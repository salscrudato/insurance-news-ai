
=================================================================================
FILE: package.json
=================================================================================

{
  "name": "insurance-news-ai",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc -b && vite build",
    "lint": "eslint .",
    "preview": "vite preview",
    "cap:sync": "npx cap sync ios",
    "ios:open": "npx cap open ios",
    "ios:run": "npx cap run ios",
    "firebase:emulators": "firebase emulators:start",
    "firebase:emulators:functions": "firebase emulators:start --only functions,hosting",
    "firebase:deploy": "npm run build && firebase deploy",
    "firebase:deploy:hosting": "npm run build && firebase deploy --only hosting",
    "firebase:deploy:functions": "firebase deploy --only functions",
    "firebase:deploy:firestore": "firebase deploy --only firestore:rules,firestore:indexes"
  },
  "dependencies": {
    "@capacitor/core": "^8.0.2",
    "@capacitor/haptics": "^8.0.0",
    "@capacitor/ios": "^8.0.2",
    "@capacitor/push-notifications": "^8.0.0",
    "@capacitor/status-bar": "^8.0.0",
    "@radix-ui/react-dialog": "^1.1.15",
    "@radix-ui/react-dropdown-menu": "^2.1.16",
    "@radix-ui/react-separator": "^1.1.8",
    "@radix-ui/react-slot": "^1.2.4",
    "@radix-ui/react-switch": "^1.2.6",
    "@radix-ui/react-tabs": "^1.1.13",
    "@tanstack/react-query": "^5.90.20",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "firebase": "^12.9.0",
    "lucide-react": "^0.563.0",
    "react": "^19.2.0",
    "react-dom": "^19.2.0",
    "react-router-dom": "^7.13.0",
    "sonner": "^2.0.7",
    "tailwind-merge": "^3.4.0"
  },
  "devDependencies": {
    "@capacitor/cli": "^8.0.2",
    "@eslint/js": "^9.39.1",
    "@tailwindcss/vite": "^4.1.18",
    "@types/node": "^24.10.12",
    "@types/react": "^19.2.5",
    "@types/react-dom": "^19.2.3",
    "@vitejs/plugin-react": "^5.1.1",
    "eslint": "^9.39.1",
    "eslint-plugin-react-hooks": "^7.0.1",
    "eslint-plugin-react-refresh": "^0.4.24",
    "firebase-tools": "^15.5.1",
    "globals": "^16.5.0",
    "tailwindcss": "^4.1.18",
    "typescript": "~5.9.3",
    "typescript-eslint": "^8.46.4",
    "vite": "^7.2.4",
    "web-push": "^3.6.7"
  }
}


=================================================================================
FILE: tsconfig.json
=================================================================================

{
  "files": [],
  "references": [
    { "path": "./tsconfig.app.json" },
    { "path": "./tsconfig.node.json" }
  ]
}


=================================================================================
FILE: tsconfig.app.json
=================================================================================

{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.app.tsbuildinfo",
    "target": "ES2022",
    "useDefineForClassFields": true,
    "lib": ["ES2022", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "types": ["vite/client"],
    "skipLibCheck": true,
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    },

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["src"]
}


=================================================================================
FILE: tsconfig.node.json
=================================================================================

{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.node.tsbuildinfo",
    "target": "ES2023",
    "lib": ["ES2023"],
    "module": "ESNext",
    "types": ["node"],
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["vite.config.ts"]
}


=================================================================================
FILE: vite.config.ts
=================================================================================

import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'
import tailwindcss from '@tailwindcss/vite'
import path from 'path'

// https://vite.dev/config/
export default defineConfig({
  plugins: [react(), tailwindcss()],
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src'),
    },
  },
})


=================================================================================
FILE: capacitor.config.ts
=================================================================================

import type { CapacitorConfig } from '@capacitor/cli';

const config: CapacitorConfig = {
  appId: 'com.insurancenewsai.app',
  appName: 'P&C Brief',
  webDir: 'dist',
  ios: {
    // Respect iOS safe areas automatically
    contentInset: 'automatic',
    scrollEnabled: true,
    // Prefer mobile content width
    preferredContentMode: 'mobile',
    // Allow the webview to extend behind status bar and home indicator
    limitsNavigationsToAppBoundDomains: false,
  },
  plugins: {
    StatusBar: {
      // Light style = dark text on light background
      style: 'LIGHT',
      backgroundColor: '#ffffff',
    },
    PushNotifications: {
      // Present push notifications when app is in foreground
      presentationOptions: ['badge', 'sound', 'alert'],
    },
  },
};

export default config;


=================================================================================
FILE: eslint.config.js
=================================================================================

import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import tseslint from 'typescript-eslint'
import { defineConfig, globalIgnores } from 'eslint/config'

export default defineConfig([
  globalIgnores(['dist']),
  {
    files: ['**/*.{ts,tsx}'],
    extends: [
      js.configs.recommended,
      tseslint.configs.recommended,
      reactHooks.configs.flat.recommended,
      reactRefresh.configs.vite,
    ],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
    },
  },
])


=================================================================================
FILE: firebase.json
=================================================================================

{
  "firestore": {
    "rules": "firestore.rules",
    "indexes": "firestore.indexes.json"
  },
  "functions": [
    {
      "source": "functions",
      "codebase": "default",
      "ignore": [
        "node_modules",
        ".git",
        "firebase-debug.log",
        "firebase-debug.*.log",
        "*.local"
      ],
      "predeploy": [
        "npm --prefix \"$RESOURCE_DIR\" run lint",
        "npm --prefix \"$RESOURCE_DIR\" run build"
      ]
    }
  ],
  "hosting": {
    "public": "dist",
    "ignore": [
      "firebase.json",
      "**/.*",
      "**/node_modules/**"
    ],
    "rewrites": [
      {
        "source": "**",
        "destination": "/index.html"
      }
    ]
  },
  "emulators": {
    "auth": {
      "port": 9099
    },
    "functions": {
      "port": 5001
    },
    "firestore": {
      "port": 8080
    },
    "hosting": {
      "port": 5002
    },
    "ui": {
      "enabled": true,
      "port": 4000
    },
    "singleProjectMode": true
  }
}



=================================================================================
FILE: firestore.rules
=================================================================================

rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // =========================================================================
    // Helper Functions
    // =========================================================================

    // Check if the request is from an authenticated user
    function isAuthenticated() {
      return request.auth != null;
    }

    // Check if the authenticated user owns this resource
    function isOwner(uid) {
      return isAuthenticated() && request.auth.uid == uid;
    }

    // =========================================================================
    // Sources Collection: sources/{sourceId}
    // Public read, server-only write (via Admin SDK)
    // =========================================================================
    match /sources/{sourceId} {
      allow read: if true;
      allow write: if false;
    }

    // =========================================================================
    // Articles Collection: articles/{articleId}
    // Public read, server-only write (via Admin SDK)
    // =========================================================================
    match /articles/{articleId} {
      allow read: if true;
      allow write: if false;
    }

    // =========================================================================
    // Briefs Collection: briefs/{date}
    // Public read, server-only write (via Admin SDK)
    // Date format: yyyy-mm-dd
    // =========================================================================
    match /briefs/{date} {
      allow read: if true;
      allow write: if false;
    }

    // =========================================================================
    // Users Collection: users/{uid}
    // Users can read/write their own profile
    // =========================================================================
    match /users/{uid} {
      // Users can read their own profile
      allow read: if isOwner(uid);
      // Profile creation/updates handled by server, but allow client reads
      allow write: if false;

      // -----------------------------------------------------------------------
      // Bookmarks Subcollection: users/{uid}/bookmarks/{articleId}
      // Users can read/write their own bookmarks
      // -----------------------------------------------------------------------
      match /bookmarks/{articleId} {
        allow read: if isOwner(uid);
        allow create: if isOwner(uid)
          && request.resource.data.articleId is string
          && request.resource.data.title is string
          && request.resource.data.sourceName is string
          && request.resource.data.url is string
          && request.resource.data.bookmarkedAt is timestamp;
        allow update: if isOwner(uid);
        allow delete: if isOwner(uid);
      }

      // -----------------------------------------------------------------------
      // Preferences Subcollection: users/{uid}/prefs/{docId}
      // Users can read/write their own preferences
      // Only "main" document is expected
      // -----------------------------------------------------------------------
      match /prefs/{docId} {
        allow read: if isOwner(uid);
        allow create: if isOwner(uid)
          && request.resource.data.enabledSourceIds is list
          && request.resource.data.enabledCategories is list
          && request.resource.data.notifications is map
          && request.resource.data.updatedAt is timestamp;
        allow update: if isOwner(uid)
          && request.resource.data.updatedAt is timestamp;
        allow delete: if isOwner(uid);
      }

      // -----------------------------------------------------------------------
      // Push Tokens Subcollection: users/{uid}/pushTokens/{token}
      // Users can read/write their own push notification tokens
      // -----------------------------------------------------------------------
      match /pushTokens/{tokenId} {
        allow read: if isOwner(uid);
        allow create: if isOwner(uid)
          && request.resource.data.token is string
          && request.resource.data.platform is string
          && request.resource.data.createdAt is timestamp
          && request.resource.data.updatedAt is timestamp;
        allow update: if isOwner(uid)
          && request.resource.data.updatedAt is timestamp;
        allow delete: if isOwner(uid);
      }

      // -----------------------------------------------------------------------
      // Chat Threads Subcollection: users/{uid}/chatThreads/{threadId}
      // Users can read/write their own chat threads
      // -----------------------------------------------------------------------
      match /chatThreads/{threadId} {
        allow read: if isOwner(uid);
        allow create: if isOwner(uid)
          && request.resource.data.title is string
          && request.resource.data.createdAt is timestamp
          && request.resource.data.updatedAt is timestamp
          && request.resource.data.scope in ["today", "7d", "30d"]
          && request.resource.data.sourceFilter in ["all", "selected"]
          && request.resource.data.category in ["all", "property", "casualty", "regulation", "claims", "reinsurance"];
        allow update: if isOwner(uid)
          && request.resource.data.updatedAt is timestamp;
        allow delete: if isOwner(uid);

        // ---------------------------------------------------------------------
        // Messages Subcollection: users/{uid}/chatThreads/{threadId}/messages/{messageId}
        // Users can read/write messages in their own threads
        // ---------------------------------------------------------------------
        match /messages/{messageId} {
          allow read: if isOwner(uid);
          allow create: if isOwner(uid)
            && request.resource.data.role in ["user", "assistant"]
            && request.resource.data.content is string
            && request.resource.data.createdAt is timestamp;
          allow update: if false; // Messages are immutable
          allow delete: if isOwner(uid);
        }
      }
    }

    // =========================================================================
    // Default: Deny all other access
    // =========================================================================
    match /{document=**} {
      allow read, write: if false;
    }
  }
}



=================================================================================
FILE: firestore.indexes.json
=================================================================================

{
  "indexes": [
    {
      "collectionGroup": "sources",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "enabled", "order": "ASCENDING" },
        { "fieldPath": "name", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "articles",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "sourceId", "order": "ASCENDING" },
        { "fieldPath": "publishedAt", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "articles",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "categories", "arrayConfig": "CONTAINS" },
        { "fieldPath": "publishedAt", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "articles",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "sourceId", "order": "ASCENDING" },
        { "fieldPath": "categories", "arrayConfig": "CONTAINS" },
        { "fieldPath": "publishedAt", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "articles",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "isRelevant", "order": "ASCENDING" },
        { "fieldPath": "publishedAt", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "articles",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "publishedAt", "order": "ASCENDING" },
        { "fieldPath": "isRelevant", "order": "ASCENDING" }
      ]
    }
  ],
  "fieldOverrides": []
}



=================================================================================
FILE: index.html
=================================================================================

<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover, maximum-scale=1" />
    <meta name="theme-color" content="#FFFFFF" />
    <meta name="mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="default" />
    <meta name="description" content="Insurance industry news and insights powered by AI" />
    <title>P&C Brief</title>
    <!-- Favicon - Shield logo -->
    <link rel="icon" type="image/svg+xml" href="/logo.svg" />
    <link rel="icon" type="image/png" sizes="192x192" href="/icons/icon-192.png" />
    <link rel="apple-touch-icon" sizes="180x180" href="/icons/icon-192.png" />
    <!-- PWA Manifest -->
    <link rel="manifest" href="/manifest.json" />
    <meta name="apple-mobile-web-app-title" content="P&C Brief" />
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>


=================================================================================
FILE: src/App.tsx
=================================================================================

import { useEffect } from "react"
import { BrowserRouter, Routes, Route } from "react-router-dom"
import { QueryClientProvider } from "@tanstack/react-query"
import { Capacitor } from "@capacitor/core"
import { StatusBar, Style } from "@capacitor/status-bar"
import { queryClient } from "@/lib/query-client"
import { AuthProvider } from "@/lib/auth-context"
import { MainLayout } from "@/layouts/MainLayout"
import { Toaster } from "@/components/ui/sonner"
import {
  TodayPage,
  FeedPage,
  SourcesPage,
  BookmarksPage,
  SettingsPage,
  AskPage,
} from "@/pages"

function App() {
  // Configure iOS status bar on app load
  useEffect(() => {
    if (Capacitor.isNativePlatform()) {
      // Set status bar to light style (dark text) for our light UI
      StatusBar.setStyle({ style: Style.Light }).catch(() => {
        // Ignore errors on unsupported platforms
      })
    }
  }, [])

  return (
    <QueryClientProvider client={queryClient}>
      <AuthProvider>
        <BrowserRouter>
          <Routes>
            <Route element={<MainLayout />}>
              <Route path="/" element={<TodayPage />} />
              <Route path="/feed" element={<FeedPage />} />
              <Route path="/ask" element={<AskPage />} />
              <Route path="/sources" element={<SourcesPage />} />
              <Route path="/bookmarks" element={<BookmarksPage />} />
              <Route path="/settings" element={<SettingsPage />} />
            </Route>
          </Routes>
        </BrowserRouter>
        <Toaster />
      </AuthProvider>
    </QueryClientProvider>
  )
}

export default App


=================================================================================
FILE: src/components/brief/ArticleSheet.tsx
=================================================================================

/**
 * Article detail sheet/modal for Today page
 *
 * Shows headline, source, why it matters, snippet, and actions:
 * - Read on source (external link)
 * - Bookmark toggle
 */

import { Sheet, SheetContent, SheetDescription, SheetTitle } from "@/components/ui/sheet"
import {
  SHEET_TOKENS,
  SheetHeaderBlock,
  SheetSection,
  SheetSectionCard,
  SheetSnippet,
  SheetActions,
  SheetIconButton,
} from "@/components/ui/sheet-primitives"
import { Bookmark } from "lucide-react"
import { toast } from "sonner"
import { Timestamp } from "firebase/firestore"
import { useIsBookmarked, useToggleBookmark } from "@/lib/hooks"
import { useAuth } from "@/lib/auth-context"
import type { TopStoryWithArticle } from "@/lib/hooks/use-today-brief"
import type { Article } from "@/types/firestore"
import { hapticLight } from "@/lib/haptics"

interface ArticleSheetProps {
  story: TopStoryWithArticle | null
  open: boolean
  onOpenChange: (open: boolean) => void
}

export function ArticleSheet({ story, open, onOpenChange }: ArticleSheetProps) {
  const { isAuthenticated } = useAuth()
  const { data: isBookmarked } = useIsBookmarked(story?.article?.id)
  const toggleBookmark = useToggleBookmark()

  // Null safety: don't render if story or article is missing
  if (!story || !story.article) return null

  // Destructure for cleaner access (article is guaranteed non-null here)
  const { article } = story

  const handleOpenArticle = () => {
    hapticLight()
    window.open(article.url, "_blank", "noopener,noreferrer")
  }

  const handleBookmark = () => {
    if (!isAuthenticated) {
      toast.error("Sign in to bookmark articles")
      return
    }
    hapticLight()

    // Create a minimal Article object for bookmarking
    // The bookmark only stores essential fields anyway
    const minimalArticle: Article = {
      id: article.id,
      sourceId: article.sourceId ?? "",
      sourceName: article.sourceName,
      title: article.title,
      snippet: article.snippet,
      url: article.url,
      canonicalUrl: article.url,
      guid: null,
      imageUrl: article.imageUrl,
      categories: [],
      publishedAt: Timestamp.fromDate(new Date(article.publishedAt)),
      ingestedAt: Timestamp.now(),
      relevanceScore: 1,
      isRelevant: true,
      ai: null,
    }

    toggleBookmark.mutate(
      { article: minimalArticle, isCurrentlyBookmarked: !!isBookmarked },
      {
        onSuccess: ({ bookmarked }) => {
          toast.success(bookmarked ? "Article saved" : "Bookmark removed")
        },
        onError: () => {
          toast.error("Failed to update bookmark")
        },
      }
    )
  }

  return (
    <Sheet open={open} onOpenChange={onOpenChange}>
      <SheetContent
        side="bottom"
        hideCloseButton
        className={SHEET_TOKENS.containerClass}
      >
        {/* Drag indicator */}
        <div className={SHEET_TOKENS.dragIndicatorClass} />

        {/* Accessibility: Visually hidden title for screen readers */}
        <SheetTitle className="sr-only">{story.headline}</SheetTitle>
        <SheetDescription className="sr-only">
          Article details from {article.sourceName}
        </SheetDescription>

        {/* Header */}
        <SheetHeaderBlock
          source={article.sourceName}
          title={story.headline}
        />

        {/* Image */}
        {article.imageUrl && (
          <div className={SHEET_TOKENS.imageClass}>
            <img
              src={article.imageUrl}
              alt=""
              className="h-full w-full object-cover"
            />
          </div>
        )}

        {/* Why It Matters Card */}
        <SheetSectionCard
          className={SHEET_TOKENS.sectionMargin}
          footer={
            <p className="text-[11px] text-[var(--color-text-tertiary)]">
              Summary generated by AI. Read original source for full article.
            </p>
          }
        >
          <SheetSection label="Why It Matters">
            {story.whyItMatters}
          </SheetSection>
        </SheetSectionCard>

        {/* Snippet */}
        {article.snippet && (
          <SheetSnippet>{article.snippet}</SheetSnippet>
        )}

        {/* Actions */}
        <SheetActions
          onReadArticle={handleOpenArticle}
          secondaryButton={
            <SheetIconButton
              onClick={handleBookmark}
              disabled={toggleBookmark.isPending}
              loading={toggleBookmark.isPending}
              aria-label={isBookmarked ? "Remove bookmark" : "Bookmark article"}
            >
              <Bookmark
                className="h-[20px] w-[20px]"
                fill={isBookmarked ? "currentColor" : "none"}
              />
            </SheetIconButton>
          }
        />
      </SheetContent>
    </Sheet>
  )
}



=================================================================================
FILE: src/components/brief/BriefSections.tsx
=================================================================================

/**
 * Category section blocks for the daily brief
 *
 * Premium design with:
 * - Muted, consistent icon background chips
 * - Improved bullet readability and spacing
 * - Clean section separators
 */

import {
  Building2,
  Scale,
  ClipboardList,
  FileText,
  RefreshCw,
  Lightbulb,
  TrendingUp,
  type LucideIcon,
} from "lucide-react"
import { Card, Separator } from "@/components/ui"
import type { BriefSection } from "@/types/firestore"

// Section display configuration with muted, sophisticated colors
// Using consistent opacity/saturation for a cohesive look
const SECTION_CONFIG: Record<string, { label: string; icon: LucideIcon; color: string; bgOpacity: string }> = {
  propertyCat: { label: "Property & Cat", icon: Building2, color: "#007AFF", bgOpacity: "10%" },
  casualtyLiability: { label: "Casualty & Liability", icon: Scale, color: "#8E8E93", bgOpacity: "12%" },
  regulation: { label: "Regulation", icon: ClipboardList, color: "#5856D6", bgOpacity: "10%" },
  claims: { label: "Claims", icon: FileText, color: "#FF9500", bgOpacity: "10%" },
  reinsurance: { label: "Reinsurance", icon: RefreshCw, color: "#32ADE6", bgOpacity: "12%" },
  insurtech: { label: "InsurTech", icon: Lightbulb, color: "#34C759", bgOpacity: "10%" },
  market: { label: "Market & M&A", icon: TrendingUp, color: "#AF52DE", bgOpacity: "10%" },
}

interface SectionBlockProps {
  sectionKey: string
  section: BriefSection
  isLast: boolean
}

function SectionBlock({ sectionKey, section, isLast }: SectionBlockProps) {
  const config = SECTION_CONFIG[sectionKey]

  if (!config || section.bullets.length === 0) {
    return null
  }

  const Icon = config.icon

  return (
    <div>
      {/* Section Header */}
      <div className="flex items-center gap-[8px] px-[14px] py-[10px]">
        <div
          className="flex h-[26px] w-[26px] items-center justify-center rounded-[6px]"
          style={{ backgroundColor: `color-mix(in srgb, ${config.color} ${config.bgOpacity}, transparent)` }}
        >
          <Icon
            className="h-[14px] w-[14px]"
            strokeWidth={1.75}
            style={{ color: config.color, opacity: 0.85 }}
          />
        </div>
        <h3 className="text-[14px] font-semibold tracking-[-0.2px] text-[var(--color-text-primary)]">
          {config.label}
        </h3>
      </div>

      {/* Bullets */}
      <ul className="space-y-[6px] px-[14px] pb-[12px]">
        {section.bullets.map((bullet, index) => (
          <li
            key={index}
            className="flex gap-[8px] text-[14px] leading-[1.42] tracking-[-0.1px] text-[var(--color-text-secondary)]"
          >
            <span
              className="mt-[7px] h-[4px] w-[4px] shrink-0 rounded-full"
              style={{ backgroundColor: config.color, opacity: 0.5 }}
            />
            <span>{bullet}</span>
          </li>
        ))}
      </ul>

      {/* Section separator */}
      {!isLast && <Separator className="mx-[14px]" />}
    </div>
  )
}

interface BriefSectionsProps {
  sections: {
    propertyCat: BriefSection
    casualtyLiability: BriefSection
    regulation: BriefSection
    claims: BriefSection
    reinsurance: BriefSection
    insurtech: BriefSection
    market: BriefSection
  }
}

export function BriefSections({ sections }: BriefSectionsProps) {
  // Filter to only show sections with content
  const sectionEntries = Object.entries(sections).filter(
    ([, section]) => section.bullets.length > 0
  )

  if (sectionEntries.length === 0) {
    return null
  }

  return (
    <Card>
      {sectionEntries.map(([key, section], index) => (
        <SectionBlock
          key={key}
          sectionKey={key}
          section={section}
          isLast={index === sectionEntries.length - 1}
        />
      ))}
    </Card>
  )
}



=================================================================================
FILE: src/components/brief/BriefSkeleton.tsx
=================================================================================

/**
 * Skeleton loading states for the Today screen
 *
 * Matches the premium Daily Brief design
 */

import { Skeleton } from "@/components/ui/skeleton"

export function ExecutiveSummarySkeleton() {
  return (
    <div className="space-y-[12px]">
      <div className="flex gap-[12px]">
        <Skeleton className="mt-[8px] h-[6px] w-[6px] shrink-0 rounded-full" />
        <Skeleton className="h-[20px] flex-1" />
      </div>
      <div className="flex gap-[12px]">
        <Skeleton className="mt-[8px] h-[6px] w-[6px] shrink-0 rounded-full" />
        <Skeleton className="h-[20px] w-11/12" />
      </div>
      <div className="flex gap-[12px]">
        <Skeleton className="mt-[8px] h-[6px] w-[6px] shrink-0 rounded-full" />
        <Skeleton className="h-[20px] w-10/12" />
      </div>
    </div>
  )
}

export function TopStoryCardSkeleton() {
  return (
    <div className="w-[280px] shrink-0 snap-start overflow-hidden rounded-[14px] bg-[var(--color-surface)] shadow-[0_1px_3px_rgba(0,0,0,0.04),0_0_0_0.5px_rgba(0,0,0,0.02)]">
      <Skeleton className="aspect-[16/9] w-full rounded-none" />
      <div className="p-[14px]">
        <Skeleton className="mb-[5px] h-[11px] w-[64px]" />
        <Skeleton className="mb-[6px] h-[17px] w-full" />
        <Skeleton className="h-[14px] w-4/5" />
      </div>
    </div>
  )
}

export function TopStoriesCarouselSkeleton() {
  return (
    <div className="-mx-[var(--spacing-4)] flex gap-[10px] overflow-hidden px-[var(--spacing-4)]">
      <TopStoryCardSkeleton />
      <TopStoryCardSkeleton />
    </div>
  )
}

export function SectionSkeleton() {
  return (
    <div>
      <div className="flex items-center gap-[10px] px-[16px] py-[12px]">
        <Skeleton className="h-[30px] w-[30px] rounded-[8px]" />
        <Skeleton className="h-[17px] w-28" />
      </div>
      <div className="space-y-[8px] px-[16px] pb-[16px]">
        <div className="flex gap-[10px]">
          <Skeleton className="mt-[8px] h-[5px] w-[5px] shrink-0 rounded-full" />
          <Skeleton className="h-[16px] flex-1" />
        </div>
        <div className="flex gap-[10px]">
          <Skeleton className="mt-[8px] h-[5px] w-[5px] shrink-0 rounded-full" />
          <Skeleton className="h-[16px] w-11/12" />
        </div>
      </div>
    </div>
  )
}

export function TodayScreenSkeleton() {
  return (
    <div className="space-y-[28px]">
      {/* Date */}
      <header className="-mt-[4px]">
        <Skeleton className="h-[15px] w-44" />
      </header>

      {/* Executive Summary Card */}
      <section className="overflow-hidden rounded-[16px] bg-[var(--color-surface)] shadow-[0_1px_3px_rgba(0,0,0,0.04),0_0_0_0.5px_rgba(0,0,0,0.02)]">
        {/* Card header */}
        <div className="flex items-center justify-between border-b border-[var(--color-separator)] px-[18px] py-[12px]">
          <Skeleton className="h-[22px] w-[100px] rounded-full" />
          <Skeleton className="h-[11px] w-[90px]" />
        </div>
        {/* Bullets */}
        <div className="px-[18px] py-[18px]">
          <ExecutiveSummarySkeleton />
        </div>
      </section>

      {/* Top Stories */}
      <section className="space-y-[10px]">
        <Skeleton className="h-[12px] w-20" />
        <TopStoriesCarouselSkeleton />
      </section>

      {/* Sections */}
      <section className="space-y-[10px]">
        <Skeleton className="h-[12px] w-24" />
        <div className="overflow-hidden rounded-[16px] bg-[var(--color-surface)] shadow-[0_1px_3px_rgba(0,0,0,0.04),0_0_0_0.5px_rgba(0,0,0,0.02)]">
          <SectionSkeleton />
          <div className="mx-[16px] h-[0.5px] bg-[var(--color-separator)]" />
          <SectionSkeleton />
        </div>
      </section>
    </div>
  )
}



=================================================================================
FILE: src/components/brief/index.ts
=================================================================================

/**
 * Brief components exports
 */

export { TodayScreenSkeleton, TopStoriesCarouselSkeleton, SectionSkeleton, ExecutiveSummarySkeleton } from "./BriefSkeleton"
export { TopStoriesCarousel } from "./TopStoriesCarousel"
export { BriefSections } from "./BriefSections"
export { ArticleSheet } from "./ArticleSheet"



=================================================================================
FILE: src/components/brief/TopStoriesCarousel.tsx
=================================================================================

/**
 * Horizontal scrolling carousel of top stories
 * Styled to match Feed ArticleCard for visual consistency
 */

import type { TopStoryWithArticle } from "@/lib/hooks/use-today-brief"

/** Accept Firestore Timestamp, ISO string, or ms number (e.g. from today brief API). */
function formatRelativeTime(timestamp: { toDate(): Date } | string | number | Date): string {
  const date =
    typeof timestamp === "string" || typeof timestamp === "number"
      ? new Date(timestamp)
      : timestamp instanceof Date
        ? timestamp
        : timestamp.toDate()
  const now = new Date()
  const diffMs = now.getTime() - date.getTime()
  const diffMins = Math.floor(diffMs / (1000 * 60))
  const diffHours = Math.floor(diffMs / (1000 * 60 * 60))
  const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24))

  if (diffMins < 60) {
    return `${diffMins}m`
  } else if (diffHours < 24) {
    return `${diffHours}h`
  } else if (diffDays < 7) {
    return `${diffDays}d`
  } else {
    return date.toLocaleDateString("en-US", { month: "short", day: "numeric" })
  }
}

interface TopStoryCardProps {
  story: TopStoryWithArticle
  onSelect: (story: TopStoryWithArticle) => void
}

function TopStoryCard({ story, onSelect }: TopStoryCardProps) {
  // Defensive: skip rendering if article is null (deleted from Firestore)
  if (!story.article) {
    return null
  }

  return (
    <button
      onClick={() => onSelect(story)}
      className="group w-[300px] shrink-0 snap-start overflow-hidden rounded-[var(--radius-xl)] bg-[var(--color-surface)] text-left shadow-[var(--shadow-card)] transition-all duration-[var(--duration-normal)] active:scale-[0.98]"
      aria-label={`Read story: ${story.headline}`}
    >
      {/* Image */}
      {story.article.imageUrl && (
        <div className="aspect-[2/1] w-full overflow-hidden bg-[var(--color-fill-quaternary)]">
          <img
            src={story.article.imageUrl}
            alt=""
            className="h-full w-full object-cover transition-transform duration-[var(--duration-slow)] group-hover:scale-[1.02]"
            loading="lazy"
          />
        </div>
      )}

      {/* Content */}
      <div className="p-[var(--spacing-4)]">
        {/* Source and timestamp */}
        <div className="mb-[var(--spacing-2)] flex items-center gap-[var(--spacing-2)]">
          <span className="inline-block rounded-full bg-[var(--color-fill-quaternary)] px-[var(--spacing-2)] py-[2px] text-[11px] font-medium text-[var(--color-text-secondary)]">
            {story.article.sourceName}
          </span>
          <span className="text-[12px] text-[var(--color-text-tertiary)]">
            {formatRelativeTime(story.article.publishedAt)}
          </span>
        </div>

        {/* Headline */}
        <h3 className="mb-[var(--spacing-2)] line-clamp-2 text-[17px] font-semibold leading-snug tracking-tight text-[var(--color-text-primary)]">
          {story.headline}
        </h3>

        {/* Why it matters */}
        <p className="line-clamp-2 text-[14px] leading-relaxed text-[var(--color-text-secondary)]">
          {story.whyItMatters}
        </p>
      </div>
    </button>
  )
}

interface TopStoriesCarouselProps {
  stories: TopStoryWithArticle[]
  onSelectStory: (story: TopStoryWithArticle) => void
}

export function TopStoriesCarousel({ stories, onSelectStory }: TopStoriesCarouselProps) {
  // Filter out stories where article was deleted (null)
  const validStories = stories.filter((story) => story.article !== null)

  if (validStories.length === 0) {
    return null
  }

  return (
    <div
      className="overflow-x-auto scrollbar-none"
      role="region"
      aria-label="Top stories carousel"
    >
      <div className="flex snap-x snap-mandatory gap-[var(--spacing-3)] px-[var(--spacing-4)] pb-[var(--spacing-2)]">
        {validStories.map((story) => (
          <TopStoryCard
            key={story.articleId}
            story={story}
            onSelect={onSelectStory}
          />
        ))}
        {/* End spacer for scroll padding */}
        <div className="w-[var(--spacing-4)] shrink-0" />
      </div>
    </div>
  )
}



=================================================================================
FILE: src/components/feed/ArticleCard.tsx
=================================================================================

/**
 * Article Card component for the feed
 * Premium iOS news reader design - tight typography, subtle styling
 */

import { Sparkles } from "lucide-react"
import type { Article } from "@/types/firestore"
import type { Timestamp } from "firebase/firestore"

interface ArticleCardProps {
  article: Article
  onSelect: (article: Article) => void
}

function formatRelativeTime(timestamp: Timestamp): string {
  const date = timestamp.toDate()
  const now = new Date()
  const diffMs = now.getTime() - date.getTime()
  const diffMins = Math.floor(diffMs / (1000 * 60))
  const diffHours = Math.floor(diffMs / (1000 * 60 * 60))
  const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24))

  if (diffMins < 60) {
    return `${diffMins}m`
  } else if (diffHours < 24) {
    return `${diffHours}h`
  } else if (diffDays < 7) {
    return `${diffDays}d`
  } else {
    return date.toLocaleDateString("en-US", { month: "short", day: "numeric" })
  }
}

export function ArticleCard({ article, onSelect }: ArticleCardProps) {
  const handleClick = () => {
    onSelect(article)
  }

  const hasAI = Boolean(article.ai?.tldr)
  const hasImage = Boolean(article.imageUrl)

  return (
    <article
      role="button"
      tabIndex={0}
      onClick={handleClick}
      onKeyDown={(e) => {
        if (e.key === "Enter" || e.key === " ") {
          e.preventDefault()
          handleClick()
        }
      }}
      className="content-visibility-auto group cursor-pointer overflow-hidden rounded-[var(--radius-lg)] bg-[var(--color-surface)] shadow-[0_0_0_0.5px_var(--color-separator)] transition-all duration-[var(--duration-fast)] ease-[var(--ease-ios)] active:scale-[0.985] active:bg-[var(--color-fill-quaternary)] focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-[var(--color-accent)] focus-visible:ring-offset-2"
    >
      {/* Image - consistent 2:1 aspect ratio */}
      {hasImage && article.imageUrl && (
        <div className="aspect-[2/1] w-full overflow-hidden bg-[var(--color-fill-quaternary)]">
          <img
            src={article.imageUrl}
            alt=""
            className="h-full w-full object-cover"
            loading="lazy"
          />
        </div>
      )}

      {/* Content - consistent padding regardless of image */}
      <div className={hasImage ? "px-[14px] py-[12px]" : "px-[14px] py-[14px]"}>
        {/* Meta row: Source · Time · subtle AI indicator */}
        <div className="mb-[6px] flex items-center gap-[5px]">
          <span className="text-[12px] font-semibold tracking-[-0.1px] text-[var(--color-text-secondary)]">
            {article.sourceName}
          </span>
          <span className="text-[11px] text-[var(--color-text-quaternary)]">·</span>
          <span className="text-[12px] text-[var(--color-text-tertiary)]">
            {formatRelativeTime(article.publishedAt)}
          </span>
          {hasAI && (
            <Sparkles className="ml-auto h-[11px] w-[11px] text-[var(--color-text-quaternary)] opacity-70" strokeWidth={2} />
          )}
        </div>

        {/* Headline */}
        <h3 className="line-clamp-2 text-[15px] font-semibold leading-[1.33] tracking-[-0.2px] text-[var(--color-text-primary)]">
          {article.title}
        </h3>

        {/* Snippet - always show, keep it tight */}
        <p className="mt-[6px] line-clamp-2 text-[13px] leading-[1.38] tracking-[-0.08px] text-[var(--color-text-tertiary)]">
          {article.ai?.tldr ?? article.snippet}
        </p>
      </div>
    </article>
  )
}

export function ArticleCardSkeleton() {
  return (
    <div className="overflow-hidden rounded-[var(--radius-lg)] bg-[var(--color-surface)] shadow-[0_0_0_0.5px_var(--color-separator)]">
      {/* Image skeleton */}
      <div className="aspect-[2/1] w-full skeleton-shimmer" />

      {/* Content skeleton */}
      <div className="px-[14px] py-[12px]">
        {/* Meta row */}
        <div className="mb-[6px] flex items-center gap-[5px]">
          <div className="h-[11px] w-[60px] rounded-[3px] skeleton-shimmer" />
          <div className="h-[11px] w-[24px] rounded-[3px] skeleton-shimmer" />
        </div>

        {/* Headline */}
        <div className="space-y-[5px]">
          <div className="h-[14px] w-full rounded-[3px] skeleton-shimmer" />
          <div className="h-[14px] w-[85%] rounded-[3px] skeleton-shimmer" />
        </div>

        {/* Snippet */}
        <div className="mt-[6px] space-y-[4px]">
          <div className="h-[12px] w-full rounded-[3px] skeleton-shimmer" />
          <div className="h-[12px] w-[70%] rounded-[3px] skeleton-shimmer" />
        </div>
      </div>
    </div>
  )
}



=================================================================================
FILE: src/components/feed/ArticleDetailSheet.tsx
=================================================================================

/**
 * Article detail sheet for the feed
 *
 * Shows headline, source, publish time, snippet, and actions:
 * - Read on source (external link)
 * - Generate TL;DR (calls getOrCreateArticleAI)
 * - Bookmark toggle
 */

import { useState, useEffect } from "react"
import { Sheet, SheetContent, SheetDescription, SheetTitle } from "@/components/ui/sheet"
import { Button } from "@/components/ui/button"
import { Skeleton } from "@/components/ui/skeleton"
import {
  SHEET_TOKENS,
  SheetHeaderBlock,
  SheetSection,
  SheetSnippet,
  SheetActions,
  SheetIconButton,
} from "@/components/ui/sheet-primitives"
import { Bookmark, Sparkles } from "lucide-react"
import { toast } from "sonner"
import { useIsBookmarked, useToggleBookmark, useArticleAI } from "@/lib/hooks"
import { useAuth } from "@/lib/auth-context"
import type { Article, ArticleAI } from "@/types/firestore"
import type { Timestamp } from "firebase/firestore"
import { hapticLight } from "@/lib/haptics"

interface ArticleDetailSheetProps {
  article: Article | null
  open: boolean
  onOpenChange: (open: boolean) => void
}

function formatDate(timestamp: Timestamp | null | undefined): string {
  if (!timestamp || typeof timestamp.toDate !== "function") {
    return "Date unavailable"
  }
  try {
    return timestamp.toDate().toLocaleDateString("en-US", {
      weekday: "short",
      month: "short",
      day: "numeric",
      hour: "numeric",
      minute: "2-digit",
    })
  } catch {
    return "Date unavailable"
  }
}

export function ArticleDetailSheet({
  article,
  open,
  onOpenChange,
}: ArticleDetailSheetProps) {
  const { isAuthenticated } = useAuth()
  const { data: isBookmarked } = useIsBookmarked(article?.id)
  const toggleBookmark = useToggleBookmark()
  const generateAI = useArticleAI()

  // Local state for AI content (combines cached article.ai with generated)
  const [aiContent, setAiContent] = useState<ArticleAI | null>(null)

  // Reset AI content when article changes
  useEffect(() => {
    if (article?.ai) {
      setAiContent(article.ai)
    } else {
      setAiContent(null)
    }
  }, [article?.id, article?.ai])

  if (!article) return null

  const handleOpenArticle = () => {
    hapticLight()
    window.open(article.url, "_blank", "noopener,noreferrer")
  }

  const handleBookmark = () => {
    if (!isAuthenticated) {
      toast.error("Sign in to bookmark articles")
      return
    }
    hapticLight()

    toggleBookmark.mutate(
      { article, isCurrentlyBookmarked: !!isBookmarked },
      {
        onSuccess: ({ bookmarked }) => {
          toast.success(bookmarked ? "Article saved" : "Bookmark removed")
        },
        onError: () => {
          toast.error("Failed to update bookmark")
        },
      }
    )
  }

  const handleGenerateAI = () => {
    if (!isAuthenticated) {
      toast.error("Sign in to generate summaries")
      return
    }
    hapticLight()

    generateAI.mutate(article.id, {
      onSuccess: (data) => {
        // Convert generatedAt string to Timestamp-like object for display
        setAiContent({
          ...data.ai,
          generatedAt: { toDate: () => new Date(data.ai.generatedAt) } as unknown as Timestamp,
        } as ArticleAI)

        if (!data.cached) {
          toast.success("Summary generated", {
            description: `${data.remaining} summaries remaining today`,
          })
        }
      },
      onError: (error) => {
        console.error("Failed to generate AI:", error)
        toast.error("Failed to generate summary", {
          description: "Please try again later",
        })
      },
    })
  }

  const hasAI = !!aiContent
  const isGenerating = generateAI.isPending

  return (
    <Sheet open={open} onOpenChange={onOpenChange}>
      <SheetContent
        side="bottom"
        hideCloseButton
        className={SHEET_TOKENS.containerClass}
      >
        {/* Drag indicator */}
        <div className={SHEET_TOKENS.dragIndicatorClass} />

        {/* Header */}
        {/* Accessibility: Visually hidden title for screen readers */}
        <SheetTitle className="sr-only">{article.title}</SheetTitle>
        <SheetDescription className="sr-only">
          Article details from {article.sourceName}
        </SheetDescription>

        <SheetHeaderBlock
          source={article.sourceName}
          timestamp={formatDate(article.publishedAt)}
          title={article.title}
        />

        {/* Image */}
        {article.imageUrl && (
          <div className={SHEET_TOKENS.imageClass}>
            <img
              src={article.imageUrl}
              alt=""
              className="h-full w-full object-cover"
            />
          </div>
        )}

        {/* AI Summary section */}
        {isGenerating ? (
          <div className="mb-[24px] overflow-hidden rounded-[var(--radius-2xl)] bg-[var(--color-fill-quaternary)]">
            <div className="border-b border-[var(--color-separator)] px-[18px] py-[16px]">
              <Skeleton className="mb-[12px] h-4 w-16" />
              <Skeleton className="h-4 w-full" />
              <Skeleton className="mt-[8px] h-4 w-3/4" />
            </div>
            <div className="px-[18px] py-[16px]">
              <Skeleton className="mb-[12px] h-4 w-24" />
              <Skeleton className="h-4 w-full" />
              <Skeleton className="mt-[8px] h-4 w-5/6" />
            </div>
          </div>
        ) : hasAI ? (
          <div className="mb-[24px] overflow-hidden rounded-[var(--radius-2xl)] bg-[var(--color-fill-quaternary)]">
            <div className="border-b border-[var(--color-separator)] px-[18px] py-[16px]">
              <SheetSection label="TL;DR">{aiContent.tldr}</SheetSection>
            </div>

            <div className="px-[18px] py-[16px]">
              <SheetSection label="Why It Matters">
                {aiContent.whyItMatters}
              </SheetSection>
            </div>

            {/* Topics */}
            {aiContent.topics && aiContent.topics.length > 0 && (
              <div className="flex flex-wrap gap-[6px] border-t border-[var(--color-separator)] px-[18px] py-[13px]">
                {aiContent.topics.map((topic) => (
                  <span
                    key={topic}
                    className="rounded-full bg-[var(--color-surface)] px-[12px] py-[6px] text-[12px] font-medium tracking-[-0.05px] text-[var(--color-text-secondary)]"
                  >
                    {topic}
                  </span>
                ))}
              </div>
            )}

            {/* AI Disclaimer */}
            <div className="border-t border-[var(--color-separator)] px-[18px] py-[10px]">
              <p className="text-[11px] text-[var(--color-text-tertiary)]">
                Summary generated by AI. Read original source for full article.
              </p>
            </div>
          </div>
        ) : (
          /* Generate TL;DR button when no AI available */
          <div className={SHEET_TOKENS.sectionMargin}>
            <Button
              variant="outline"
              size="lg"
              className="w-full gap-[10px]"
              onClick={handleGenerateAI}
              disabled={isGenerating}
            >
              <Sparkles className="h-[18px] w-[18px]" />
              <span>Generate AI Summary</span>
            </Button>
          </div>
        )}

        {/* Snippet */}
        {article.snippet && <SheetSnippet>{article.snippet}</SheetSnippet>}

        {/* Actions */}
        <SheetActions
          onReadArticle={handleOpenArticle}
          secondaryButton={
            <SheetIconButton
              onClick={handleBookmark}
              disabled={toggleBookmark.isPending}
              loading={toggleBookmark.isPending}
              aria-label={isBookmarked ? "Remove bookmark" : "Bookmark article"}
            >
              <Bookmark
                className="h-[20px] w-[20px]"
                fill={isBookmarked ? "currentColor" : "none"}
              />
            </SheetIconButton>
          }
        />
      </SheetContent>
    </Sheet>
  )
}



=================================================================================
FILE: src/components/feed/ArticleRow.tsx
=================================================================================

/**
 * Article row component for the feed list
 */

import { Bookmark, Loader2 } from "lucide-react"
import { Badge } from "@/components/ui/badge"
import { toast } from "sonner"
import { useIsBookmarked, useToggleBookmark } from "@/lib/hooks"
import { useAuth } from "@/lib/auth-context"
import type { Article } from "@/types/firestore"
import type { Timestamp } from "firebase/firestore"

interface ArticleRowProps {
  article: Article
  onSelect: (article: Article) => void
  showBookmark?: boolean
}

function formatRelativeTime(timestamp: Timestamp): string {
  const date = timestamp.toDate()
  const now = new Date()
  const diffMs = now.getTime() - date.getTime()
  const diffMins = Math.floor(diffMs / (1000 * 60))
  const diffHours = Math.floor(diffMs / (1000 * 60 * 60))
  const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24))

  if (diffMins < 60) {
    return `${diffMins}m ago`
  } else if (diffHours < 24) {
    return `${diffHours}h ago`
  } else if (diffDays < 7) {
    return `${diffDays}d ago`
  } else {
    return date.toLocaleDateString("en-US", { month: "short", day: "numeric" })
  }
}

export function ArticleRow({ article, onSelect, showBookmark = true }: ArticleRowProps) {
  const { isAuthenticated } = useAuth()
  const { data: isBookmarked } = useIsBookmarked(showBookmark ? article.id : undefined)
  const toggleBookmark = useToggleBookmark()

  const handleBookmarkClick = (e: React.MouseEvent) => {
    e.stopPropagation()

    if (!isAuthenticated) {
      toast.error("Sign in to bookmark articles")
      return
    }

    toggleBookmark.mutate(
      { article, isCurrentlyBookmarked: !!isBookmarked },
      {
        onSuccess: ({ bookmarked }) => {
          toast.success(bookmarked ? "Article saved" : "Bookmark removed")
        },
        onError: () => {
          toast.error("Failed to update bookmark")
        },
      }
    )
  }

  const handleRowClick = () => {
    onSelect(article)
  }

  return (
    <div
      role="button"
      tabIndex={0}
      onClick={handleRowClick}
      onKeyDown={(e) => {
        if (e.key === "Enter" || e.key === " ") {
          e.preventDefault()
          handleRowClick()
        }
      }}
      className="flex w-full cursor-pointer gap-3 border-b border-[var(--color-border)] px-[var(--spacing-md)] py-[var(--spacing-md)] text-left transition-colors hover:bg-[var(--color-surface)] active:bg-[var(--color-surface)]"
    >
      {/* Content */}
      <div className="min-w-0 flex-1">
        {/* Source and time */}
        <div className="mb-1 flex items-center gap-2">
          <Badge variant="secondary" className="text-[11px]">
            {article.sourceName}
          </Badge>
          <span className="text-[12px] text-[var(--color-text-tertiary)]">
            {formatRelativeTime(article.publishedAt)}
          </span>
        </div>

        {/* Headline */}
        <h3 className="mb-1 line-clamp-2 text-[15px] font-semibold leading-snug text-[var(--color-text-primary)]">
          {article.title}
        </h3>

        {/* Snippet */}
        <p className="line-clamp-1 text-[13px] leading-relaxed text-[var(--color-text-secondary)]">
          {article.snippet}
        </p>
      </div>

      {/* Bookmark button */}
      {showBookmark && (
        <button
          onClick={handleBookmarkClick}
          disabled={toggleBookmark.isPending}
          className="shrink-0 self-start rounded-full p-2 text-[var(--color-text-tertiary)] transition-colors hover:bg-[var(--color-surface)] hover:text-[var(--color-accent)] disabled:opacity-50"
          aria-label={isBookmarked ? "Remove bookmark" : "Add bookmark"}
        >
          {toggleBookmark.isPending ? (
            <Loader2 className="h-5 w-5 animate-spin" />
          ) : (
            <Bookmark
              className="h-5 w-5"
              fill={isBookmarked ? "currentColor" : "none"}
            />
          )}
        </button>
      )}
    </div>
  )
}

export function ArticleRowSkeleton() {
  return (
    <div className="flex gap-3 border-b border-[var(--color-border)] px-[var(--spacing-md)] py-[var(--spacing-md)]">
      <div className="min-w-0 flex-1 space-y-2">
        <div className="flex items-center gap-2">
          <div className="h-5 w-20 animate-pulse rounded-full bg-[var(--color-surface)]" />
          <div className="h-4 w-12 animate-pulse rounded bg-[var(--color-surface)]" />
        </div>
        <div className="h-5 w-full animate-pulse rounded bg-[var(--color-surface)]" />
        <div className="h-5 w-3/4 animate-pulse rounded bg-[var(--color-surface)]" />
        <div className="h-4 w-full animate-pulse rounded bg-[var(--color-surface)]" />
      </div>
      <div className="h-9 w-9 shrink-0 animate-pulse rounded-full bg-[var(--color-surface)]" />
    </div>
  )
}



=================================================================================
FILE: src/components/feed/FeedFilters.tsx
=================================================================================

/**
 * Filter components for the Feed page
 * Refined iOS-native design with compact, elegant controls
 */

import { useState } from "react"
import { ChevronDown, Check, Clock, Newspaper } from "lucide-react"
import { Button } from "@/components/ui/button"
import {
  Sheet,
  SheetContent,
  SheetHeader,
  SheetTitle,
  SheetTrigger,
} from "@/components/ui/sheet"
import type { SourceCategory } from "@/types/firestore"
import { cn } from "@/lib/utils"
import { hapticLight } from "@/lib/haptics"

// Category configuration
const CATEGORIES: { value: SourceCategory | "all"; label: string }[] = [
  { value: "all", label: "All" },
  { value: "property_cat", label: "Property" },
  { value: "casualty_liability", label: "Casualty" },
  { value: "regulation", label: "Regulation" },
  { value: "claims", label: "Claims" },
  { value: "reinsurance", label: "Reinsurance" },
  { value: "insurtech", label: "InsurTech" },
]

// Time window options
const TIME_WINDOWS: { value: "24h" | "7d" | "all"; label: string }[] = [
  { value: "24h", label: "24h" },
  { value: "7d", label: "7 days" },
  { value: "all", label: "All time" },
]

interface CategoryChipsProps {
  value: SourceCategory | "all"
  onChange: (value: SourceCategory | "all") => void
}

export function CategoryChips({ value, onChange }: CategoryChipsProps) {
  const handleChange = (newValue: SourceCategory | "all") => {
    hapticLight()
    onChange(newValue)
  }

  return (
    <div
      className="-mx-[var(--spacing-4)] overflow-x-auto px-[var(--spacing-4)] scrollbar-none scroll-smooth"
      role="tablist"
      aria-label="Filter by category"
    >
      <div className="flex gap-[6px]">
        {CATEGORIES.map((cat) => (
          <button
            key={cat.value}
            role="tab"
            aria-selected={value === cat.value}
            onClick={() => handleChange(cat.value)}
            className={cn(
              // min-h-[32px] with py gives touch area; horizontal spacing adequate
              "shrink-0 rounded-full min-h-[32px] px-[14px] py-[6px] text-[13px] font-medium tracking-[-0.08px] transition-all duration-[var(--duration-fast)] ease-[var(--ease-ios)]",
              value === cat.value
                ? "bg-[var(--color-text-primary)] text-white"
                : "text-[var(--color-text-secondary)] active:bg-[var(--color-fill-tertiary)]"
            )}
          >
            {cat.label}
          </button>
        ))}
      </div>
    </div>
  )
}

interface TimeWindowToggleProps {
  value: "24h" | "7d" | "all"
  onChange: (value: "24h" | "7d" | "all") => void
}

export function TimeWindowToggle({ value, onChange }: TimeWindowToggleProps) {
  const [open, setOpen] = useState(false)

  const handleChange = (newValue: "24h" | "7d" | "all") => {
    hapticLight()
    onChange(newValue)
    setOpen(false)
  }

  const currentLabel = TIME_WINDOWS.find((tw) => tw.value === value)?.label ?? "7 days"

  return (
    <Sheet open={open} onOpenChange={setOpen}>
      <SheetTrigger asChild>
        <button
          className="flex min-h-[44px] min-w-[44px] items-center gap-[4px] rounded-[var(--radius-md)] px-[10px] py-[8px] text-[13px] font-medium tracking-[-0.08px] text-[var(--color-text-secondary)] transition-colors active:bg-[var(--color-fill-quaternary)]"
          onClick={() => hapticLight()}
          aria-label={`Time range: ${currentLabel}`}
        >
          <Clock className="h-[13px] w-[13px] shrink-0 opacity-60" strokeWidth={2} />
          <span className="whitespace-nowrap">{currentLabel}</span>
          <ChevronDown className="h-[10px] w-[10px] shrink-0 opacity-40" strokeWidth={2.5} />
        </button>
      </SheetTrigger>
      <SheetContent
        side="bottom"
        className="h-auto max-h-[45vh] rounded-t-[var(--radius-3xl)] bg-[var(--color-bg-grouped)] p-0"
      >
        <div className="drag-indicator" />
        <SheetHeader className="px-[18px] pb-[12px] pt-[14px]">
          <SheetTitle className="text-[17px] font-semibold tracking-[-0.32px]">Time Range</SheetTitle>
        </SheetHeader>
        <div className="mx-[16px] mb-[calc(var(--safe-area-inset-bottom)+16px)] overflow-hidden rounded-[var(--radius-xl)] bg-[var(--color-surface)]">
          {TIME_WINDOWS.map((tw, index) => (
            <div key={tw.value}>
              <button
                onClick={() => handleChange(tw.value)}
                className="flex w-full min-h-[48px] items-center justify-between px-[16px] py-[12px] text-left transition-colors duration-[var(--duration-instant)] active:bg-[var(--color-fill-quaternary)]"
              >
                <span className="text-[15px] font-medium tracking-[-0.18px] text-[var(--color-text-primary)]">
                  {tw.label}
                </span>
                {value === tw.value && (
                  <Check className="h-[18px] w-[18px] text-[var(--color-accent)]" strokeWidth={2.5} />
                )}
              </button>
              {index < TIME_WINDOWS.length - 1 && (
                <div className="ml-[16px] h-[0.5px] bg-[var(--color-separator)]" />
              )}
            </div>
          ))}
        </div>
      </SheetContent>
    </Sheet>
  )
}

interface SourceFilterProps {
  sources: { id: string; name: string }[]
  selectedIds: string[]
  onChange: (ids: string[]) => void
}

export function SourceFilter({ sources, selectedIds, onChange }: SourceFilterProps) {
  const [open, setOpen] = useState(false)

  const toggleSource = (id: string) => {
    hapticLight()
    if (selectedIds.includes(id)) {
      onChange(selectedIds.filter((s) => s !== id))
    } else {
      onChange([...selectedIds, id])
    }
  }

  const clearAll = () => {
    hapticLight()
    onChange([])
  }

  const label = selectedIds.length === 0
    ? "All sources"
    : selectedIds.length === 1
      ? sources.find((s) => s.id === selectedIds[0])?.name ?? "1 source"
      : `${selectedIds.length} sources`

  return (
    <Sheet open={open} onOpenChange={setOpen}>
      <SheetTrigger asChild>
        <button
          className={cn(
            "flex min-h-[44px] min-w-[44px] items-center gap-[4px] rounded-[var(--radius-md)] px-[10px] py-[8px] text-[13px] font-medium tracking-[-0.08px] transition-colors active:bg-[var(--color-fill-quaternary)]",
            selectedIds.length > 0
              ? "text-[var(--color-accent)]"
              : "text-[var(--color-text-secondary)]"
          )}
          onClick={() => hapticLight()}
          aria-label={`Filter sources: ${label}`}
        >
          <Newspaper className="h-[13px] w-[13px] shrink-0 opacity-60" strokeWidth={2} />
          <span className="whitespace-nowrap">{label}</span>
          <ChevronDown className="h-[10px] w-[10px] shrink-0 opacity-40" strokeWidth={2.5} />
        </button>
      </SheetTrigger>
      <SheetContent
        side="bottom"
        className="h-[55vh] rounded-t-[var(--radius-3xl)] bg-[var(--color-bg-grouped)] p-0"
      >
        <div className="drag-indicator" />

        <SheetHeader className="flex-row items-center justify-between px-[18px] pb-[12px] pt-[14px]">
          <SheetTitle className="text-[17px] font-semibold tracking-[-0.32px]">Sources</SheetTitle>
          {selectedIds.length > 0 && (
            <Button variant="ghost" size="sm" onClick={clearAll} className="text-[var(--color-accent)] font-medium text-[14px]">
              Clear
            </Button>
          )}
        </SheetHeader>

        <div className="mx-[16px] mb-[calc(var(--safe-area-inset-bottom)+16px)] overflow-hidden rounded-[var(--radius-xl)] bg-[var(--color-surface)]">
          <div className="max-h-[calc(55vh-120px)] overflow-y-auto">
            {sources.map((source, index) => {
              const isSelected = selectedIds.includes(source.id)
              return (
                <div key={source.id}>
                  <button
                    onClick={() => toggleSource(source.id)}
                    className="flex w-full min-h-[48px] items-center justify-between px-[16px] py-[12px] text-left transition-colors duration-[var(--duration-instant)] active:bg-[var(--color-fill-quaternary)]"
                  >
                    <span className="text-[15px] font-medium tracking-[-0.18px] text-[var(--color-text-primary)]">
                      {source.name}
                    </span>
                    {isSelected && (
                      <Check className="h-[18px] w-[18px] text-[var(--color-accent)]" strokeWidth={2.5} />
                    )}
                  </button>
                  {index < sources.length - 1 && (
                    <div className="ml-[16px] h-[0.5px] bg-[var(--color-separator)]" />
                  )}
                </div>
              )
            })}
          </div>
        </div>
      </SheetContent>
    </Sheet>
  )
}



=================================================================================
FILE: src/components/feed/index.ts
=================================================================================

/**
 * Feed components exports
 */

export { CategoryChips, TimeWindowToggle, SourceFilter } from "./FeedFilters"
export { SearchBar } from "./SearchBar"
export { ArticleRow, ArticleRowSkeleton } from "./ArticleRow"
export { ArticleCard, ArticleCardSkeleton } from "./ArticleCard"
export { ArticleDetailSheet } from "./ArticleDetailSheet"



=================================================================================
FILE: src/components/feed/SearchBar.tsx
=================================================================================

/**
 * Search bar component for the Feed page
 * iOS-native search field design
 */

import { Search, X } from "lucide-react"
import { useRef } from "react"

interface SearchBarProps {
  value: string
  onChange: (value: string) => void
  placeholder?: string
}

export function SearchBar({ value, onChange, placeholder = "Search" }: SearchBarProps) {
  const inputRef = useRef<HTMLInputElement>(null)

  const handleClear = () => {
    onChange("")
    inputRef.current?.focus()
  }

  return (
    <div className="relative">
      <Search
        className="absolute left-[10px] top-1/2 h-[16px] w-[16px] -translate-y-1/2 text-[var(--color-text-tertiary)] pointer-events-none"
        strokeWidth={2}
      />
      <input
        ref={inputRef}
        type="search"
        value={value}
        onChange={(e) => onChange(e.target.value)}
        placeholder={placeholder}
        aria-label="Search articles"
        className="h-[36px] w-full rounded-[10px] bg-[var(--color-fill-tertiary)] pl-[32px] pr-[32px] text-[16px] tracking-[-0.2px] text-[var(--color-text-primary)] placeholder:text-[var(--color-text-tertiary)] focus:outline-none focus:bg-[var(--color-fill-secondary)] transition-colors duration-[var(--duration-fast)]"
      />
      {value && (
        <button
          onClick={handleClear}
          aria-label="Clear search"
          className="absolute right-0 top-1/2 flex h-[44px] w-[44px] -translate-y-1/2 items-center justify-center"
        >
          {/* Visual clear button - smaller visible element with proper touch target */}
          <span className="flex h-[18px] w-[18px] items-center justify-center rounded-full bg-[var(--color-fill-secondary)] text-[var(--color-text-tertiary)] transition-transform duration-[var(--duration-instant)] active:scale-90">
            <X className="h-[10px] w-[10px]" strokeWidth={3} />
          </span>
        </button>
      )}
    </div>
  )
}



=================================================================================
FILE: src/components/layout/index.ts
=================================================================================

/**
 * Layout components for P&C Insurance News AI
 */

export { TopNav, MenuButton } from "./TopNav"



=================================================================================
FILE: src/components/layout/TopNav.tsx
=================================================================================

/**
 * TopNav - iOS-style sticky top navigation with large title collapse behavior
 * 
 * Features:
 * - Brand mark + app name on top-level screens, or back button for sub-screens
 * - Menu button (Sheet trigger) with 44px tap target
 * - Glass/blur background
 * - Collapsed title that appears when large title scrolls out of view
 * - Optional right-side action slot
 */

import React from "react"
import { useNavigate } from "react-router-dom"
import { Menu, ChevronLeft } from "lucide-react"
import { Button } from "@/components/ui/button"
import { AppLogo } from "@/components/ui/app-logo"
import { hapticLight, hapticMedium } from "@/lib/haptics"
import { cn } from "@/lib/utils"

interface TopNavProps {
  /** Page title shown in collapsed state */
  title: string
  /** Whether the large title is visible (controls collapsed state) */
  isLargeTitleVisible: boolean
  /** Optional action element for the right side (appears left of menu button) */
  rightAction?: React.ReactNode
  /** Sheet trigger to open navigation menu */
  menuTrigger: React.ReactNode
  /** Whether this is a sub-screen with back navigation */
  isSubScreen?: boolean
  /** Custom back action (defaults to navigate(-1)) */
  onBack?: () => void
}

export function TopNav({
  title,
  isLargeTitleVisible,
  rightAction,
  menuTrigger,
  isSubScreen = false,
  onBack,
}: TopNavProps) {
  const navigate = useNavigate()
  
  const handleBack = () => {
    hapticLight()
    if (onBack) {
      onBack()
    } else {
      navigate(-1)
    }
  }

  return (
    <header className="glass-nav sticky top-0 z-40 shadow-[var(--shadow-nav)]">
      <div
        className="safe-area-padding-x"
        style={{ paddingTop: 'var(--safe-area-inset-top)' }}
      >
        <div className="flex h-[52px] items-center justify-between px-[var(--spacing-4)]">
          {/* Left side: Brand or Back button */}
          <div className="flex items-center min-w-0 flex-1">
            {isSubScreen ? (
              <Button
                variant="ghost"
                size="icon"
                className="-ml-2 h-[44px] w-[44px] rounded-full text-[var(--color-accent)] transition-all duration-[var(--duration-fast)] hover:bg-[var(--color-fill-tertiary)] active:bg-[var(--color-fill-secondary)] active:scale-[0.92]"
                onClick={handleBack}
              >
                <ChevronLeft className="h-[24px] w-[24px]" strokeWidth={2} />
                <span className="sr-only">Go back</span>
              </Button>
            ) : (
              <div className="flex items-center gap-[10px]">
                {/* Logo - fixed size container to prevent jitter */}
                <div className="flex h-[32px] w-[32px] items-center justify-center shrink-0">
                  <AppLogo size={32} glow className="drop-shadow-[0_1px_3px_rgba(10,42,69,0.25)]" />
                </div>
                {/* Collapsed title - fades in when large title scrolls out */}
                <span
                  className={cn(
                    "text-[17px] font-semibold tracking-[-0.35px] text-[var(--color-text-primary)] whitespace-nowrap",
                    "transition-opacity duration-[var(--duration-normal)] ease-[var(--ease-ios)]",
                    isLargeTitleVisible ? "opacity-0" : "opacity-100"
                  )}
                >
                  {title}
                </span>
              </div>
            )}
          </div>

          {/* Right side: Optional action + Menu button */}
          <div className="flex items-center gap-[4px] shrink-0">
            {rightAction}
            {menuTrigger}
          </div>
        </div>
      </div>
    </header>
  )
}

/**
 * MenuButton - Standardized menu trigger button
 * Use with Sheet + SheetTrigger
 */
interface MenuButtonProps {
  onClick?: (e: React.MouseEvent<HTMLButtonElement>) => void
  className?: string
}

export const MenuButton = React.forwardRef<HTMLButtonElement, MenuButtonProps>(
  ({ onClick, className }, ref) => {
    return (
      <Button
        ref={ref}
        variant="ghost"
        size="icon"
        className={cn(
          "-mr-2 h-[44px] w-[44px] rounded-full text-[var(--color-text-secondary)] transition-all duration-[var(--duration-fast)] hover:bg-[var(--color-fill-tertiary)] active:bg-[var(--color-fill-secondary)] active:scale-[0.92]",
          className
        )}
        onClick={(e) => {
          hapticMedium()
          onClick?.(e)
        }}
      >
        <Menu className="h-[22px] w-[22px]" strokeWidth={1.8} />
        <span className="sr-only">Open menu</span>
      </Button>
    )
  }
)
MenuButton.displayName = "MenuButton"



=================================================================================
FILE: src/components/sources/index.ts
=================================================================================

/**
 * Sources components exports
 */

export { SourceRow, SourceRowSkeleton } from "./SourceRow"



=================================================================================
FILE: src/components/sources/SourceRow.tsx
=================================================================================

/**
 * Source row component with toggle switch - iOS Settings quality
 */

import { ExternalLink } from "lucide-react"
import { Switch } from "@/components/ui/switch"
import type { Source } from "@/types/firestore"
import { hapticLight } from "@/lib/haptics"

interface SourceRowProps {
  source: Source
  isFollowing: boolean
  onToggle: (enabled: boolean) => void
  isLoading?: boolean
}

// Category display labels
const CATEGORY_LABELS: Record<string, string> = {
  property_cat: "Property",
  casualty_liability: "Casualty",
  regulation: "Regulation",
  claims: "Claims",
  reinsurance: "Reinsurance",
  insurtech: "InsurTech",
}

// Category colors - muted, tasteful palette
const CATEGORY_COLORS: Record<string, string> = {
  property_cat: "rgba(0, 122, 255, 0.65)",
  casualty_liability: "rgba(175, 82, 222, 0.65)",
  regulation: "rgba(88, 86, 214, 0.65)",
  claims: "rgba(255, 149, 0, 0.65)",
  reinsurance: "rgba(48, 176, 199, 0.65)",
  insurtech: "rgba(52, 199, 89, 0.65)",
}

export function SourceRow({
  source,
  isFollowing,
  onToggle,
  isLoading,
}: SourceRowProps) {
  const handleExternalClick = (e: React.MouseEvent) => {
    e.stopPropagation()
    hapticLight()
  }

  return (
    <div className="flex min-h-[56px] items-center gap-[var(--spacing-3)] px-[20px] py-[12px]">
      {/* Source info */}
      <div className="min-w-0 flex-1">
        {/* Name row with external link */}
        <div className="flex items-center gap-[6px]">
          <h3 className="text-[17px] font-normal tracking-[-0.4px] text-[var(--color-text-primary)]">
            {source.name}
          </h3>
          <a
            href={source.siteUrl}
            target="_blank"
            rel="noopener noreferrer"
            onClick={handleExternalClick}
            className="flex h-[28px] w-[28px] shrink-0 items-center justify-center rounded-full text-[var(--color-text-quaternary)] transition-colors active:bg-[var(--color-fill-tertiary)]"
            aria-label={`Visit ${source.name} website`}
          >
            <ExternalLink className="h-[12px] w-[12px]" strokeWidth={1.75} />
          </a>
        </div>

        {/* Category tags - cleaner inline layout */}
        {source.tags.length > 0 && (
          <div className="mt-[3px] flex items-center gap-[6px]">
            {source.tags.slice(0, 3).map((tag, index) => (
              <div key={tag} className="flex items-center gap-[5px]">
                <span
                  className="h-[6px] w-[6px] rounded-full"
                  style={{ backgroundColor: CATEGORY_COLORS[tag] || "rgba(60, 60, 67, 0.3)" }}
                />
                <span className="text-[13px] tracking-[-0.08px] text-[var(--color-text-tertiary)]">
                  {CATEGORY_LABELS[tag] || tag}
                </span>
                {index < Math.min(source.tags.length, 3) - 1 && (
                  <span className="text-[13px] text-[var(--color-text-quaternary)]">·</span>
                )}
              </div>
            ))}
          </div>
        )}
      </div>

      {/* Toggle switch - vertically centered */}
      <Switch
        checked={isFollowing}
        onCheckedChange={onToggle}
        disabled={isLoading}
        aria-label={`${isFollowing ? "Unfollow" : "Follow"} ${source.name}`}
      />
    </div>
  )
}

export function SourceRowSkeleton() {
  return (
    <div className="flex min-h-[56px] items-center gap-[var(--spacing-3)] px-[20px] py-[12px]">
      <div className="min-w-0 flex-1">
        <div className="h-[17px] w-36 rounded-[4px] skeleton-shimmer" />
        <div className="mt-[3px] flex items-center gap-[6px]">
          <div className="h-[6px] w-[6px] rounded-full skeleton-shimmer" />
          <div className="h-[13px] w-24 rounded-[3px] skeleton-shimmer" />
        </div>
      </div>
      <div className="h-[31px] w-[51px] rounded-full skeleton-shimmer" />
    </div>
  )
}



=================================================================================
FILE: src/components/ui/app-logo.tsx
=================================================================================

/**
 * AppLogo - Shield logo component with gradient
 * 
 * Derived from public/logo.svg - a gradient shield representing
 * protection and trust in the insurance industry.
 * 
 * The gradient flows from deep navy (#0A2A45) through ocean blue (#0D3A66)
 * to bright cyan (#35D3FF), symbolizing depth, stability, and innovation.
 */

import { cn } from "@/lib/utils"

interface AppLogoProps {
  /** Size preset or custom size in pixels */
  size?: "xs" | "sm" | "md" | "lg" | "xl" | number
  /** Additional CSS classes */
  className?: string
  /** Whether to add a subtle shadow glow effect */
  glow?: boolean
  /** Whether to render as a rounded square (for app icon style) */
  rounded?: boolean
}

const SIZE_MAP = {
  xs: 16,
  sm: 20,
  md: 32,
  lg: 40,
  xl: 64,
} as const

export function AppLogo({ 
  size = "md", 
  className,
  glow = false,
  rounded = false,
}: AppLogoProps) {
  const pixelSize = typeof size === "number" ? size : SIZE_MAP[size]
  
  // Generate unique gradient ID to avoid conflicts when multiple logos render
  const gradientId = `logo-gradient-${Math.random().toString(36).slice(2, 9)}`
  
  return (
    <svg
      width={pixelSize}
      height={pixelSize}
      viewBox="0 0 1024 1024"
      fill="none"
      xmlns="http://www.w3.org/2000/svg"
      className={cn(
        "shrink-0",
        glow && "drop-shadow-[0_2px_8px_rgba(53,211,255,0.35)]",
        rounded && "rounded-[22%]",
        className
      )}
      aria-label="P&C Brief logo"
    >
      <defs>
        <linearGradient 
          id={gradientId} 
          x1="260" 
          y1="180" 
          x2="780" 
          y2="920" 
          gradientUnits="userSpaceOnUse"
        >
          <stop offset="0%" stopColor="#0A2A45" />
          <stop offset="55%" stopColor="#0D3A66" />
          <stop offset="100%" stopColor="#35D3FF" />
        </linearGradient>
      </defs>
      
      {/* Shield path */}
      <path
        d="M512 176
           C654 176 776 248 776 380
           V556
           C776 702 654 824 512 904
           C370 824 248 702 248 556
           V380
           C248 248 370 176 512 176
           Z"
        fill={`url(#${gradientId})`}
      />
    </svg>
  )
}

/**
 * AppLogoMark - Compact version for tight spaces
 * Same shield but optimized viewBox for tighter cropping
 */
export function AppLogoMark({ 
  size = 24, 
  className 
}: { 
  size?: number
  className?: string 
}) {
  const gradientId = `logo-mark-${Math.random().toString(36).slice(2, 9)}`
  
  return (
    <svg
      width={size}
      height={size}
      viewBox="200 140 624 800"
      fill="none"
      xmlns="http://www.w3.org/2000/svg"
      className={cn("shrink-0", className)}
      aria-label="P&C Brief"
    >
      <defs>
        <linearGradient 
          id={gradientId} 
          x1="260" 
          y1="180" 
          x2="780" 
          y2="920" 
          gradientUnits="userSpaceOnUse"
        >
          <stop offset="0%" stopColor="#0A2A45" />
          <stop offset="55%" stopColor="#0D3A66" />
          <stop offset="100%" stopColor="#35D3FF" />
        </linearGradient>
      </defs>
      
      <path
        d="M512 176
           C654 176 776 248 776 380
           V556
           C776 702 654 824 512 904
           C370 824 248 702 248 556
           V380
           C248 248 370 176 512 176
           Z"
        fill={`url(#${gradientId})`}
      />
    </svg>
  )
}



=================================================================================
FILE: src/components/ui/badge.tsx
=================================================================================

import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"
import { cn } from "@/lib/utils"

/**
 * Badge - Compact label for status and categories
 *
 * Consistent with iOS styling: rounded full, proper padding, muted colors.
 */
const badgeVariants = cva(
  "inline-flex items-center justify-center rounded-full text-[12px] font-semibold tracking-[-0.02em] transition-colors",
  {
    variants: {
      variant: {
        default: "bg-[var(--color-accent)] text-white",
        secondary: "bg-[var(--color-fill-tertiary)] text-[var(--color-text-secondary)]",
        muted: "bg-[var(--color-fill-quaternary)] text-[var(--color-text-tertiary)]",
        destructive: "bg-[var(--color-destructive-soft)] text-[var(--color-destructive)]",
        success: "bg-[var(--color-success-soft)] text-[var(--color-success)]",
        warning: "bg-[var(--color-warning-soft)] text-[var(--color-warning)]",
        accent: "bg-gradient-to-r from-[#007AFF]/10 to-[#5856D6]/10 text-[#007AFF]",
      },
      size: {
        default: "h-[22px] px-[10px]",
        sm: "h-[18px] px-[8px] text-[11px]",
        lg: "h-[26px] px-[12px] text-[13px]",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

export interface BadgeProps
  extends React.HTMLAttributes<HTMLDivElement>,
    VariantProps<typeof badgeVariants> {}

const Badge = React.forwardRef<HTMLDivElement, BadgeProps>(
  ({ className, variant, size, ...props }, ref) => (
    <div
      ref={ref}
      className={cn(badgeVariants({ variant, size }), className)}
      {...props}
    />
  )
)
Badge.displayName = "Badge"

export { Badge, badgeVariants }



=================================================================================
FILE: src/components/ui/button.tsx
=================================================================================

import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"
import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-[7px] whitespace-nowrap rounded-[12px] text-[15px] font-semibold tracking-[-0.2px] transition-all duration-[var(--duration-fast)] ease-[var(--ease-ios)] focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-[var(--color-accent)] focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-38 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0 active:scale-[0.96]",
  {
    variants: {
      variant: {
        default:
          "bg-[#007AFF] text-white shadow-[0_1px_3px_rgba(0,122,255,0.24),inset_0_1px_0_rgba(255,255,255,0.10)] hover:bg-[#0066D6] active:bg-[#0055B3]",
        destructive:
          "bg-[#FF3B30] text-white shadow-[0_1px_3px_rgba(255,59,48,0.24),inset_0_1px_0_rgba(255,255,255,0.10)] hover:bg-[#E5352B] active:brightness-90",
        outline:
          "bg-[var(--color-surface)] text-[var(--color-text-primary)] shadow-[var(--shadow-card)] hover:bg-[var(--color-fill-quaternary)] active:bg-[var(--color-fill-tertiary)] active:shadow-[var(--shadow-card-active)]",
        secondary:
          "bg-[var(--color-fill-tertiary)] text-[var(--color-text-primary)] hover:bg-[var(--color-fill-secondary)] active:bg-[var(--color-fill-primary)]",
        ghost:
          "text-[var(--color-text-primary)] hover:bg-[var(--color-fill-quaternary)] active:bg-[var(--color-fill-tertiary)]",
        link:
          "text-[var(--color-accent)] underline-offset-4 hover:underline active:opacity-70",
      },
      size: {
        default: "h-[46px] px-[20px]",
        sm: "h-[36px] rounded-[10px] px-[14px] text-[14px]",
        lg: "h-[52px] rounded-[14px] px-[26px] text-[16px]",
        icon: "h-[44px] w-[44px]",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, asChild = false, ...props }, ref) => {
    const Comp = asChild ? Slot : "button"
    return (
      <Comp
        className={cn(buttonVariants({ variant, size, className }))}
        ref={ref}
        {...props}
      />
    )
  }
)
Button.displayName = "Button"

export { Button, buttonVariants }



=================================================================================
FILE: src/components/ui/card.tsx
=================================================================================

import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"
import { cn } from "@/lib/utils"

/**
 * Card - Unified surface component with iOS-style variants
 *
 * Variants:
 * - default: Standard card with subtle shadow (for content cards)
 * - grouped: iOS Settings-style grouped list container
 * - interactive: Card that responds to press/hover (for tappable items)
 * - elevated: Slightly more prominent shadow
 */
const cardVariants = cva(
  "overflow-hidden bg-[var(--color-surface)]",
  {
    variants: {
      variant: {
        default: "rounded-[16px] shadow-[0_1px_3px_rgba(0,0,0,0.04),0_0_0_0.5px_rgba(0,0,0,0.02)]",
        grouped: "rounded-[var(--radius-xl)] shadow-[0_0.5px_1px_rgba(0,0,0,0.04),0_0_0_0.5px_rgba(0,0,0,0.015)]",
        interactive: "rounded-[16px] shadow-[0_1px_3px_rgba(0,0,0,0.04),0_0_0_0.5px_rgba(0,0,0,0.02)] transition-all duration-[var(--duration-fast)] ease-[var(--ease-ios)] cursor-pointer active:scale-[0.985] active:bg-[var(--color-fill-quaternary)]",
        elevated: "rounded-[16px] shadow-[var(--shadow-md)]",
        outline: "rounded-[var(--radius-lg)] border border-[var(--color-separator)]",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

export interface CardProps
  extends React.HTMLAttributes<HTMLDivElement>,
    VariantProps<typeof cardVariants> {}

const Card = React.forwardRef<HTMLDivElement, CardProps>(
  ({ className, variant, ...props }, ref) => (
    <div
      ref={ref}
      className={cn(cardVariants({ variant }), className)}
      {...props}
    />
  )
)
Card.displayName = "Card"

const CardHeader = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex flex-col space-y-1.5 px-[18px] py-[14px]", className)}
    {...props}
  />
))
CardHeader.displayName = "CardHeader"

const CardTitle = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn(
      "text-[17px] font-semibold leading-tight tracking-[-0.32px] text-[var(--color-text-primary)]",
      className
    )}
    {...props}
  />
))
CardTitle.displayName = "CardTitle"

const CardDescription = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("text-[15px] leading-[1.45] tracking-[-0.2px] text-[var(--color-text-secondary)]", className)}
    {...props}
  />
))
CardDescription.displayName = "CardDescription"

const CardContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("px-[18px] pb-[18px]", className)}
    {...props}
  />
))
CardContent.displayName = "CardContent"

const CardFooter = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex items-center px-[18px] pb-[14px]", className)}
    {...props}
  />
))
CardFooter.displayName = "CardFooter"

export { Card, cardVariants, CardHeader, CardFooter, CardTitle, CardDescription, CardContent }



=================================================================================
FILE: src/components/ui/dropdown-menu.tsx
=================================================================================

import * as React from "react"
import * as DropdownMenuPrimitive from "@radix-ui/react-dropdown-menu"
import { Check, ChevronRight, Circle } from "lucide-react"
import { cn } from "@/lib/utils"

const DropdownMenu = DropdownMenuPrimitive.Root
const DropdownMenuTrigger = DropdownMenuPrimitive.Trigger
const DropdownMenuGroup = DropdownMenuPrimitive.Group
const DropdownMenuPortal = DropdownMenuPrimitive.Portal
const DropdownMenuSub = DropdownMenuPrimitive.Sub
const DropdownMenuRadioGroup = DropdownMenuPrimitive.RadioGroup

const DropdownMenuSubTrigger = React.forwardRef<
  React.ComponentRef<typeof DropdownMenuPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubTrigger> & {
    inset?: boolean
  }
>(({ className, inset, children, ...props }, ref) => (
  <DropdownMenuPrimitive.SubTrigger
    ref={ref}
    className={cn(
      "flex cursor-default select-none items-center gap-2 rounded-[var(--radius-sm)] px-3 py-2 text-[15px] outline-none focus:bg-[var(--color-surface)] data-[state=open]:bg-[var(--color-surface)] [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
      inset && "pl-8",
      className
    )}
    {...props}
  >
    {children}
    <ChevronRight className="ml-auto" />
  </DropdownMenuPrimitive.SubTrigger>
))
DropdownMenuSubTrigger.displayName = DropdownMenuPrimitive.SubTrigger.displayName

const DropdownMenuSubContent = React.forwardRef<
  React.ComponentRef<typeof DropdownMenuPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.SubContent
    ref={ref}
    className={cn(
      "z-50 min-w-[8rem] overflow-hidden rounded-[var(--radius-md)] border border-[var(--color-border)] bg-[var(--color-surface-elevated)] p-1 text-[var(--color-text-primary)] shadow-[var(--shadow-lg)] data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95",
      className
    )}
    {...props}
  />
))
DropdownMenuSubContent.displayName = DropdownMenuPrimitive.SubContent.displayName

const DropdownMenuContent = React.forwardRef<
  React.ComponentRef<typeof DropdownMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <DropdownMenuPrimitive.Portal>
    <DropdownMenuPrimitive.Content
      ref={ref}
      sideOffset={sideOffset}
      className={cn(
        "z-50 min-w-[8rem] overflow-hidden rounded-[var(--radius-md)] border border-[var(--color-border)] bg-[var(--color-surface-elevated)] p-1 text-[var(--color-text-primary)] shadow-[var(--shadow-lg)] data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95",
        className
      )}
      {...props}
    />
  </DropdownMenuPrimitive.Portal>
))
DropdownMenuContent.displayName = DropdownMenuPrimitive.Content.displayName

const DropdownMenuItem = React.forwardRef<
  React.ComponentRef<typeof DropdownMenuPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Item> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center gap-2 rounded-[var(--radius-sm)] px-3 py-2 text-[15px] outline-none transition-colors focus:bg-[var(--color-surface)] data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
DropdownMenuItem.displayName = DropdownMenuPrimitive.Item.displayName

const DropdownMenuCheckboxItem = React.forwardRef<
  React.ComponentRef<typeof DropdownMenuPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <DropdownMenuPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-[var(--radius-sm)] py-2 pl-8 pr-3 text-[15px] outline-none transition-colors focus:bg-[var(--color-surface)] data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-4 w-4 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.CheckboxItem>
))
DropdownMenuCheckboxItem.displayName = DropdownMenuPrimitive.CheckboxItem.displayName

const DropdownMenuRadioItem = React.forwardRef<
  React.ComponentRef<typeof DropdownMenuPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <DropdownMenuPrimitive.RadioItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-[var(--radius-sm)] py-2 pl-8 pr-3 text-[15px] outline-none transition-colors focus:bg-[var(--color-surface)] data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-4 w-4 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Circle className="h-2 w-2 fill-current" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.RadioItem>
))
DropdownMenuRadioItem.displayName = DropdownMenuPrimitive.RadioItem.displayName

const DropdownMenuLabel = React.forwardRef<
  React.ComponentRef<typeof DropdownMenuPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Label> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Label
    ref={ref}
    className={cn(
      "px-3 py-1.5 text-[13px] font-semibold text-[var(--color-text-secondary)]",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
DropdownMenuLabel.displayName = DropdownMenuPrimitive.Label.displayName

const DropdownMenuSeparator = React.forwardRef<
  React.ComponentRef<typeof DropdownMenuPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-[var(--color-border)]", className)}
    {...props}
  />
))
DropdownMenuSeparator.displayName = DropdownMenuPrimitive.Separator.displayName

const DropdownMenuShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn("ml-auto text-[12px] tracking-widest text-[var(--color-text-tertiary)]", className)}
      {...props}
    />
  )
}
DropdownMenuShortcut.displayName = "DropdownMenuShortcut"

export {
  DropdownMenu,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuCheckboxItem,
  DropdownMenuRadioItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuGroup,
  DropdownMenuPortal,
  DropdownMenuSub,
  DropdownMenuSubContent,
  DropdownMenuSubTrigger,
  DropdownMenuRadioGroup,
}



=================================================================================
FILE: src/components/ui/empty-state.tsx
=================================================================================

/**
 * Empty State Component
 *
 * Minimal empty state for lists with no content.
 * iOS-style centered design with refined typography.
 */

import { type ReactNode } from "react"
import { type LucideIcon } from "lucide-react"
import { cn } from "@/lib/utils"

interface EmptyStateProps {
  /** Icon to display */
  icon: LucideIcon
  /** Primary heading text */
  title: string
  /** Optional description text */
  description?: string
  /** Optional action button/element */
  action?: ReactNode
  /** Optional additional class names */
  className?: string
  /** Compact variant with smaller spacing */
  compact?: boolean
}

export function EmptyState({
  icon: Icon,
  title,
  description,
  action,
  className,
  compact = false,
}: EmptyStateProps) {
  return (
    <div
      className={cn(
        "flex flex-col items-center justify-center text-center",
        compact ? "py-[32px]" : "py-[48px]",
        className
      )}
    >
      {/* Icon container - rounded square for iOS feel */}
      <div
        className={cn(
          "flex items-center justify-center rounded-[20px] bg-[var(--color-fill-tertiary)]",
          compact ? "mb-[14px] h-[48px] w-[48px]" : "mb-[18px] h-[64px] w-[64px]"
        )}
      >
        <Icon
          className={cn(
            "text-[var(--color-text-tertiary)]",
            compact ? "h-[22px] w-[22px]" : "h-[28px] w-[28px]"
          )}
          strokeWidth={1.5}
        />
      </div>

      {/* Title */}
      <h3
        className={cn(
          "font-semibold tracking-[-0.4px] text-[var(--color-text-primary)]",
          compact ? "mb-[4px] text-[17px]" : "mb-[8px] text-[20px]"
        )}
      >
        {title}
      </h3>

      {/* Description */}
      {description && (
        <p
          className={cn(
            "max-w-[260px] leading-[1.45] tracking-[-0.16px] text-[var(--color-text-tertiary)]",
            compact ? "text-[14px]" : "text-[15px]"
          )}
        >
          {description}
        </p>
      )}

      {/* Optional action button */}
      {action && <div className="mt-[20px]">{action}</div>}
    </div>
  )
}



=================================================================================
FILE: src/components/ui/error-state.tsx
=================================================================================

/**
 * Error State Component
 *
 * Non-alarming error display with retry capability.
 * iOS-style calm and professional design.
 */

import { type LucideIcon, WifiOff } from "lucide-react"
import { cn } from "@/lib/utils"
import { Button } from "./button"

interface ErrorStateProps {
  /** Custom icon (defaults to WifiOff) */
  icon?: LucideIcon
  /** Error heading */
  title?: string
  /** Error description */
  description?: string
  /** Retry callback */
  onRetry?: () => void
  /** Retry button label */
  retryLabel?: string
  /** Optional additional class names */
  className?: string
  /** Compact variant with smaller spacing */
  compact?: boolean
}

export function ErrorState({
  icon: Icon = WifiOff,
  title = "Unable to load",
  description = "Check your connection and try again.",
  onRetry,
  retryLabel = "Try Again",
  className,
  compact = false,
}: ErrorStateProps) {
  return (
    <div
      className={cn(
        "flex flex-col items-center justify-center text-center",
        compact ? "py-[32px]" : "py-[48px]",
        className
      )}
    >
      {/* Icon container - rounded square for iOS feel */}
      <div
        className={cn(
          "flex items-center justify-center rounded-[20px] bg-[var(--color-fill-tertiary)]",
          compact ? "mb-[14px] h-[48px] w-[48px]" : "mb-[18px] h-[64px] w-[64px]"
        )}
      >
        <Icon
          className={cn(
            "text-[var(--color-text-tertiary)]",
            compact ? "h-[22px] w-[22px]" : "h-[28px] w-[28px]"
          )}
          strokeWidth={1.5}
        />
      </div>

      {/* Title */}
      <h3
        className={cn(
          "font-semibold tracking-[-0.4px] text-[var(--color-text-primary)]",
          compact ? "mb-[4px] text-[17px]" : "mb-[8px] text-[20px]"
        )}
      >
        {title}
      </h3>

      {/* Description */}
      <p
        className={cn(
          "max-w-[260px] leading-[1.45] tracking-[-0.16px] text-[var(--color-text-tertiary)]",
          compact ? "text-[14px]" : "text-[15px]"
        )}
      >
        {description}
      </p>

      {/* Retry button */}
      {onRetry && (
        <Button variant="secondary" size="sm" onClick={onRetry} className="mt-[20px]">
          {retryLabel}
        </Button>
      )}
    </div>
  )
}



=================================================================================
FILE: src/components/ui/index.ts
=================================================================================

export * from "./app-logo"
export * from "./badge"
export * from "./button"
export * from "./card"
export * from "./dropdown-menu"
export * from "./empty-state"
export * from "./error-state"
export * from "./list-row"
export * from "./section-label"
export * from "./separator"
export * from "./sheet"
export * from "./sheet-primitives"
export * from "./skeleton"
export * from "./sonner"
export * from "./switch"
export * from "./tabs"



=================================================================================
FILE: src/components/ui/list-row.tsx
=================================================================================

/**
 * ListRow - iOS-style interactive list row
 * 
 * Consistent touch targets (min 44px), press feedback, and focus states.
 * Use within Card variant="grouped" for Settings-style lists.
 */

import * as React from "react"
import { cn } from "@/lib/utils"

interface ListRowProps extends React.HTMLAttributes<HTMLDivElement> {
  /** Make row interactive with press states */
  interactive?: boolean
  /** Add disclosure indicator (chevron) */
  hasChevron?: boolean
}

const ListRow = React.forwardRef<HTMLDivElement, ListRowProps>(
  ({ className, interactive = false, children, ...props }, ref) => (
    <div
      ref={ref}
      role={interactive ? "button" : undefined}
      tabIndex={interactive ? 0 : undefined}
      className={cn(
        "flex min-h-[44px] items-center gap-[12px] px-[16px] py-[12px]",
        interactive && [
          "cursor-pointer",
          "transition-colors duration-[var(--duration-instant)] ease-[var(--ease-out)]",
          "active:bg-[var(--color-fill-quaternary)]",
          "focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-[var(--color-accent)] focus-visible:ring-inset",
        ],
        className
      )}
      {...props}
    >
      {children}
    </div>
  )
)
ListRow.displayName = "ListRow"

/**
 * ListRowIcon - Leading icon container for list rows (iOS Settings style)
 */
interface ListRowIconProps extends React.HTMLAttributes<HTMLDivElement> {
  /** Background color for the icon container */
  color?: string
  /** Whether icon is disabled (reduced opacity) */
  disabled?: boolean
}

const ListRowIcon = React.forwardRef<HTMLDivElement, ListRowIconProps>(
  ({ className, color, disabled, children, ...props }, ref) => (
    <div
      ref={ref}
      className={cn(
        "flex h-[29px] w-[29px] shrink-0 items-center justify-center rounded-[6px]",
        disabled && "opacity-50",
        !color && "bg-[var(--color-fill-secondary)]",
        className
      )}
      style={color ? { backgroundColor: color } : undefined}
      {...props}
    >
      {children}
    </div>
  )
)
ListRowIcon.displayName = "ListRowIcon"

/**
 * ListRowContent - Main content area for list rows
 */
const ListRowContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex-1 min-w-0", className)}
    {...props}
  />
))
ListRowContent.displayName = "ListRowContent"

/**
 * ListRowLabel - Primary text for list rows
 */
const ListRowLabel = React.forwardRef<
  HTMLSpanElement,
  React.HTMLAttributes<HTMLSpanElement> & { disabled?: boolean }
>(({ className, disabled, ...props }, ref) => (
  <span
    ref={ref}
    className={cn(
      "block text-[17px] leading-[22px] tracking-[-0.4px]",
      disabled ? "text-[var(--color-text-tertiary)]" : "text-[var(--color-text-primary)]",
      className
    )}
    {...props}
  />
))
ListRowLabel.displayName = "ListRowLabel"

/**
 * ListRowValue - Secondary/trailing value text for list rows
 */
const ListRowValue = React.forwardRef<
  HTMLSpanElement,
  React.HTMLAttributes<HTMLSpanElement>
>(({ className, ...props }, ref) => (
  <span
    ref={ref}
    className={cn(
      "text-[17px] text-[var(--color-text-tertiary)]",
      className
    )}
    {...props}
  />
))
ListRowValue.displayName = "ListRowValue"

export { 
  ListRow, 
  ListRowIcon, 
  ListRowContent, 
  ListRowLabel, 
  ListRowValue,
  type ListRowProps,
  type ListRowIconProps,
}



=================================================================================
FILE: src/components/ui/section-label.tsx
=================================================================================

/**
 * SectionLabel - iOS-style section header text
 * 
 * Used for labeling groups of content in list views and pages.
 * Follows Apple HIG typography for section headers.
 */

import * as React from "react"
import { cn } from "@/lib/utils"
import type { LucideIcon } from "lucide-react"

interface SectionLabelProps extends React.HTMLAttributes<HTMLDivElement> {
  /** Optional icon to display alongside label */
  icon?: LucideIcon
  /** Add left padding for grouped list context (Settings-style) */
  inset?: boolean
}

const SectionLabel = React.forwardRef<HTMLDivElement, SectionLabelProps>(
  ({ className, children, icon: Icon, inset = false, ...props }, ref) => (
    <div
      ref={ref}
      className={cn(
        "flex items-center gap-[8px] text-[13px] font-semibold uppercase tracking-[0.02em] text-[var(--color-text-secondary)]",
        inset && "pl-[16px]",
        className
      )}
      style={{ opacity: 0.6 }}
      {...props}
    >
      {Icon && <Icon className="h-[14px] w-[14px]" strokeWidth={2} />}
      <span>{children}</span>
    </div>
  )
)
SectionLabel.displayName = "SectionLabel"

/**
 * SectionFooter - iOS-style section footer/description text
 * 
 * Used for explanatory text below grouped content sections.
 */
interface SectionFooterProps extends React.HTMLAttributes<HTMLParagraphElement> {
  /** Add left/right padding for grouped list context */
  inset?: boolean
}

const SectionFooter = React.forwardRef<HTMLParagraphElement, SectionFooterProps>(
  ({ className, inset = false, ...props }, ref) => (
    <p
      ref={ref}
      className={cn(
        "text-[13px] leading-[18px] text-[var(--color-text-tertiary)]",
        inset && "px-[16px]",
        className
      )}
      {...props}
    />
  )
)
SectionFooter.displayName = "SectionFooter"

export { SectionLabel, SectionFooter }



=================================================================================
FILE: src/components/ui/separator.tsx
=================================================================================

import * as React from "react"
import { cn } from "@/lib/utils"

/**
 * Separator - iOS-style divider line
 *
 * Variants:
 * - full: Full-width separator (default)
 * - inset: Standard inset (16px left margin) for list rows
 * - inset-icon: Larger inset (57px left margin) for rows with leading icons (16px + 29px + 12px)
 *
 * Uses 0.5px height for true iOS hairline appearance
 */
interface SeparatorProps extends React.HTMLAttributes<HTMLDivElement> {
  orientation?: "horizontal" | "vertical"
  variant?: "full" | "inset" | "inset-icon"
}

const Separator = React.forwardRef<HTMLDivElement, SeparatorProps>(
  ({ className, orientation = "horizontal", variant = "full", ...props }, ref) => {
    const insetMargin = variant === "inset"
      ? "ml-[16px]"
      : variant === "inset-icon"
        ? "ml-[57px]"
        : ""

    return (
      <div
        ref={ref}
        role="separator"
        aria-orientation={orientation}
        className={cn(
          "shrink-0 bg-[var(--color-separator)]",
          orientation === "horizontal"
            ? `h-[0.5px] w-full ${insetMargin}`
            : "h-full w-[0.5px]",
          className
        )}
        {...props}
      />
    )
  }
)
Separator.displayName = "Separator"

export { Separator, type SeparatorProps }



=================================================================================
FILE: src/components/ui/sheet-primitives.tsx
=================================================================================

/**
 * Shared primitives for bottom sheets
 * 
 * Provides consistent styling across all article detail sheets:
 * - SheetHeaderBlock: source label + optional timestamp + title
 * - SheetSection: labeled content block (TL;DR, Why it matters, etc.)
 * - SheetActions: primary button + secondary icon button
 */

import * as React from "react"
import { Button } from "@/components/ui/button"
import { ExternalLink, Loader2 } from "lucide-react"
import { cn } from "@/lib/utils"

// ============================================================================
// Design Tokens (unified across all sheets)
// ============================================================================

export const SHEET_TOKENS = {
  // Container
  containerClass: "glass-sheet sheet-scroll h-[85vh] overflow-y-auto px-[20px] pb-[calc(56px+var(--safe-area-inset-bottom))] pt-[8px]",
  
  // Drag indicator
  dragIndicatorClass: "drag-indicator mb-[20px]",
  
  // Header
  headerMargin: "mb-[24px]",
  
  // Image
  imageClass: "mb-[24px] aspect-[16/9] w-full overflow-hidden rounded-[var(--radius-2xl)] bg-[var(--color-fill-tertiary)]",
  
  // Section spacing
  sectionMargin: "mb-[24px]",
  snippetMargin: "mb-[28px]",
  
  // Actions
  actionsGap: "gap-[12px]",
  iconButtonSize: "h-[52px] w-[52px]",
} as const

// ============================================================================
// SheetHeaderBlock
// ============================================================================

interface SheetHeaderBlockProps {
  source: string
  timestamp?: string
  title: string
  className?: string
}

export function SheetHeaderBlock({
  source,
  timestamp,
  title,
  className,
}: SheetHeaderBlockProps) {
  return (
    <div className={cn("text-left", SHEET_TOKENS.headerMargin, className)}>
      <div className="mb-[10px] flex items-center gap-[6px]">
        <span className="text-[12px] font-semibold uppercase tracking-[0.04em] text-[var(--color-accent)]">
          {source}
        </span>
        {timestamp && (
          <span className="text-[12px] text-[var(--color-text-tertiary)]">
            · {timestamp}
          </span>
        )}
      </div>
      <h2 className="text-[26px] font-bold leading-[1.18] tracking-[-0.5px] text-[var(--color-text-primary)]">
        {title}
      </h2>
    </div>
  )
}

// ============================================================================
// SheetSection
// ============================================================================

interface SheetSectionProps {
  label: string
  children: React.ReactNode
  className?: string
}

export function SheetSection({ label, children, className }: SheetSectionProps) {
  return (
    <div className={cn(className)}>
      <h4 className="mb-[8px] text-[11px] font-semibold uppercase tracking-[0.04em] text-[var(--color-text-tertiary)]">
        {label}
      </h4>
      <div className="text-[15px] leading-[1.55] tracking-[-0.2px] text-[var(--color-text-primary)]">
        {children}
      </div>
    </div>
  )
}

// ============================================================================
// SheetSectionCard (for grouped AI content)
// ============================================================================

interface SheetSectionCardProps {
  children: React.ReactNode
  footer?: React.ReactNode
  className?: string
}

export function SheetSectionCard({ children, footer, className }: SheetSectionCardProps) {
  return (
    <div className={cn("overflow-hidden rounded-[var(--radius-2xl)] bg-[var(--color-fill-quaternary)]", className)}>
      <div className="px-[18px] py-[16px]">{children}</div>
      {footer && (
        <div className="border-t border-[var(--color-separator)] px-[18px] py-[10px]">
          {footer}
        </div>
      )}
    </div>
  )
}

// ============================================================================
// SheetSnippet
// ============================================================================

interface SheetSnippetProps {
  children: React.ReactNode
  className?: string
}

export function SheetSnippet({ children, className }: SheetSnippetProps) {
  return (
    <div className={cn(SHEET_TOKENS.snippetMargin, className)}>
      <p className="text-[15px] leading-[1.6] tracking-[-0.2px] text-[var(--color-text-secondary)]">
        {children}
      </p>
    </div>
  )
}

// ============================================================================
// SheetActions
// ============================================================================

interface SheetActionsProps {
  onReadArticle: () => void
  secondaryButton: React.ReactNode
  primaryLabel?: string
  className?: string
}

export function SheetActions({
  onReadArticle,
  secondaryButton,
  primaryLabel = "Read Article",
  className,
}: SheetActionsProps) {
  return (
    <div className={cn("flex", SHEET_TOKENS.actionsGap, className)}>
      <Button onClick={onReadArticle} className="flex-1 gap-[8px]" size="lg">
        <span>{primaryLabel}</span>
        <ExternalLink className="h-[17px] w-[17px]" />
      </Button>
      {secondaryButton}
    </div>
  )
}

// ============================================================================
// SheetIconButton (for bookmark/action icon buttons)
// ============================================================================

interface SheetIconButtonProps {
  onClick: () => void
  disabled?: boolean
  loading?: boolean
  children: React.ReactNode
  className?: string
  "aria-label"?: string
}

export function SheetIconButton({
  onClick,
  disabled,
  loading,
  children,
  className,
  "aria-label": ariaLabel,
}: SheetIconButtonProps) {
  return (
    <Button
      variant="outline"
      size="lg"
      onClick={onClick}
      disabled={disabled}
      aria-label={ariaLabel}
      className={cn(SHEET_TOKENS.iconButtonSize, "shrink-0 p-0 active:scale-[0.94]", className)}
    >
      {loading ? <Loader2 className="h-[20px] w-[20px] animate-spin" /> : children}
    </Button>
  )
}



=================================================================================
FILE: src/components/ui/sheet.tsx
=================================================================================

import * as React from "react"
import * as DialogPrimitive from "@radix-ui/react-dialog"
import { cva, type VariantProps } from "class-variance-authority"
import { X } from "lucide-react"
import { cn } from "@/lib/utils"

const Sheet = DialogPrimitive.Root
const SheetTrigger = DialogPrimitive.Trigger
const SheetClose = DialogPrimitive.Close
const SheetPortal = DialogPrimitive.Portal

const SheetOverlay = React.forwardRef<
  React.ComponentRef<typeof DialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Overlay
    className={cn(
      "fixed inset-0 z-50 bg-black/45 backdrop-blur-[8px] data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:duration-[var(--duration-fast)] data-[state=open]:duration-[var(--duration-normal)]",
      className
    )}
    {...props}
    ref={ref}
  />
))
SheetOverlay.displayName = DialogPrimitive.Overlay.displayName

const sheetVariants = cva(
  "fixed z-50 bg-[var(--color-surface-elevated)] shadow-[var(--shadow-sheet)] transition ease-[var(--ease-ios)] data-[state=closed]:duration-[var(--duration-normal)] data-[state=open]:duration-[var(--duration-sheet)] data-[state=open]:animate-in data-[state=closed]:animate-out",
  {
    variants: {
      side: {
        top: "inset-x-0 top-0 data-[state=closed]:slide-out-to-top data-[state=open]:slide-in-from-top",
        bottom:
          "inset-x-0 bottom-0 rounded-t-[var(--radius-3xl)] data-[state=closed]:slide-out-to-bottom data-[state=open]:slide-in-from-bottom",
        left: "inset-y-0 left-0 h-full w-3/4 data-[state=closed]:slide-out-to-left data-[state=open]:slide-in-from-left sm:max-w-sm",
        right:
          "inset-y-0 right-0 h-full w-3/4 data-[state=closed]:slide-out-to-right data-[state=open]:slide-in-from-right sm:max-w-sm",
      },
    },
    defaultVariants: {
      side: "right",
    },
  }
)

interface SheetContentProps
  extends React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content>,
    VariantProps<typeof sheetVariants> {
  /** Hide the default close button (for bottom sheets with drag indicator) */
  hideCloseButton?: boolean
}

const SheetContent = React.forwardRef<
  React.ComponentRef<typeof DialogPrimitive.Content>,
  SheetContentProps
>(({ side = "right", className, children, hideCloseButton = false, ...props }, ref) => {
  const isBottomSheet = side === "bottom"
  const isSideSheet = side === "left" || side === "right"

  return (
    <SheetPortal>
      <SheetOverlay />
      <DialogPrimitive.Content
        ref={ref}
        className={cn(sheetVariants({ side }), className)}
        {...props}
      >
        {/* Close button - positioned with safe area awareness for side sheets, hidden for bottom sheets by default */}
        {!hideCloseButton && !isBottomSheet && (
          <DialogPrimitive.Close
            className={cn(
              "absolute z-10 flex h-[32px] w-[32px] items-center justify-center rounded-full bg-[var(--color-fill-tertiary)] text-[var(--color-text-secondary)] transition-all duration-[var(--duration-fast)] hover:bg-[var(--color-fill-secondary)] active:scale-[0.92] focus:outline-none",
              isSideSheet && "right-[16px] top-[calc(16px+var(--safe-area-inset-top))]"
            )}
          >
            <X className="h-[15px] w-[15px]" strokeWidth={2.25} />
            <span className="sr-only">Close</span>
          </DialogPrimitive.Close>
        )}
        {children}
      </DialogPrimitive.Content>
    </SheetPortal>
  )
})
SheetContent.displayName = DialogPrimitive.Content.displayName

const SheetHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col gap-[4px] text-center sm:text-left",
      className
    )}
    {...props}
  />
)
SheetHeader.displayName = "SheetHeader"

const SheetFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse gap-[10px] sm:flex-row sm:justify-end",
      className
    )}
    {...props}
  />
)
SheetFooter.displayName = "SheetFooter"

const SheetTitle = React.forwardRef<
  React.ComponentRef<typeof DialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Title
    ref={ref}
    className={cn("text-[20px] font-bold leading-[1.2] tracking-[-0.36px] text-[var(--color-text-primary)]", className)}
    {...props}
  />
))
SheetTitle.displayName = DialogPrimitive.Title.displayName

const SheetDescription = React.forwardRef<
  React.ComponentRef<typeof DialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Description
    ref={ref}
    className={cn("text-[14px] leading-[1.5] tracking-[-0.14px] text-[var(--color-text-secondary)]", className)}
    {...props}
  />
))
SheetDescription.displayName = DialogPrimitive.Description.displayName

export {
  Sheet,
  SheetPortal,
  SheetOverlay,
  SheetTrigger,
  SheetClose,
  SheetContent,
  SheetHeader,
  SheetFooter,
  SheetTitle,
  SheetDescription,
}



=================================================================================
FILE: src/components/ui/skeleton.tsx
=================================================================================

import { cn } from "@/lib/utils"

function Skeleton({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) {
  return (
    <div
      className={cn(
        "skeleton-shimmer rounded-[var(--radius-sm)]",
        className
      )}
      {...props}
    />
  )
}

export { Skeleton }



=================================================================================
FILE: src/components/ui/sonner.tsx
=================================================================================

import { Toaster as Sonner } from "sonner"

type ToasterProps = React.ComponentProps<typeof Sonner>

const Toaster = ({ ...props }: ToasterProps) => {
  return (
    <Sonner
      className="toaster group"
      toastOptions={{
        classNames: {
          toast:
            "group toast group-[.toaster]:bg-[var(--color-surface-elevated)] group-[.toaster]:text-[var(--color-text-primary)] group-[.toaster]:border-[var(--color-border)] group-[.toaster]:shadow-[var(--shadow-lg)] group-[.toaster]:rounded-[var(--radius-md)]",
          description: "group-[.toast]:text-[var(--color-text-secondary)]",
          actionButton:
            "group-[.toast]:bg-[var(--color-accent)] group-[.toast]:text-white",
          cancelButton:
            "group-[.toast]:bg-[var(--color-surface)] group-[.toast]:text-[var(--color-text-secondary)]",
        },
      }}
      {...props}
    />
  )
}

export { Toaster }



=================================================================================
FILE: src/components/ui/switch.tsx
=================================================================================

/**
 * Switch component - iOS-style toggle
 */

import * as React from "react"
import * as SwitchPrimitives from "@radix-ui/react-switch"
import { cn } from "@/lib/utils"

const Switch = React.forwardRef<
  React.ComponentRef<typeof SwitchPrimitives.Root>,
  React.ComponentPropsWithoutRef<typeof SwitchPrimitives.Root>
>(({ className, ...props }, ref) => (
  <SwitchPrimitives.Root
    className={cn(
      "peer inline-flex h-[31px] w-[51px] shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent transition-all duration-[var(--duration-normal)] ease-[var(--ease-ios)] focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-[var(--color-accent)] focus-visible:ring-offset-2 focus-visible:ring-offset-[var(--color-background)] disabled:cursor-not-allowed disabled:opacity-38 data-[state=checked]:bg-[#34C759] data-[state=unchecked]:bg-[rgba(120,120,128,0.16)]",
      className
    )}
    {...props}
    ref={ref}
  >
    <SwitchPrimitives.Thumb
      className={cn(
        "pointer-events-none block h-[27px] w-[27px] rounded-full bg-white shadow-[0_2px_4px_rgba(0,0,0,0.12),0_0_1px_rgba(0,0,0,0.04)] ring-0 transition-transform duration-[var(--duration-normal)] ease-[var(--ease-ios-spring)] data-[state=checked]:translate-x-5 data-[state=unchecked]:translate-x-0"
      )}
    />
  </SwitchPrimitives.Root>
))
Switch.displayName = SwitchPrimitives.Root.displayName

export { Switch }



=================================================================================
FILE: src/components/ui/tabs.tsx
=================================================================================

import * as React from "react"
import * as TabsPrimitive from "@radix-ui/react-tabs"
import { cn } from "@/lib/utils"

const Tabs = TabsPrimitive.Root

const TabsList = React.forwardRef<
  React.ComponentRef<typeof TabsPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.List>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.List
    ref={ref}
    className={cn(
      "inline-flex h-11 items-center justify-center rounded-[var(--radius-md)] bg-[var(--color-surface)] p-1 text-[var(--color-text-secondary)]",
      className
    )}
    {...props}
  />
))
TabsList.displayName = TabsPrimitive.List.displayName

const TabsTrigger = React.forwardRef<
  React.ComponentRef<typeof TabsPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Trigger>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Trigger
    ref={ref}
    className={cn(
      "inline-flex items-center justify-center whitespace-nowrap rounded-[var(--radius-sm)] px-4 py-1.5 text-[15px] font-medium transition-all duration-[var(--duration-fast)] focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-[var(--color-accent)] focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:bg-[var(--color-surface-elevated)] data-[state=active]:text-[var(--color-text-primary)] data-[state=active]:shadow-[var(--shadow-sm)]",
      className
    )}
    {...props}
  />
))
TabsTrigger.displayName = TabsPrimitive.Trigger.displayName

const TabsContent = React.forwardRef<
  React.ComponentRef<typeof TabsPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Content>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Content
    ref={ref}
    className={cn(
      "mt-[var(--spacing-md)] focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-[var(--color-accent)] focus-visible:ring-offset-2",
      className
    )}
    {...props}
  />
))
TabsContent.displayName = TabsPrimitive.Content.displayName

export { Tabs, TabsList, TabsTrigger, TabsContent }



=================================================================================
FILE: src/index.css
=================================================================================

@import "tailwindcss";

/* ===== Apple-Inspired Design Tokens (2026) ===== */
:root {
  /* Typography - SF Pro-like system font stack with optimized rendering */
  --font-sans: -apple-system, BlinkMacSystemFont, "SF Pro Text", "SF Pro Display",
    "Helvetica Neue", "Segoe UI", Roboto, system-ui, sans-serif;
  --font-display: -apple-system, BlinkMacSystemFont, "SF Pro Display",
    "Helvetica Neue", "Segoe UI", Roboto, system-ui, sans-serif;

  /* Colors - Light mode (iOS 18+ / visionOS 2026 refined palette) */
  --color-background: #FFFFFF;
  --color-bg-grouped: #F2F2F7;
  --color-bg-grouped-secondary: #EFEFF4;
  --color-bg-subtle: #FAFAFA;
  --color-surface: #FFFFFF;
  --color-surface-elevated: #FFFFFF;
  --color-surface-secondary: #F9F9FB;
  --color-surface-tertiary: #F5F5F7;
  --color-border: rgba(0, 0, 0, 0.04);
  --color-border-strong: rgba(0, 0, 0, 0.06);
  --color-separator: rgba(60, 60, 67, 0.08);
  --color-separator-opaque: #E5E5EA;
  --color-text-primary: #1D1D1F;
  --color-text-secondary: rgba(60, 60, 67, 0.68);
  --color-text-tertiary: rgba(60, 60, 67, 0.42);
  --color-text-quaternary: rgba(60, 60, 67, 0.28);
  --color-accent: #007AFF;
  --color-accent-soft: rgba(0, 122, 255, 0.12);
  --color-accent-hover: #0066D6;
  --color-accent-pressed: #0055B3;
  --color-destructive: #FF3B30;
  --color-destructive-soft: rgba(255, 59, 48, 0.12);
  --color-success: #34C759;
  --color-success-soft: rgba(52, 199, 89, 0.12);
  --color-warning: #FF9500;
  --color-warning-soft: rgba(255, 149, 0, 0.12);
  --color-purple: #AF52DE;
  --color-purple-soft: rgba(175, 82, 222, 0.12);
  --color-orange: #FF9500;
  --color-orange-soft: rgba(255, 149, 0, 0.12);
  --color-red: #FF3B30;
  --color-teal: #5AC8FA;
  --color-teal-soft: rgba(90, 200, 250, 0.12);
  --color-indigo: #5856D6;
  --color-indigo-soft: rgba(88, 86, 214, 0.12);
  --color-pink: #FF2D55;
  --color-pink-soft: rgba(255, 45, 85, 0.12);
  --color-cyan: #32ADE6;
  --color-cyan-soft: rgba(50, 173, 230, 0.12);
  --color-mint: #00C7BE;
  --color-mint-soft: rgba(0, 199, 190, 0.12);
  --color-fill-primary: rgba(120, 120, 128, 0.16);
  --color-fill-secondary: rgba(120, 120, 128, 0.12);
  --color-fill-tertiary: rgba(120, 120, 128, 0.08);
  --color-fill-quaternary: rgba(120, 120, 128, 0.04);

  /* Spacing - iOS-inspired rhythm (4pt base with enhanced scale) */
  --spacing-0: 0px;
  --spacing-px: 1px;
  --spacing-0-5: 2px;
  --spacing-1: 4px;
  --spacing-1-5: 6px;
  --spacing-2: 8px;
  --spacing-2-5: 10px;
  --spacing-3: 12px;
  --spacing-3-5: 14px;
  --spacing-4: 16px;
  --spacing-5: 20px;
  --spacing-6: 24px;
  --spacing-7: 28px;
  --spacing-8: 32px;
  --spacing-9: 36px;
  --spacing-10: 40px;
  --spacing-11: 44px;
  --spacing-12: 48px;
  --spacing-14: 56px;
  --spacing-16: 64px;
  --spacing-20: 80px;

  /* Border Radius - iOS continuous corners (squircle-inspired) */
  --radius-xs: 6px;
  --radius-sm: 8px;
  --radius-md: 10px;
  --radius-lg: 12px;
  --radius-xl: 14px;
  --radius-2xl: 18px;
  --radius-3xl: 22px;
  --radius-4xl: 28px;
  --radius-full: 9999px;

  /* Shadows - refined iOS-style with natural depth (2026 ultra-subtle) */
  --shadow-xs: 0 1px 2px rgba(0, 0, 0, 0.03);
  --shadow-sm: 0 1px 3px rgba(0, 0, 0, 0.05), 0 1px 2px rgba(0, 0, 0, 0.02);
  --shadow-md: 0 2px 8px rgba(0, 0, 0, 0.06), 0 1px 3px rgba(0, 0, 0, 0.03);
  --shadow-lg: 0 4px 16px rgba(0, 0, 0, 0.08), 0 2px 4px rgba(0, 0, 0, 0.03);
  --shadow-xl: 0 8px 28px rgba(0, 0, 0, 0.10), 0 4px 8px rgba(0, 0, 0, 0.04);
  --shadow-2xl: 0 16px 48px rgba(0, 0, 0, 0.14), 0 6px 16px rgba(0, 0, 0, 0.06);
  --shadow-card: 0 1px 3px rgba(0, 0, 0, 0.04), 0 1px 2px rgba(0, 0, 0, 0.02);
  --shadow-card-hover: 0 6px 20px rgba(0, 0, 0, 0.08), 0 2px 6px rgba(0, 0, 0, 0.03);
  --shadow-card-active: 0 1px 2px rgba(0, 0, 0, 0.04);
  --shadow-button: 0 1px 3px rgba(0, 0, 0, 0.08), 0 1px 1px rgba(0, 0, 0, 0.04);
  --shadow-button-active: 0 1px 1px rgba(0, 0, 0, 0.04);
  --shadow-inset: inset 0 1px 2px rgba(0, 0, 0, 0.03);
  --shadow-up-sm: 0 -1px 3px rgba(0, 0, 0, 0.05);
  --shadow-up-lg: 0 -4px 16px rgba(0, 0, 0, 0.08);
  --shadow-sheet: 0 -8px 32px rgba(0, 0, 0, 0.12), 0 -2px 8px rgba(0, 0, 0, 0.04);
  --shadow-nav: 0 1px 0 rgba(0, 0, 0, 0.04);

  /* Blur - frosted glass effects */
  --blur-xs: 4px;
  --blur-sm: 8px;
  --blur-md: 16px;
  --blur-lg: 24px;
  --blur-xl: 40px;
  --blur-2xl: 64px;
  --blur-3xl: 80px;

  /* Safe Area Insets */
  --safe-area-inset-top: env(safe-area-inset-top, 0px);
  --safe-area-inset-right: env(safe-area-inset-right, 0px);
  --safe-area-inset-bottom: env(safe-area-inset-bottom, 0px);
  --safe-area-inset-left: env(safe-area-inset-left, 0px);

  /* Animation - Apple-tuned curves with refined timing (iOS 18 / 2026) */
  --duration-instant: 100ms;
  --duration-fast: 180ms;
  --duration-normal: 250ms;
  --duration-slow: 350ms;
  --duration-slower: 450ms;
  --duration-sheet: 400ms;
  --ease-out: cubic-bezier(0.16, 1, 0.3, 1);
  --ease-in: cubic-bezier(0.7, 0, 1, 0.5);
  --ease-in-out: cubic-bezier(0.4, 0, 0.2, 1);
  --ease-spring: cubic-bezier(0.175, 0.885, 0.32, 1.175);
  --ease-ios: cubic-bezier(0.25, 0.1, 0.25, 1);
  --ease-ios-spring: cubic-bezier(0.16, 1.11, 0.3, 1.02);
  --ease-bounce: cubic-bezier(0.34, 1.4, 0.64, 1);
}

/* ===== Base Styles ===== */
* {
  box-sizing: border-box;
}

html {
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  text-rendering: optimizeLegibility;
  font-feature-settings: "kern" 1, "liga" 1;
}

body {
  margin: 0;
  padding: 0;
  font-family: var(--font-sans);
  background-color: var(--color-bg-grouped);
  color: var(--color-text-primary);
  line-height: 1.47;
  font-size: 17px;
  letter-spacing: -0.022em;
  min-height: 100vh;
  min-height: 100dvh;
  -webkit-tap-highlight-color: transparent;
  touch-action: manipulation;
  scroll-behavior: smooth;
  overscroll-behavior-y: none;
}

#root {
  min-height: 100vh;
  min-height: 100dvh;
  display: flex;
  flex-direction: column;
}

/* ===== Typography Scale (SF Pro-inspired, 2026 refinements) ===== */
.text-large-title, h1 {
  font-size: 34px;
  font-weight: 700;
  line-height: 1.10;
  letter-spacing: -0.4px;
}

.text-title-1, h2 {
  font-size: 28px;
  font-weight: 700;
  line-height: 1.14;
  letter-spacing: -0.36px;
}

.text-title-2 {
  font-size: 22px;
  font-weight: 700;
  line-height: 1.18;
  letter-spacing: -0.28px;
}

.text-title-3, h3 {
  font-size: 20px;
  font-weight: 600;
  line-height: 1.20;
  letter-spacing: -0.24px;
}

.text-headline, h4 {
  font-size: 17px;
  font-weight: 600;
  line-height: 1.24;
  letter-spacing: -0.41px;
}

.text-body, p {
  font-size: 17px;
  font-weight: 400;
  line-height: 1.47;
  letter-spacing: -0.41px;
}

.text-callout {
  font-size: 16px;
  font-weight: 400;
  line-height: 1.35;
  letter-spacing: -0.32px;
}

.text-subheadline {
  font-size: 15px;
  font-weight: 400;
  line-height: 1.40;
  letter-spacing: -0.24px;
}

.text-footnote {
  font-size: 13px;
  font-weight: 400;
  line-height: 1.42;
  letter-spacing: -0.08px;
  color: var(--color-text-secondary);
}

.text-caption-1 {
  font-size: 12px;
  font-weight: 500;
  line-height: 1.33;
  letter-spacing: 0px;
  color: var(--color-text-tertiary);
}

.text-caption-2 {
  font-size: 11px;
  font-weight: 500;
  line-height: 1.27;
  letter-spacing: 0.06px;
  color: var(--color-text-tertiary);
}

/* Section label - uppercase with proper letter spacing */
.text-section-label {
  font-size: 13px;
  font-weight: 600;
  line-height: 1.23;
  letter-spacing: 0.02em;
  text-transform: uppercase;
  color: var(--color-text-tertiary);
}

/* ===== Focus States ===== */
:focus-visible {
  outline: 3px solid var(--color-accent-soft);
  outline-offset: 2px;
}

button:focus-visible,
a:focus-visible,
[role="button"]:focus-visible {
  outline: 2px solid var(--color-accent);
  outline-offset: 2px;
}

/* ===== Reduced Motion ===== */
@media (prefers-reduced-motion: reduce) {
  *,
  *::before,
  *::after {
    animation-duration: 0.01ms !important;
    animation-iteration-count: 1 !important;
    transition-duration: 0.01ms !important;
    scroll-behavior: auto !important;
  }
}

/* ===== Utility Classes ===== */
.safe-area-padding {
  padding-top: var(--safe-area-inset-top);
  padding-right: var(--safe-area-inset-right);
  padding-bottom: var(--safe-area-inset-bottom);
  padding-left: var(--safe-area-inset-left);
}

.safe-area-padding-x {
  padding-left: var(--safe-area-inset-left);
  padding-right: var(--safe-area-inset-right);
}

.safe-area-padding-y {
  padding-top: var(--safe-area-inset-top);
  padding-bottom: var(--safe-area-inset-bottom);
}

.safe-area-margin-bottom {
  margin-bottom: var(--safe-area-inset-bottom);
}

/* Glass morphism effects - refined for iOS 18 / 2026 aesthetic */
.glass {
  background: rgba(255, 255, 255, 0.85);
  backdrop-filter: saturate(180%) blur(var(--blur-xl));
  -webkit-backdrop-filter: saturate(180%) blur(var(--blur-xl));
}

.glass-subtle {
  background: rgba(255, 255, 255, 0.92);
  backdrop-filter: saturate(150%) blur(var(--blur-lg));
  -webkit-backdrop-filter: saturate(150%) blur(var(--blur-lg));
}

.glass-solid {
  background: rgba(255, 255, 255, 0.98);
  backdrop-filter: saturate(140%) blur(var(--blur-md));
  -webkit-backdrop-filter: saturate(140%) blur(var(--blur-md));
}

.glass-sheet {
  background: rgba(255, 255, 255, 0.98);
  backdrop-filter: saturate(180%) blur(var(--blur-3xl));
  -webkit-backdrop-filter: saturate(180%) blur(var(--blur-3xl));
}

.glass-nav {
  background: rgba(255, 255, 255, 0.94);
  backdrop-filter: saturate(180%) blur(28px);
  -webkit-backdrop-filter: saturate(180%) blur(28px);
}

.glass-card {
  background: rgba(255, 255, 255, 0.90);
  backdrop-filter: saturate(160%) blur(var(--blur-lg));
  -webkit-backdrop-filter: saturate(160%) blur(var(--blur-lg));
}

/* Hide scrollbar for carousel elements */
.scrollbar-none {
  -ms-overflow-style: none;
  scrollbar-width: none;
}

.scrollbar-none::-webkit-scrollbar {
  display: none;
}

/* Note: grouped-list, section-header, list-row, list-separator replaced by
   React components: Card variant="grouped", SectionLabel, ListRow, Separator */

/* Touch target minimum */
.touch-target {
  min-height: 44px;
  min-width: 44px;
}

/* iOS-style tap highlight */
@media (hover: none) {
  .tap-highlight:active {
    background-color: var(--color-fill-quaternary);
  }
}

/* Smooth scroll for carousels */
.scroll-smooth {
  scroll-behavior: smooth;
}

/* iOS-native scroll behavior for sheets */
.sheet-scroll {
  -webkit-overflow-scrolling: touch;
  overscroll-behavior: contain;
}

/* Skeleton animation - ultra-smooth, subtle */
@keyframes shimmer {
  0% {
    background-position: -200% 0;
  }
  100% {
    background-position: 200% 0;
  }
}

.skeleton-shimmer {
  background: linear-gradient(
    90deg,
    rgba(120, 120, 128, 0.08) 0%,
    rgba(120, 120, 128, 0.04) 50%,
    rgba(120, 120, 128, 0.08) 100%
  );
  background-size: 200% 100%;
  animation: shimmer 1.8s ease-in-out infinite;
  border-radius: var(--radius-sm);
}

/* Pulse animation for subtle loading states */
@keyframes subtle-pulse {
  0%, 100% {
    opacity: 1;
  }
  50% {
    opacity: 0.6;
  }
}

.animate-subtle-pulse {
  animation: subtle-pulse 2s ease-in-out infinite;
}

/* Note: card-surface, card-surface-interactive, grouped-container
   replaced by Card component variants */

/* Active press state for buttons */
.press-scale {
  transition: transform var(--duration-fast) var(--ease-out);
}

.press-scale:active {
  transform: scale(0.97);
}

/* Pill button style */
.pill {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  height: 32px;
  padding: 0 var(--spacing-3);
  border-radius: var(--radius-full);
  font-size: 14px;
  font-weight: 500;
  letter-spacing: -0.01em;
  transition: all var(--duration-fast) var(--ease-out);
}

.pill-active {
  background-color: var(--color-accent);
  color: white;
  box-shadow: var(--shadow-xs);
}

.pill-inactive {
  background-color: var(--color-fill-tertiary);
  color: var(--color-text-secondary);
}

.pill-inactive:active {
  background-color: var(--color-fill-secondary);
}

/* Drag indicator for bottom sheets - iOS HIG compliant */
.drag-indicator {
  width: 36px;
  height: 5px;
  border-radius: 100px;
  background-color: rgba(60, 60, 67, 0.20);
  margin: 8px auto 0;
  flex-shrink: 0;
}

/* Note: section-label, section-group, inset-row, section-subhead
   replaced by SectionLabel, Card variant="grouped", ListRow components */

/* Header large title style */
.large-title {
  font-size: 34px;
  font-weight: 700;
  letter-spacing: -0.4px;
  line-height: 1.10;
  color: var(--color-text-primary);
}

/* Segmented control */
.segmented-control {
  display: inline-flex;
  padding: 2px;
  background-color: var(--color-fill-tertiary);
  border-radius: var(--radius-sm);
}

.segmented-control-item {
  padding: 5px 12px;
  font-size: 13px;
  font-weight: 500;
  border-radius: 6px;
  color: var(--color-text-secondary);
  transition: all var(--duration-fast) var(--ease-ios);
}

.segmented-control-item[data-active="true"] {
  background-color: var(--color-surface);
  color: var(--color-text-primary);
  box-shadow: var(--shadow-xs);
}

/* Input field styling */
.input-field {
  height: 40px;
  padding: 0 14px;
  font-size: 16px;
  background-color: var(--color-fill-tertiary);
  border-radius: var(--radius-lg);
  border: none;
  color: var(--color-text-primary);
  transition: box-shadow var(--duration-fast) var(--ease-ios);
}

.input-field::placeholder {
  color: var(--color-text-tertiary);
}

.input-field:focus {
  outline: none;
  box-shadow: 0 0 0 3px var(--color-accent-soft);
}

/* Pill tag style - for topics, categories */
.pill-tag {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  height: 30px;
  padding: 0 14px;
  border-radius: var(--radius-full);
  font-size: 13px;
  font-weight: 500;
  letter-spacing: -0.01em;
  background-color: var(--color-surface);
  color: var(--color-text-secondary);
  box-shadow: 0 0.5px 1px rgba(0, 0, 0, 0.04), 0 0 0 0.5px rgba(0, 0, 0, 0.02);
  transition: all var(--duration-fast) var(--ease-out);
}

/* Note: list-row-interactive, section-title, card-grouped, topic-pill,
   list-row-inset, card-interactive replaced by ListRow, SectionLabel,
   Card, Badge components */

/* Page header subtitle */
.page-subtitle {
  font-size: 15px;
  font-weight: 400;
  line-height: 1.5;
  letter-spacing: -0.2px;
  color: var(--color-text-secondary);
  margin-top: -2px;
}

/* Refined bullet point */
.bullet-dot {
  width: 6px;
  height: 6px;
  border-radius: 50%;
  flex-shrink: 0;
}

/* Source meta text */
.meta-text {
  font-size: 13px;
  letter-spacing: -0.1px;
  color: var(--color-text-tertiary);
}

/* Footer text */
.footer-text {
  font-size: 12px;
  letter-spacing: -0.1px;
  color: var(--color-text-quaternary);
  line-height: 1.5;
}

/* Subtle focus ring */
.focus-ring:focus-visible {
  outline: none;
  box-shadow: 0 0 0 3px var(--color-accent-soft), 0 0 0 1px var(--color-accent);
}

/* iOS-style active state for list items */
.list-active {
  transition: background-color var(--duration-instant) var(--ease-out);
}

.list-active:active {
  background-color: var(--color-fill-quaternary);
}

/* Content visibility optimization - prevents layout popping
   Using auto allows browser to remember actual size after first render
   280px = approximate height of card with image (2:1 aspect ~160px + content ~120px) */
.content-visibility-auto {
  content-visibility: auto;
  contain-intrinsic-block-size: auto 280px;
}

/* Improved text rendering for headlines */
.headline-text {
  text-rendering: optimizeLegibility;
  font-feature-settings: "kern" 1, "liga" 1;
  word-spacing: -0.02em;
}

/* Accent gradient for branded elements */
.accent-gradient {
  background: linear-gradient(135deg, var(--color-accent) 0%, #5856D6 100%);
}

/* Subtle inner shadow for inputs */
.input-inset {
  box-shadow: inset 0 1px 2px rgba(0, 0, 0, 0.03);
}

/* Enhanced loading spinner */
@keyframes spin-smooth {
  0% {
    transform: rotate(0deg);
  }
  100% {
    transform: rotate(360deg);
  }
}

.spinner {
  animation: spin-smooth 0.8s linear infinite;
}

/* ===== Layout & Utility Patterns ===== */

/* Section container with consistent vertical rhythm */
.section-container {
  margin-bottom: var(--spacing-8);
}

/* Page description text */
.page-description {
  font-size: 15px;
  font-weight: 400;
  line-height: 1.52;
  letter-spacing: -0.2px;
  color: var(--color-text-secondary);
}

/* Stats/meta text */
.stats-text {
  font-size: 13px;
  font-weight: 500;
  letter-spacing: -0.08px;
  color: var(--color-text-tertiary);
}

/* Note: section-heading, card-container, card-row, separator-inset,
   separator-full replaced by SectionLabel, Card, ListRow, Separator components */

/* Accent dot indicator */
.accent-dot {
  width: 7px;
  height: 7px;
  border-radius: 50%;
  background: linear-gradient(135deg, #007AFF 0%, #5856D6 100%);
  flex-shrink: 0;
}

/* Note: pill-tag-refined, section-label-with-icon replaced by Badge, SectionLabel components */

/* Smooth content fade-in */
@keyframes content-fade-in {
  from {
    opacity: 0;
    transform: translateY(8px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

.animate-content-in {
  animation: content-fade-in var(--duration-normal) var(--ease-out);
}

/* Scroll shadow indicators */
.scroll-shadow-top {
  box-shadow: inset 0 12px 8px -8px rgba(0, 0, 0, 0.04);
}

.scroll-shadow-bottom {
  box-shadow: inset 0 -12px 8px -8px rgba(0, 0, 0, 0.04);
}


=================================================================================
FILE: src/layouts/MainLayout.tsx
=================================================================================

import { Outlet, useLocation, useNavigate } from "react-router-dom"
import { Newspaper, LayoutList, Globe, Bookmark, Settings, ChevronRight, Sparkles, type LucideIcon } from "lucide-react"
import { AppLogo } from "@/components/ui/app-logo"
import {
  Sheet,
  SheetContent,
  SheetHeader,
  SheetTitle,
  SheetTrigger,
} from "@/components/ui/sheet"
import { Card, Separator } from "@/components/ui"
import { useState, createContext, useContext } from "react"
import { hapticMedium } from "@/lib/haptics"
import { cn } from "@/lib/utils"
import { TopNav, MenuButton } from "@/components/layout"
import { useLargeTitle } from "@/lib/hooks"

// Context to share large title state with child pages
interface LargeTitleContextValue {
  titleRef: React.RefObject<HTMLDivElement | null>
  isVisible: boolean
}

const LargeTitleContext = createContext<LargeTitleContextValue | null>(null)

export function useLargeTitleContext() {
  const context = useContext(LargeTitleContext)
  if (!context) {
    throw new Error("useLargeTitleContext must be used within MainLayout")
  }
  return context
}

interface NavItem {
  path: string
  label: string
  icon: LucideIcon
  iconBg: string
  description?: string
}

const primaryNavItems: NavItem[] = [
  { path: "/", label: "Today", icon: Newspaper, iconBg: "#007AFF", description: "Daily brief" },
  { path: "/feed", label: "Feed", icon: LayoutList, iconBg: "#FF9500", description: "All articles" },
  { path: "/ask", label: "Ask AI", icon: Sparkles, iconBg: "#AF52DE", description: "Chat with sources" },
  { path: "/sources", label: "Sources", icon: Globe, iconBg: "#32ADE6", description: "News sources" },
  { path: "/bookmarks", label: "Bookmarks", icon: Bookmark, iconBg: "#FF2D55", description: "Saved articles" },
]

const secondaryNavItems: NavItem[] = [
  { path: "/settings", label: "Settings", icon: Settings, iconBg: "#8E8E93", description: "Preferences" },
]

const allNavItems = [...primaryNavItems, ...secondaryNavItems]

function getPageTitle(pathname: string): string {
  const item = allNavItems.find((nav) => nav.path === pathname)
  return item?.label ?? "Today"
}

export function MainLayout() {
  const location = useLocation()
  const navigate = useNavigate()
  const [open, setOpen] = useState(false)
  const { titleRef, isVisible } = useLargeTitle()

  const handleNavigation = (path: string) => {
    navigate(path)
    setOpen(false)
  }

  const pageTitle = getPageTitle(location.pathname)

  // Menu trigger element for TopNav (contains full Sheet with trigger + content)
  const menuTrigger = (
    <Sheet open={open} onOpenChange={setOpen}>
      <SheetTrigger asChild>
        <MenuButton />
      </SheetTrigger>
      <SheetContent
        side="right"
        className="w-[300px] border-l-0 bg-[var(--color-bg-grouped)] p-0"
      >
        <SheetHeader className="sr-only">
          <SheetTitle>Navigation Menu</SheetTitle>
        </SheetHeader>

        <div className="flex h-full flex-col">
          {/* Header with brand - padding accounts for safe area */}
          <div className="px-[20px] pb-[28px]" style={{ paddingTop: 'calc(20px + var(--safe-area-inset-top))' }}>
            <div className="flex items-center gap-[14px]">
              {/* Logo container for consistent sizing */}
              <div className="flex h-[44px] w-[44px] items-center justify-center shrink-0">
                <AppLogo size={44} glow className="drop-shadow-[0_2px_8px_rgba(53,211,255,0.3)]" />
              </div>
              <span className="text-[19px] font-bold tracking-[-0.4px] text-[var(--color-text-primary)]">
                P&C Brief
              </span>
            </div>
          </div>

          {/* Primary Navigation */}
          <nav className="flex-1 px-[12px]">
            <p className="mb-[6px] ml-[8px] text-[12px] font-semibold uppercase tracking-[0.4px] text-[var(--color-text-tertiary)]">
              Navigation
            </p>
            <Card variant="grouped">
              {primaryNavItems.map((item, index) => {
                const isActive = location.pathname === item.path
                const Icon = item.icon
                const isNextActive = location.pathname === primaryNavItems[index + 1]?.path
                return (
                  <div key={item.path}>
                    <button
                      onClick={() => {
                        hapticMedium()
                        handleNavigation(item.path)
                      }}
                      className={cn(
                        "flex w-full items-center gap-[12px] px-[14px] py-[11px] text-left transition-all duration-[var(--duration-fast)]",
                        isActive
                          ? "bg-[var(--color-accent)]"
                          : "active:bg-[var(--color-fill-quaternary)]"
                      )}
                    >
                      <div
                        className="flex h-[30px] w-[30px] items-center justify-center rounded-[7px]"
                        style={{
                          backgroundColor: isActive ? 'rgba(255,255,255,0.22)' : `${item.iconBg}14`
                        }}
                      >
                        <Icon
                          className="h-[16px] w-[16px]"
                          style={{ color: isActive ? 'white' : item.iconBg }}
                          strokeWidth={1.8}
                        />
                      </div>
                      <div className="flex-1 min-w-0">
                        <span
                          className={cn(
                            "block text-[15px] font-semibold tracking-[-0.2px]",
                            isActive ? "text-white" : "text-[var(--color-text-primary)]"
                          )}
                        >
                          {item.label}
                        </span>
                        {item.description && (
                          <span
                            className={cn(
                              "block text-[12px] tracking-[-0.04px] mt-[1px]",
                              isActive ? "text-white/70" : "text-[var(--color-text-secondary)]"
                            )}
                          >
                            {item.description}
                          </span>
                        )}
                      </div>
                      <ChevronRight
                        className={cn(
                          "h-[14px] w-[14px] shrink-0",
                          isActive ? "text-white/50" : "text-[var(--color-text-tertiary)]"
                        )}
                        strokeWidth={2.5}
                      />
                    </button>
                    {index < primaryNavItems.length - 1 && !isActive && !isNextActive && (
                      <Separator className="ml-[56px]" />
                    )}
                  </div>
                )
              })}
            </Card>

            {/* Secondary Navigation */}
            <Card variant="grouped" className="mt-[14px]">
              {secondaryNavItems.map((item) => {
                const isActive = location.pathname === item.path
                const Icon = item.icon
                return (
                  <button
                    key={item.path}
                    onClick={() => {
                      hapticMedium()
                      handleNavigation(item.path)
                    }}
                    className={cn(
                      "flex w-full items-center gap-[12px] px-[14px] py-[11px] text-left transition-all duration-[var(--duration-fast)]",
                      isActive
                        ? "bg-[var(--color-accent)]"
                        : "active:bg-[var(--color-fill-quaternary)]"
                    )}
                  >
                    <div
                      className={cn(
                        "flex h-[30px] w-[30px] items-center justify-center rounded-[7px]",
                        isActive
                          ? "bg-white/22"
                          : "bg-[var(--color-fill-tertiary)]"
                      )}
                    >
                      <Icon
                        className={cn(
                          "h-[16px] w-[16px]",
                          isActive ? "text-white" : "text-[var(--color-text-secondary)]"
                        )}
                        strokeWidth={1.8}
                      />
                    </div>
                    <div className="flex-1 min-w-0">
                      <span
                        className={cn(
                          "block text-[15px] font-semibold tracking-[-0.2px]",
                          isActive ? "text-white" : "text-[var(--color-text-primary)]"
                        )}
                      >
                        {item.label}
                      </span>
                      {item.description && (
                        <span
                          className={cn(
                            "block text-[12px] tracking-[-0.04px] mt-[1px]",
                            isActive ? "text-white/70" : "text-[var(--color-text-secondary)]"
                          )}
                        >
                          {item.description}
                        </span>
                      )}
                    </div>
                    <ChevronRight
                      className={cn(
                        "h-[14px] w-[14px] shrink-0",
                        isActive ? "text-white/50" : "text-[var(--color-text-tertiary)]"
                      )}
                      strokeWidth={2.5}
                    />
                  </button>
                )
              })}
            </Card>
          </nav>

          {/* Footer */}
          <div className="px-[20px] pb-[calc(24px+var(--safe-area-inset-bottom))] pt-[20px] text-center">
            <p className="text-[10px] font-medium tracking-[-0.02em] text-[var(--color-text-quaternary)]">
              Made in Hackensack
            </p>
          </div>
        </div>
      </SheetContent>
    </Sheet>
  )

  return (
    <LargeTitleContext.Provider value={{ titleRef, isVisible }}>
      <div className="flex min-h-screen flex-col bg-[var(--color-bg-grouped)]">
        {/* Top Navigation Bar */}
        <TopNav
          title={pageTitle}
          isLargeTitleVisible={isVisible}
          menuTrigger={menuTrigger}
        />

        {/* Main Content */}
        <main className="flex-1 flex flex-col overflow-hidden">
          <div className="safe-area-padding-x flex-1 flex flex-col overflow-hidden">
            {/* Full-bleed layout for /ask route (no title, no padding) */}
            {location.pathname === "/ask" ? (
              <div className="flex-1 flex flex-col overflow-hidden">
                <Outlet />
              </div>
            ) : (
              <div className="mx-auto max-w-2xl px-[var(--spacing-4)] pb-[52px] pt-[20px] flex-1 overflow-auto">
                {/* Large Page Title - iOS style with ref for IntersectionObserver */}
                <div ref={titleRef}>
                  <h1 className="mb-[20px] text-[32px] font-bold leading-[1.1] tracking-[-0.4px] text-[var(--color-text-primary)]">
                    {pageTitle}
                  </h1>
                </div>
                <Outlet />
              </div>
            )}
          </div>
        </main>

        {/* Safe area bottom padding */}
        <div style={{ paddingBottom: 'var(--safe-area-inset-bottom)' }} />
      </div>
    </LargeTitleContext.Provider>
  )
}



=================================================================================
FILE: src/lib/analytics.ts
=================================================================================

/**
 * Lightweight Analytics Utility
 * 
 * Simple event tracking for key user actions.
 * Uses Firebase Analytics when available, falls back to console.log in dev.
 */

// Event names for Ask AI feature
export type AskAnalyticsEvent =
  | "ask_sent"
  | "ask_answered"
  | "ask_no_coverage"
  | "citation_opened"
  | "follow_up_clicked"

// Event parameters
export interface AskEventParams {
  scope?: string
  source_filter?: string
  source_count?: number
  article_id?: string
  has_citations?: boolean
  response_time_ms?: number
}

// Simple in-memory debounce for duplicate events
const recentEvents = new Map<string, number>()
const DEBOUNCE_MS = 1000

/**
 * Track an analytics event
 * 
 * In production, this would send to Firebase Analytics.
 * For now, we log to console in dev and store basic metrics.
 */
export function trackEvent(
  event: AskAnalyticsEvent,
  params?: AskEventParams
): void {
  try {
    // Create a key for debouncing
    const eventKey = `${event}_${JSON.stringify(params || {})}`
    const now = Date.now()
    const lastTime = recentEvents.get(eventKey)
    
    // Skip if same event was fired recently
    if (lastTime && now - lastTime < DEBOUNCE_MS) {
      return
    }
    
    recentEvents.set(eventKey, now)
    
    // Clean old entries periodically
    if (recentEvents.size > 100) {
      const cutoff = now - DEBOUNCE_MS * 10
      for (const [key, time] of recentEvents.entries()) {
        if (time < cutoff) recentEvents.delete(key)
      }
    }

    // Log in development
    if (import.meta.env.DEV) {
      console.log(`[Analytics] ${event}`, params || {})
    }

    // TODO: In production, send to Firebase Analytics
    // import { getAnalytics, logEvent } from "firebase/analytics"
    // const analytics = getAnalytics()
    // logEvent(analytics, event, params)
    
    // For now, store basic metrics in localStorage for debugging
    try {
      const metricsKey = "pcbrief_analytics"
      const metrics = JSON.parse(localStorage.getItem(metricsKey) || "{}")
      metrics[event] = (metrics[event] || 0) + 1
      metrics.lastEvent = { event, params, timestamp: new Date().toISOString() }
      localStorage.setItem(metricsKey, JSON.stringify(metrics))
    } catch {
      // Silently ignore storage errors
    }
  } catch {
    // Analytics should never break the app
  }
}

/**
 * Get analytics summary (for debugging)
 */
export function getAnalyticsSummary(): Record<string, unknown> {
  try {
    const metricsKey = "pcbrief_analytics"
    return JSON.parse(localStorage.getItem(metricsKey) || "{}")
  } catch {
    return {}
  }
}



=================================================================================
FILE: src/lib/auth-context.tsx
=================================================================================

/**
 * Firebase Auth Context
 *
 * Provides authentication state throughout the app.
 * Uses anonymous auth by default for user preferences.
 */

import {
  createContext,
  useContext,
  useEffect,
  useState,
  type ReactNode,
} from "react"
import {
  onAuthStateChanged,
  signInAnonymously,
  type User,
} from "firebase/auth"
import { auth } from "@/lib/firebase"

interface AuthContextValue {
  user: User | null
  isLoading: boolean
  isAuthenticated: boolean
}

const AuthContext = createContext<AuthContextValue>({
  user: null,
  isLoading: true,
  isAuthenticated: false,
})

export function AuthProvider({ children }: { children: ReactNode }) {
  const [user, setUser] = useState<User | null>(null)
  const [isLoading, setIsLoading] = useState(true)

  useEffect(() => {
    const unsubscribe = onAuthStateChanged(auth, async (firebaseUser) => {
      if (firebaseUser) {
        setUser(firebaseUser)
        setIsLoading(false)
      } else {
        // Sign in anonymously if no user
        try {
          await signInAnonymously(auth)
          // onAuthStateChanged will fire again with the new user
        } catch (error) {
          console.error("Anonymous auth failed:", error)
          setIsLoading(false)
        }
      }
    })

    return () => unsubscribe()
  }, [])

  return (
    <AuthContext.Provider
      value={{
        user,
        isLoading,
        isAuthenticated: !!user,
      }}
    >
      {children}
    </AuthContext.Provider>
  )
}

export function useAuth() {
  return useContext(AuthContext)
}



=================================================================================
FILE: src/lib/cache.ts
=================================================================================

/**
 * LocalStorage Cache Utility
 * 
 * Simple TTL-based cache for expensive data like the Today brief.
 * Provides instant fallback while fresh data loads.
 */

interface CacheEntry<T> {
  data: T
  timestamp: number
  ttl: number
}

const CACHE_PREFIX = "pcbrief_cache_"

/**
 * Get cached data if valid (not expired)
 */
export function getCached<T>(key: string): T | null {
  try {
    const raw = localStorage.getItem(CACHE_PREFIX + key)
    if (!raw) return null

    const entry: CacheEntry<T> = JSON.parse(raw)
    const now = Date.now()
    const age = now - entry.timestamp

    // Return data if within TTL
    if (age < entry.ttl) {
      return entry.data
    }

    // Expired - remove and return null
    localStorage.removeItem(CACHE_PREFIX + key)
    return null
  } catch {
    return null
  }
}

/**
 * Set cached data with TTL
 * @param key Cache key
 * @param data Data to cache
 * @param ttlMs Time-to-live in milliseconds (default: 30 minutes)
 */
export function setCache<T>(key: string, data: T, ttlMs: number = 30 * 60 * 1000): void {
  try {
    const entry: CacheEntry<T> = {
      data,
      timestamp: Date.now(),
      ttl: ttlMs,
    }
    localStorage.setItem(CACHE_PREFIX + key, JSON.stringify(entry))
  } catch {
    // Storage may be full or disabled - silently ignore
  }
}

/**
 * Remove cached data
 */
export function removeCache(key: string): void {
  try {
    localStorage.removeItem(CACHE_PREFIX + key)
  } catch {
    // Silently ignore
  }
}

/**
 * Clear all cache entries
 */
export function clearCache(): void {
  try {
    const keys = Object.keys(localStorage).filter((k) => k.startsWith(CACHE_PREFIX))
    keys.forEach((k) => localStorage.removeItem(k))
  } catch {
    // Silently ignore
  }
}



=================================================================================
FILE: src/lib/firebase.ts
=================================================================================

/**
 * Firebase Client SDK Initialization
 *
 * Initializes the Firebase app and exports Functions, Firestore, and Auth instances.
 * Enables offline persistence for improved performance and reduced reads.
 */

import { initializeApp, getApps, getApp } from "firebase/app"
import { getFunctions, connectFunctionsEmulator } from "firebase/functions"
import {
  initializeFirestore,
  persistentLocalCache,
  persistentMultipleTabManager,
  connectFirestoreEmulator,
  type Firestore,
} from "firebase/firestore"
import { getAuth, connectAuthEmulator } from "firebase/auth"

// Firebase configuration
// These are public keys - safe to expose in client code
const firebaseConfig = {
  apiKey: "AIzaSyC55lowlixG6V8KI-bWV4T-x6MiuNp38-g",
  projectId: "insurance-news-ai",
  authDomain: "insurance-news-ai.firebaseapp.com",
  storageBucket: "insurance-news-ai.firebasestorage.app",
  messagingSenderId: "695640024145",
  appId: "1:695640024145:web:ab17c496e14b3d915ac470",
}

// Initialize Firebase (singleton pattern)
const app = getApps().length === 0 ? initializeApp(firebaseConfig) : getApp()

// Get Functions instance
const functions = getFunctions(app, "us-central1")

// Initialize Firestore with offline persistence
// Uses IndexedDB for caching and supports multiple tabs
let db: Firestore
try {
  db = initializeFirestore(app, {
    localCache: persistentLocalCache({
      tabManager: persistentMultipleTabManager(),
    }),
  })
} catch {
  // Firestore may already be initialized (hot reload), use existing instance
  const { getFirestore } = await import("firebase/firestore")
  db = getFirestore(app)
}

// Get Auth instance
const auth = getAuth(app)

// Connect to emulators in development
if (import.meta.env.DEV && import.meta.env.VITE_FIREBASE_USE_EMULATOR === "true") {
  connectFunctionsEmulator(functions, "localhost", 5001)
  connectFirestoreEmulator(db, "localhost", 8080)
  connectAuthEmulator(auth, "http://localhost:9099")
}

export { app, functions, db, auth }



=================================================================================
FILE: src/lib/haptics.ts
=================================================================================

/**
 * iOS Haptic Feedback Utility
 * 
 * Provides haptic feedback on iOS devices. Gracefully no-ops on web.
 */

import { Capacitor } from "@capacitor/core"
import { Haptics, ImpactStyle, NotificationType } from "@capacitor/haptics"

const isNative = Capacitor.isNativePlatform()

/**
 * Light impact - for subtle UI feedback (toggles, selections)
 */
export async function hapticLight(): Promise<void> {
  if (!isNative) return
  try {
    await Haptics.impact({ style: ImpactStyle.Light })
  } catch {
    // Silently ignore errors
  }
}

/**
 * Medium impact - for button presses, card taps
 */
export async function hapticMedium(): Promise<void> {
  if (!isNative) return
  try {
    await Haptics.impact({ style: ImpactStyle.Medium })
  } catch {
    // Silently ignore errors
  }
}

/**
 * Heavy impact - for significant actions
 */
export async function hapticHeavy(): Promise<void> {
  if (!isNative) return
  try {
    await Haptics.impact({ style: ImpactStyle.Heavy })
  } catch {
    // Silently ignore errors
  }
}

/**
 * Selection changed - for picker/segment changes
 */
export async function hapticSelection(): Promise<void> {
  if (!isNative) return
  try {
    await Haptics.selectionChanged()
  } catch {
    // Silently ignore errors
  }
}

/**
 * Success notification - for successful actions
 */
export async function hapticSuccess(): Promise<void> {
  if (!isNative) return
  try {
    await Haptics.notification({ type: NotificationType.Success })
  } catch {
    // Silently ignore errors
  }
}

/**
 * Warning notification - for warnings
 */
export async function hapticWarning(): Promise<void> {
  if (!isNative) return
  try {
    await Haptics.notification({ type: NotificationType.Warning })
  } catch {
    // Silently ignore errors
  }
}

/**
 * Error notification - for errors
 */
export async function hapticError(): Promise<void> {
  if (!isNative) return
  try {
    await Haptics.notification({ type: NotificationType.Error })
  } catch {
    // Silently ignore errors
  }
}



=================================================================================
FILE: src/lib/hooks/index.ts
=================================================================================

/**
 * Custom hooks for P&C Insurance News AI
 */

export { useTodayBrief, type TodayBriefResponse, type TopStoryWithArticle } from "./use-today-brief"
export { useArticles, useSources, useAllSources, type ArticleFilters } from "./use-articles"
export {
  useBookmarks,
  useIsBookmarked,
  useToggleBookmark,
  useArticleAI,
  useCachedArticleAI,
} from "./use-bookmarks"
export {
  useUserPreferences,
  useToggleSource,
  useResetSourcePreferences,
  useToggleNotifications,
} from "./use-user-preferences"
export { usePushNotifications } from "./use-push-notifications"
export { useLargeTitle, useLargeTitleWithScroll } from "./use-large-title"
export {
  useChatThreads,
  useCreateThread,
  useAppendMessage,
  useChatMessages,
  useDeleteThread,
  type CreateThreadInput,
  type AppendMessageInput,
} from "./use-chat-threads"



=================================================================================
FILE: src/lib/hooks/use-articles.ts
=================================================================================

/**
 * Hook for fetching articles with infinite scroll, filters, and search
 */

import { useInfiniteQuery, useQuery } from "@tanstack/react-query"
import {
  collection,
  query,
  orderBy,
  limit,
  startAfter,
  where,
  getDocs,
  Timestamp,
  QueryDocumentSnapshot,
  type DocumentData,
} from "firebase/firestore"
import { db } from "@/lib/firebase"
import type { Article, SourceCategory } from "@/types/firestore"

const ARTICLES_PER_PAGE = 20

export interface ArticleFilters {
  category?: SourceCategory | "all"
  sourceIds?: string[]
  timeWindow?: "24h" | "7d" | "all"
  searchQuery?: string
}

// Convert Firestore doc to Article
function docToArticle(doc: QueryDocumentSnapshot<DocumentData>): Article {
  const data = doc.data()
  return {
    id: doc.id,
    sourceId: data.sourceId,
    sourceName: data.sourceName,
    title: data.title,
    snippet: data.snippet,
    url: data.url,
    canonicalUrl: data.canonicalUrl,
    guid: data.guid,
    imageUrl: data.imageUrl,
    categories: data.categories,
    publishedAt: data.publishedAt,
    ingestedAt: data.ingestedAt,
    relevanceScore: data.relevanceScore,
    isRelevant: data.isRelevant,
    ai: data.ai,
  } as Article
}

// Get time threshold for filtering
function getTimeThreshold(timeWindow: "24h" | "7d" | "all"): Date | null {
  if (timeWindow === "all") return null
  const now = new Date()
  if (timeWindow === "24h") {
    return new Date(now.getTime() - 24 * 60 * 60 * 1000)
  }
  return new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000)
}

interface FetchArticlesParams {
  filters: ArticleFilters
  pageParam?: QueryDocumentSnapshot<DocumentData> | null
}

async function fetchArticles({ filters, pageParam }: FetchArticlesParams) {
  const articlesRef = collection(db, "articles")
  const constraints: Parameters<typeof query>[1][] = []

  // Time window filter
  const timeThreshold = getTimeThreshold(filters.timeWindow ?? "all")
  if (timeThreshold) {
    constraints.push(where("publishedAt", ">=", Timestamp.fromDate(timeThreshold)))
  }

  // Category filter (only if not "all")
  if (filters.category && filters.category !== "all") {
    constraints.push(where("categories", "array-contains", filters.category))
  }

  // Source filter
  if (filters.sourceIds && filters.sourceIds.length > 0 && filters.sourceIds.length <= 10) {
    constraints.push(where("sourceId", "in", filters.sourceIds))
  }

  // Order by publishedAt desc
  constraints.push(orderBy("publishedAt", "desc"))

  // Pagination
  if (pageParam) {
    constraints.push(startAfter(pageParam))
  }

  // Limit
  constraints.push(limit(ARTICLES_PER_PAGE))

  const q = query(articlesRef, ...constraints)
  const snapshot = await getDocs(q)

  const articles = snapshot.docs.map(docToArticle)
  const lastDoc = snapshot.docs[snapshot.docs.length - 1] || null

  return {
    articles,
    lastDoc,
    hasMore: snapshot.docs.length === ARTICLES_PER_PAGE,
  }
}

/**
 * Hook for infinite scroll articles list
 */
export function useArticles(filters: ArticleFilters = {}) {
  return useInfiniteQuery({
    queryKey: ["articles", filters],
    queryFn: ({ pageParam }) => fetchArticles({ filters, pageParam }),
    initialPageParam: null as QueryDocumentSnapshot<DocumentData> | null,
    getNextPageParam: (lastPage) => (lastPage.hasMore ? lastPage.lastDoc : undefined),
    staleTime: 1000 * 60 * 2, // 2 minutes
    gcTime: 1000 * 60 * 10, // 10 minutes
  })
}

// Maximum sources to fetch (prevents runaway reads if sources grow)
const MAX_SOURCES = 50

/**
 * Hook for fetching available sources for filter (lightweight)
 */
export function useSources() {
  return useQuery({
    queryKey: ["sources"],
    queryFn: async () => {
      const sourcesRef = collection(db, "sources")
      const q = query(sourcesRef, where("enabled", "==", true), orderBy("name"), limit(MAX_SOURCES))
      const snapshot = await getDocs(q)
      return snapshot.docs.map((doc) => ({
        id: doc.id,
        name: doc.data().name as string,
      }))
    },
    staleTime: 1000 * 60 * 30, // 30 minutes
  })
}

/**
 * Hook for fetching all enabled sources with full data (for Sources page)
 */
export function useAllSources() {
  return useQuery({
    queryKey: ["sources", "full"],
    queryFn: async () => {
      const sourcesRef = collection(db, "sources")
      const q = query(sourcesRef, where("enabled", "==", true), orderBy("name"), limit(MAX_SOURCES))
      const snapshot = await getDocs(q)
      return snapshot.docs.map((doc) => {
        const data = doc.data()
        return {
          id: doc.id,
          name: data.name,
          siteUrl: data.siteUrl,
          rssUrl: data.rssUrl,
          enabled: data.enabled,
          tier: data.tier,
          tags: data.tags || [],
          createdAt: data.createdAt,
          updatedAt: data.updatedAt,
          fetchState: data.fetchState,
        } as import("@/types/firestore").Source
      })
    },
    staleTime: 1000 * 60 * 30, // 30 minutes
  })
}



=================================================================================
FILE: src/lib/hooks/use-bookmarks.ts
=================================================================================

/**
 * Hooks for bookmark management
 */

import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query"
import {
  collection,
  doc,
  getDocs,
  getDoc,
  setDoc,
  deleteDoc,
  orderBy,
  query,
  limit,
  Timestamp,
} from "firebase/firestore"
import { httpsCallable } from "firebase/functions"
import { db, functions } from "@/lib/firebase"
import { useAuth } from "@/lib/auth-context"
import type { Bookmark, Article, ArticleAI } from "@/types/firestore"

// Maximum bookmarks to fetch (most users won't have more than this)
const MAX_BOOKMARKS = 100

// ============================================================================
// Bookmarks Hooks
// ============================================================================

/**
 * Fetch bookmarks for the current user (limited to prevent excessive reads)
 */
export function useBookmarks() {
  const { user, isLoading: authLoading } = useAuth()

  return useQuery({
    queryKey: ["bookmarks", user?.uid],
    queryFn: async () => {
      if (!user) return []

      const bookmarksRef = collection(db, "users", user.uid, "bookmarks")
      const q = query(bookmarksRef, orderBy("bookmarkedAt", "desc"), limit(MAX_BOOKMARKS))
      const snapshot = await getDocs(q)

      return snapshot.docs.map((doc) => ({
        ...doc.data(),
        articleId: doc.id,
      })) as Bookmark[]
    },
    enabled: !authLoading && !!user,
    staleTime: 1000 * 60 * 5, // 5 minutes
  })
}

/**
 * Check if a specific article is bookmarked
 */
export function useIsBookmarked(articleId: string | undefined) {
  const { user, isLoading: authLoading } = useAuth()

  return useQuery({
    queryKey: ["bookmark", user?.uid, articleId],
    queryFn: async () => {
      if (!user || !articleId) return false
      
      const bookmarkRef = doc(db, "users", user.uid, "bookmarks", articleId)
      const snapshot = await getDoc(bookmarkRef)
      return snapshot.exists()
    },
    enabled: !authLoading && !!user && !!articleId,
    staleTime: 1000 * 60 * 5, // 5 minutes
  })
}

interface ToggleBookmarkParams {
  article: Article
  isCurrentlyBookmarked: boolean
}

/**
 * Toggle bookmark status for an article
 */
export function useToggleBookmark() {
  const { user } = useAuth()
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: async ({ article, isCurrentlyBookmarked }: ToggleBookmarkParams) => {
      if (!user) throw new Error("Must be authenticated to bookmark")
      
      const bookmarkRef = doc(db, "users", user.uid, "bookmarks", article.id)
      
      if (isCurrentlyBookmarked) {
        // Remove bookmark
        await deleteDoc(bookmarkRef)
        return { bookmarked: false }
      } else {
        // Add bookmark
        const bookmark: Bookmark = {
          articleId: article.id,
          title: article.title,
          sourceName: article.sourceName,
          url: article.url,
          bookmarkedAt: Timestamp.now(),
        }
        await setDoc(bookmarkRef, bookmark)
        return { bookmarked: true }
      }
    },
    onSuccess: (_, { article }) => {
      // Invalidate bookmark queries
      queryClient.invalidateQueries({ queryKey: ["bookmarks", user?.uid] })
      queryClient.invalidateQueries({ queryKey: ["bookmark", user?.uid, article.id] })
    },
  })
}

// ============================================================================
// Article AI Hook
// ============================================================================

interface ArticleAIResponse {
  cached: boolean
  ai: ArticleAI & { generatedAt: string }
  remaining: number
}

/**
 * Generate or retrieve AI summary for an article
 */
export function useArticleAI() {
  const { user } = useAuth()
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: async (articleId: string): Promise<ArticleAIResponse> => {
      if (!user) throw new Error("Must be authenticated to generate AI summary")
      
      const getOrCreateArticleAI = httpsCallable<{ articleId: string }, ArticleAIResponse>(
        functions,
        "getOrCreateArticleAI"
      )
      
      const result = await getOrCreateArticleAI({ articleId })
      return result.data
    },
    onSuccess: (data, articleId) => {
      // Update article cache with AI data
      queryClient.invalidateQueries({ queryKey: ["articles"] })
      // Cache the AI response
      queryClient.setQueryData(["articleAI", articleId], data)
    },
  })
}

/**
 * Get cached AI data for an article
 */
export function useCachedArticleAI(articleId: string | undefined) {
  return useQuery<ArticleAIResponse | null>({
    queryKey: ["articleAI", articleId],
    queryFn: () => null, // Only used for cached data
    enabled: false,
    staleTime: Infinity,
  })
}



=================================================================================
FILE: src/lib/hooks/use-chat-threads.ts
=================================================================================

/**
 * Hooks for chat thread persistence (optional)
 * 
 * Chat threads are stored in users/{uid}/chatThreads/{threadId}
 * Messages are stored in users/{uid}/chatThreads/{threadId}/messages/{messageId}
 */

import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query"
import {
  collection,
  doc,
  getDocs,
  addDoc,
  updateDoc,
  deleteDoc,
  orderBy,
  query,
  limit,
  Timestamp,
  serverTimestamp,
} from "firebase/firestore"
import { db } from "@/lib/firebase"
import { useAuth } from "@/lib/auth-context"
import type {
  ChatThread,
  ChatMessage,
  ChatTimeScope,
  ChatSourceFilter,
  ChatCategory,
  ChatCitation,
} from "@/types/firestore"

// Maximum threads to fetch
const MAX_THREADS = 20

// ============================================================================
// Types for hook inputs
// ============================================================================

export interface CreateThreadInput {
  title: string
  scope: ChatTimeScope
  sourceFilter: ChatSourceFilter
  category: ChatCategory
}

export interface AppendMessageInput {
  threadId: string
  role: "user" | "assistant"
  content: string
  citations?: ChatCitation[]
}

// ============================================================================
// Hooks
// ============================================================================

/**
 * Fetch recent chat threads for the current user
 */
export function useChatThreads() {
  const { user } = useAuth()

  return useQuery({
    queryKey: ["chatThreads", user?.uid],
    queryFn: async (): Promise<ChatThread[]> => {
      if (!user) return []

      const threadsRef = collection(db, "users", user.uid, "chatThreads")
      const q = query(threadsRef, orderBy("updatedAt", "desc"), limit(MAX_THREADS))
      const snapshot = await getDocs(q)

      return snapshot.docs.map((doc) => ({
        id: doc.id,
        ...doc.data(),
      })) as ChatThread[]
    },
    enabled: !!user,
    staleTime: 1000 * 60 * 5, // 5 minutes
  })
}

/**
 * Create a new chat thread
 */
export function useCreateThread() {
  const { user } = useAuth()
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: async (input: CreateThreadInput): Promise<string> => {
      if (!user) throw new Error("Must be authenticated to create thread")

      const threadsRef = collection(db, "users", user.uid, "chatThreads")
      const now = Timestamp.now()

      const docRef = await addDoc(threadsRef, {
        title: input.title,
        createdAt: now,
        updatedAt: now,
        scope: input.scope,
        sourceFilter: input.sourceFilter,
        category: input.category,
      })

      return docRef.id
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["chatThreads", user?.uid] })
    },
  })
}

/**
 * Append a message to a chat thread
 */
export function useAppendMessage() {
  const { user } = useAuth()
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: async (input: AppendMessageInput): Promise<string> => {
      if (!user) throw new Error("Must be authenticated to append message")

      const messagesRef = collection(
        db,
        "users",
        user.uid,
        "chatThreads",
        input.threadId,
        "messages"
      )

      // Add the message
      const docRef = await addDoc(messagesRef, {
        role: input.role,
        content: input.content,
        createdAt: Timestamp.now(),
        ...(input.citations && { citations: input.citations }),
      })

      // Update thread's updatedAt
      const threadRef = doc(db, "users", user.uid, "chatThreads", input.threadId)
      await updateDoc(threadRef, {
        updatedAt: serverTimestamp(),
      })

      return docRef.id
    },
    onSuccess: (_, input) => {
      queryClient.invalidateQueries({ queryKey: ["chatThreads", user?.uid] })
      queryClient.invalidateQueries({ queryKey: ["chatMessages", input.threadId] })
    },
  })
}

/**
 * Fetch messages for a specific thread
 */
export function useChatMessages(threadId: string | null) {
  const { user } = useAuth()

  return useQuery({
    queryKey: ["chatMessages", threadId],
    queryFn: async (): Promise<ChatMessage[]> => {
      if (!user || !threadId) return []

      const messagesRef = collection(
        db,
        "users",
        user.uid,
        "chatThreads",
        threadId,
        "messages"
      )
      const q = query(messagesRef, orderBy("createdAt", "asc"))
      const snapshot = await getDocs(q)

      return snapshot.docs.map((doc) => ({
        id: doc.id,
        ...doc.data(),
      })) as ChatMessage[]
    },
    enabled: !!user && !!threadId,
    staleTime: 1000 * 60, // 1 minute
  })
}

/**
 * Delete a chat thread and all its messages
 */
export function useDeleteThread() {
  const { user } = useAuth()
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: async (threadId: string): Promise<void> => {
      if (!user) throw new Error("Must be authenticated to delete thread")

      // Note: In production, you might want to use a Cloud Function
      // to delete subcollections atomically. For now, we just delete the thread doc.
      // Firestore will orphan the messages subcollection, but they won't be accessible.
      const threadRef = doc(db, "users", user.uid, "chatThreads", threadId)
      await deleteDoc(threadRef)
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["chatThreads", user?.uid] })
    },
  })
}



=================================================================================
FILE: src/lib/hooks/use-large-title.ts
=================================================================================

/**
 * useLargeTitle - Hook for iOS-style large title collapse behavior
 * 
 * Uses IntersectionObserver to track when the large title element
 * scrolls out of view, enabling the collapsed title in TopNav.
 */

import { useRef, useState, useEffect, type RefObject } from "react"

interface UseLargeTitleResult {
  /** Ref to attach to the large title container element */
  titleRef: RefObject<HTMLDivElement | null>
  /** Whether the large title is currently visible */
  isVisible: boolean
}

/**
 * Track large title visibility for iOS-style collapse behavior
 * 
 * @param threshold - Visibility threshold (0-1). Default 0.1 means title is considered
 *                    "not visible" when less than 10% is showing
 * @returns titleRef to attach to large title element, and isVisible state
 */
export function useLargeTitle(threshold = 0.1): UseLargeTitleResult {
  const titleRef = useRef<HTMLDivElement>(null)
  const [isVisible, setIsVisible] = useState(true)

  useEffect(() => {
    const element = titleRef.current
    if (!element) return

    const observer = new IntersectionObserver(
      (entries) => {
        // The title is considered visible if it's intersecting above threshold
        const entry = entries[0]
        if (entry) {
          setIsVisible(entry.isIntersecting)
        }
      },
      {
        // Use the viewport as root
        root: null,
        // Account for sticky header height (52px) + safe area
        // We observe when the title hits the bottom of the header
        rootMargin: "-52px 0px 0px 0px",
        threshold,
      }
    )

    observer.observe(element)

    return () => {
      observer.disconnect()
    }
  }, [threshold])

  return {
    titleRef,
    isVisible,
  }
}

/**
 * Scrollable container variant of useLargeTitle
 * Use when the scrollable element is not the viewport
 */
export function useLargeTitleWithScroll(
  scrollContainerRef: RefObject<HTMLElement | null>,
  threshold = 0.1
): UseLargeTitleResult {
  const titleRef = useRef<HTMLDivElement>(null)
  const [isVisible, setIsVisible] = useState(true)

  useEffect(() => {
    const element = titleRef.current
    const scrollContainer = scrollContainerRef.current
    if (!element || !scrollContainer) return

    const observer = new IntersectionObserver(
      (entries) => {
        const entry = entries[0]
        if (entry) {
          setIsVisible(entry.isIntersecting)
        }
      },
      {
        root: scrollContainer,
        rootMargin: "-52px 0px 0px 0px",
        threshold,
      }
    )

    observer.observe(element)

    return () => {
      observer.disconnect()
    }
  }, [scrollContainerRef, threshold])

  return {
    titleRef,
    isVisible,
  }
}



=================================================================================
FILE: src/lib/hooks/use-push-notifications.ts
=================================================================================

/**
 * Hook for managing push notifications
 */

import { useState, useEffect, useCallback } from "react"
import { useAuth } from "@/lib/auth-context"
import { useUserPreferences } from "@/lib/hooks/use-user-preferences"
import {
  isPushSupported,
  registerPushToken,
  unregisterPush,
} from "@/lib/push-notifications"

interface UsePushNotificationsResult {
  /** Whether push is supported on this platform */
  isSupported: boolean
  /** Whether we're loading the support check */
  isLoading: boolean
  /** Current permission status */
  permissionStatus: NotificationPermission | "unknown"
  /** Whether notifications are enabled in user preferences */
  isEnabled: boolean
  /** Register for push notifications */
  enableNotifications: () => Promise<boolean>
  /** Current push token (if registered) */
  pushToken: string | null
}

export function usePushNotifications(): UsePushNotificationsResult {
  const { user } = useAuth()
  const { data: prefs } = useUserPreferences()

  const [isSupported, setIsSupported] = useState(false)
  const [isLoading, setIsLoading] = useState(true)
  const [permissionStatus, setPermissionStatus] = useState<NotificationPermission | "unknown">("unknown")
  const [pushToken, setPushToken] = useState<string | null>(null)

  // Check support on mount
  useEffect(() => {
    async function checkSupport() {
      const supported = await isPushSupported()
      setIsSupported(supported)
      setIsLoading(false)

      // Check current permission status
      if (supported && "Notification" in window) {
        setPermissionStatus(Notification.permission)
      }
    }
    checkSupport()
  }, [])

  // Auto-register if user has notifications enabled
  useEffect(() => {
    async function autoRegister() {
      if (
        user &&
        isSupported &&
        prefs?.notifications?.dailyBrief &&
        permissionStatus === "granted" &&
        !pushToken
      ) {
        const token = await registerPushToken(user.uid)
        if (token) {
          setPushToken(token)
        }
      }
    }
    autoRegister()
  }, [user, isSupported, prefs?.notifications?.dailyBrief, permissionStatus, pushToken])

  const enableNotifications = useCallback(async (): Promise<boolean> => {
    if (!user || !isSupported) return false

    const token = await registerPushToken(user.uid)
    if (token) {
      setPushToken(token)
      setPermissionStatus("granted")
      return true
    }
    setPermissionStatus("denied")
    return false
  }, [user, isSupported])

  // Cleanup on unmount
  useEffect(() => {
    return () => {
      unregisterPush()
    }
  }, [])

  return {
    isSupported,
    isLoading,
    permissionStatus,
    isEnabled: prefs?.notifications?.dailyBrief ?? true,
    enableNotifications,
    pushToken,
  }
}



=================================================================================
FILE: src/lib/hooks/use-today-brief.ts
=================================================================================

/**
 * Hook for fetching today's brief from Cloud Functions
 *
 * Features:
 * - localStorage caching with 30min TTL for instant display
 * - Falls back to cache while fresh data loads
 */

import { useQuery } from "@tanstack/react-query"
import { httpsCallable } from "firebase/functions"
import { functions } from "@/lib/firebase"
import { getCached, setCache } from "@/lib/cache"
import type { Brief } from "@/types/firestore"

// Article data embedded in top story (may be null if article was deleted)
export interface TopStoryArticle {
  id: string
  title: string
  url: string
  sourceName: string
  sourceId?: string
  publishedAt: string
  snippet: string
  imageUrl: string | null
}

// Response type from getTodayBrief callable
// Note: article can be null if the referenced article was deleted from Firestore
export interface TopStoryWithArticle {
  articleId: string
  headline: string
  whyItMatters: string
  article: TopStoryArticle | null
}

export interface TodayBriefResponse {
  found: boolean
  date: string
  brief: Brief | null
  topStoriesWithArticles: TopStoryWithArticle[]
}

// Cache key for today's brief
const BRIEF_CACHE_KEY = "today_brief"
const BRIEF_CACHE_TTL = 30 * 60 * 1000 // 30 minutes

// Callable function reference
const getTodayBriefCallable = httpsCallable<{ date?: string }, TodayBriefResponse>(
  functions,
  "getTodayBrief"
)

/**
 * Fetch today's brief (or a specific date's brief)
 * Updates localStorage cache on success
 */
async function fetchTodayBrief(date?: string): Promise<TodayBriefResponse> {
  const result = await getTodayBriefCallable({ date })
  const data = result.data

  // Cache the response (only for "today" queries)
  if (!date && data.found) {
    setCache(BRIEF_CACHE_KEY, data, BRIEF_CACHE_TTL)
  }

  return data
}

/**
 * Hook to fetch today's brief with TanStack Query
 *
 * Uses localStorage cache for instant initial display, then fetches fresh data.
 *
 * @param date - Optional date in yyyy-mm-dd format (defaults to today ET)
 */
export function useTodayBrief(date?: string) {
  // Get cached data for initial display (only for "today")
  const cachedData = !date ? getCached<TodayBriefResponse>(BRIEF_CACHE_KEY) : null

  return useQuery({
    queryKey: ["brief", date ?? "today"],
    queryFn: () => fetchTodayBrief(date),
    staleTime: 1000 * 60 * 5, // 5 minutes
    gcTime: 1000 * 60 * 30, // 30 minutes
    // Use cached data as placeholder while fetching
    placeholderData: cachedData ?? undefined,
  })
}



=================================================================================
FILE: src/lib/hooks/use-user-preferences.ts
=================================================================================

/**
 * Hook for managing user preferences (source toggles, etc.)
 */

import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query"
import {
  doc,
  getDoc,
  setDoc,
  updateDoc,
  serverTimestamp,
} from "firebase/firestore"
import { db } from "@/lib/firebase"
import { useAuth } from "@/lib/auth-context"
import type { UserPreferences } from "@/types/firestore"

// Default preferences for new users
const DEFAULT_PREFERENCES: Omit<UserPreferences, "updatedAt"> = {
  enabledSourceIds: [], // Empty means "all sources"
  enabledCategories: [
    "property_cat",
    "casualty_liability",
    "regulation",
    "claims",
    "reinsurance",
    "insurtech",
  ],
  notifications: {
    dailyBrief: true,
    breakingNews: false,
  },
}

/**
 * Fetch user preferences from Firestore
 */
async function fetchUserPreferences(uid: string): Promise<UserPreferences | null> {
  const prefsRef = doc(db, "users", uid, "prefs", "main")
  const snapshot = await getDoc(prefsRef)

  if (!snapshot.exists()) {
    return null
  }

  return snapshot.data() as UserPreferences
}

/**
 * Hook to get user preferences
 */
export function useUserPreferences() {
  const { user, isLoading: authLoading } = useAuth()

  return useQuery({
    queryKey: ["userPreferences", user?.uid],
    queryFn: () => fetchUserPreferences(user!.uid),
    enabled: !!user && !authLoading,
    staleTime: 1000 * 60 * 5, // 5 minutes
  })
}

/**
 * Hook to toggle a source in user preferences
 */
export function useToggleSource() {
  const { user } = useAuth()
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: async ({
      sourceId,
      enabled,
      currentEnabledIds,
    }: {
      sourceId: string
      enabled: boolean
      currentEnabledIds: string[]
    }) => {
      if (!user) throw new Error("Not authenticated")

      const prefsRef = doc(db, "users", user.uid, "prefs", "main")
      const prefsDoc = await getDoc(prefsRef)

      let newEnabledIds: string[]

      if (enabled) {
        // Add source to enabled list
        newEnabledIds = [...currentEnabledIds, sourceId]
      } else {
        // Remove source from enabled list
        newEnabledIds = currentEnabledIds.filter((id) => id !== sourceId)
      }

      if (prefsDoc.exists()) {
        // Update existing preferences
        await updateDoc(prefsRef, {
          enabledSourceIds: newEnabledIds,
          updatedAt: serverTimestamp(),
        })
      } else {
        // Create new preferences document
        await setDoc(prefsRef, {
          ...DEFAULT_PREFERENCES,
          enabledSourceIds: newEnabledIds,
          updatedAt: serverTimestamp(),
        })
      }

      return newEnabledIds
    },
    onSuccess: () => {
      // Invalidate preferences query to refetch
      queryClient.invalidateQueries({ queryKey: ["userPreferences", user?.uid] })
    },
  })
}

/**
 * Hook to reset all source preferences (follow all)
 */
export function useResetSourcePreferences() {
  const { user } = useAuth()
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: async () => {
      if (!user) throw new Error("Not authenticated")

      const prefsRef = doc(db, "users", user.uid, "prefs", "main")
      const prefsDoc = await getDoc(prefsRef)

      if (prefsDoc.exists()) {
        await updateDoc(prefsRef, {
          enabledSourceIds: [],
          updatedAt: serverTimestamp(),
        })
      } else {
        await setDoc(prefsRef, {
          ...DEFAULT_PREFERENCES,
          enabledSourceIds: [],
          updatedAt: serverTimestamp(),
        })
      }
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["userPreferences", user?.uid] })
    },
  })
}

/**
 * Hook to toggle notification preferences
 */
export function useToggleNotifications() {
  const { user } = useAuth()
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: async ({
      dailyBrief,
    }: {
      dailyBrief: boolean
    }) => {
      if (!user) throw new Error("Not authenticated")

      const prefsRef = doc(db, "users", user.uid, "prefs", "main")
      const prefsDoc = await getDoc(prefsRef)

      if (prefsDoc.exists()) {
        await updateDoc(prefsRef, {
          "notifications.dailyBrief": dailyBrief,
          updatedAt: serverTimestamp(),
        })
      } else {
        await setDoc(prefsRef, {
          ...DEFAULT_PREFERENCES,
          notifications: {
            ...DEFAULT_PREFERENCES.notifications,
            dailyBrief,
          },
          updatedAt: serverTimestamp(),
        })
      }
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["userPreferences", user?.uid] })
    },
  })
}



=================================================================================
FILE: src/lib/push-notifications.ts
=================================================================================

/**
 * Push Notifications Service
 *
 * Handles FCM registration for both web (Firebase Messaging) and iOS (Capacitor Push Notifications).
 * Stores device tokens under users/{uid}/pushTokens/{token}
 */

import { Capacitor } from "@capacitor/core"
import { PushNotifications, type Token } from "@capacitor/push-notifications"
import { getMessaging, getToken, onMessage, isSupported } from "firebase/messaging"
import { doc, setDoc, deleteDoc, serverTimestamp, Timestamp } from "firebase/firestore"
import { app, db } from "@/lib/firebase"

// VAPID key for web push (you need to generate this in Firebase Console > Cloud Messaging)
const VAPID_KEY = import.meta.env.VITE_FIREBASE_VAPID_KEY || ""

export interface PushToken {
  token: string
  platform: "ios" | "web"
  createdAt: Timestamp
  updatedAt: Timestamp
}

/**
 * Check if push notifications are supported on the current platform
 */
export async function isPushSupported(): Promise<boolean> {
  if (Capacitor.isNativePlatform()) {
    return true // iOS native always supports push
  }
  // Check web push support - requires VAPID key to be configured
  if (!VAPID_KEY) {
    return false
  }
  return await isSupported()
}

/**
 * Request push notification permission
 */
export async function requestPushPermission(): Promise<"granted" | "denied" | "default"> {
  if (Capacitor.isNativePlatform()) {
    const result = await PushNotifications.requestPermissions()
    return result.receive === "granted" ? "granted" : "denied"
  }

  // Web permission
  const permission = await Notification.requestPermission()
  return permission
}

/**
 * Register for push notifications and store the token
 */
export async function registerPushToken(uid: string): Promise<string | null> {
  try {
    const permission = await requestPushPermission()
    if (permission !== "granted") {
      console.log("[Push] Permission not granted")
      return null
    }

    if (Capacitor.isNativePlatform()) {
      return await registerNativePush(uid)
    } else {
      return await registerWebPush(uid)
    }
  } catch (error) {
    console.error("[Push] Failed to register:", error)
    return null
  }
}

/**
 * Register native (iOS) push notifications via Capacitor
 */
async function registerNativePush(uid: string): Promise<string | null> {
  return new Promise((resolve) => {
    // Listen for registration success
    PushNotifications.addListener("registration", async (token: Token) => {
      console.log("[Push] iOS token received:", token.value)
      await storePushToken(uid, token.value, "ios")
      resolve(token.value)
    })

    // Listen for registration errors
    PushNotifications.addListener("registrationError", (error) => {
      console.error("[Push] iOS registration error:", error)
      resolve(null)
    })

    // Register with APNS
    PushNotifications.register()
  })
}

/**
 * Register web push notifications via Firebase Messaging
 */
async function registerWebPush(uid: string): Promise<string | null> {
  // Skip web push if VAPID key is not configured
  if (!VAPID_KEY) {
    console.log("[Push] Web push skipped - VAPID key not configured (set VITE_FIREBASE_VAPID_KEY)")
    return null
  }

  try {
    const messaging = getMessaging(app)
    const token = await getToken(messaging, { vapidKey: VAPID_KEY })

    if (token) {
      console.log("[Push] Web token received:", token.substring(0, 20) + "...")
      await storePushToken(uid, token, "web")

      // Listen for foreground messages
      onMessage(messaging, (payload) => {
        console.log("[Push] Foreground message:", payload)
        // Show notification manually for foreground
        if (payload.notification) {
          new Notification(payload.notification.title || "P&C Brief", {
            body: payload.notification.body,
            icon: "/pwa-192x192.png",
          })
        }
      })

      return token
    }
    return null
  } catch (error) {
    console.error("[Push] Web registration error:", error)
    return null
  }
}

/**
 * Store push token in Firestore
 */
async function storePushToken(
  uid: string,
  token: string,
  platform: "ios" | "web"
): Promise<void> {
  const tokenRef = doc(db, "users", uid, "pushTokens", token)
  await setDoc(tokenRef, {
    token,
    platform,
    createdAt: serverTimestamp(),
    updatedAt: serverTimestamp(),
  })
  console.log(`[Push] Token stored for ${platform}`)
}

/**
 * Remove a push token from Firestore
 */
export async function removePushToken(uid: string, token: string): Promise<void> {
  const tokenRef = doc(db, "users", uid, "pushTokens", token)
  await deleteDoc(tokenRef)
  console.log("[Push] Token removed")
}

/**
 * Unregister from push notifications
 */
export async function unregisterPush(): Promise<void> {
  if (Capacitor.isNativePlatform()) {
    await PushNotifications.removeAllListeners()
  }
}



=================================================================================
FILE: src/lib/query-client.ts
=================================================================================

import { QueryClient } from "@tanstack/react-query"

export const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 1000 * 60 * 5, // 5 minutes
      gcTime: 1000 * 60 * 30, // 30 minutes (formerly cacheTime)
      retry: 1,
      refetchOnWindowFocus: false,
    },
  },
})



=================================================================================
FILE: src/lib/utils.ts
=================================================================================

import { type ClassValue, clsx } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}



=================================================================================
FILE: src/main.tsx
=================================================================================

import { StrictMode } from "react"
import { createRoot } from "react-dom/client"
import "./index.css"
import App from "./App"

createRoot(document.getElementById("root")!).render(
  <StrictMode>
    <App />
  </StrictMode>
)


=================================================================================
FILE: src/pages/AskPage.tsx
=================================================================================

/**
 * Ask AI Page - ChatGPT-style chat interface for querying P&C news
 * Clean, minimal, message-first design with Apple-inspired polish
 * Wired to answerQuestionRag backend endpoint with streaming support
 */

import { useState, useRef, useEffect, useCallback } from "react"
import {
  ArrowUp,
  ExternalLink,
  ChevronDown,
  RotateCcw,
  AlertCircle,
  Check
} from "lucide-react"
import { toast } from "sonner"
import { useMutation, useQuery } from "@tanstack/react-query"
import { httpsCallable } from "firebase/functions"
import { doc, getDoc } from "firebase/firestore"
import { functions, db, auth } from "@/lib/firebase"
import { hapticLight, hapticMedium, hapticSelection } from "@/lib/haptics"
import { cn } from "@/lib/utils"
import { useAuth } from "@/lib/auth-context"
import { useUserPreferences } from "@/lib/hooks"
import { ArticleDetailSheet } from "@/components/feed"
import { Sheet, SheetContent, SheetTitle, SheetDescription } from "@/components/ui/sheet"
import { trackEvent } from "@/lib/analytics"
import type { Article } from "@/types/firestore"

// localStorage cache key for Q/A history
const ASK_CACHE_KEY = "pcbrief_ask_cache"
const MAX_CACHED_MESSAGES = 40 // 20 Q/A pairs = 40 messages

// Streaming endpoint URL (Firebase Functions v2)
const STREAMING_ENDPOINT =
  import.meta.env.DEV && import.meta.env.VITE_FIREBASE_USE_EMULATOR === "true"
    ? "http://localhost:5001/insurance-news-ai/us-central1/answerQuestionRagStream"
    : "https://us-central1-insurance-news-ai.cloudfunctions.net/answerQuestionRagStream"

// Types matching backend RAG response
type RagScope = "today" | "7d" | "30d"

interface RagCitation {
  articleId: string
  title: string
  sourceName: string
  url: string
  publishedAt: string
}

interface RagAnswerResponse {
  answerMarkdown: string
  takeaways: string[]
  citations: RagCitation[]
  followUps: string[]
  remaining: number
}

interface Message {
  id: string
  role: "user" | "assistant"
  content: string
  citations?: RagCitation[]
  takeaways?: string[]
  followUps?: string[]
  error?: boolean
}

type SourceFilterMode = "my-sources" | "all-sources"

// Scope labels for display
const scopeLabels: Record<RagScope, string> = {
  today: "Today",
  "7d": "7 Days",
  "30d": "30 Days",
}

// Cycle through scopes
const scopeOrder: RagScope[] = ["today", "7d", "30d"]

export function AskPage() {
  const { isAuthenticated } = useAuth()
  const { data: userPrefs } = useUserPreferences()

  // Chat state
  const [messages, setMessages] = useState<Message[]>([])
  const [inputValue, setInputValue] = useState("")
  const messagesEndRef = useRef<HTMLDivElement>(null)
  const inputRef = useRef<HTMLTextAreaElement>(null)

  // Scope & source filter state
  const [scope, setScope] = useState<RagScope>("7d")
  const [sourceFilterMode, setSourceFilterMode] = useState<SourceFilterMode>("my-sources")
  const [sourceSheetOpen, setSourceSheetOpen] = useState(false)

  // Article detail sheet state
  const [selectedArticleId, setSelectedArticleId] = useState<string | null>(null)
  const [articleSheetOpen, setArticleSheetOpen] = useState(false)

  // Retry state
  const [pendingRetry, setPendingRetry] = useState<string | null>(null)

  // Streaming state
  const [isStreaming, setIsStreaming] = useState(false)
  const abortControllerRef = useRef<AbortController | null>(null)

  // Load cached messages on mount
  useEffect(() => {
    try {
      const cached = localStorage.getItem(ASK_CACHE_KEY)
      if (cached) {
        const parsedMessages = JSON.parse(cached) as Message[]
        if (Array.isArray(parsedMessages) && parsedMessages.length > 0) {
          setMessages(parsedMessages)
        }
      }
    } catch {
      // Ignore cache errors
    }
  }, [])

  // Save messages to cache when they change
  useEffect(() => {
    if (messages.length === 0) return
    try {
      // Keep only the last MAX_CACHED_MESSAGES
      const toCache = messages.slice(-MAX_CACHED_MESSAGES)
      localStorage.setItem(ASK_CACHE_KEY, JSON.stringify(toCache))
    } catch {
      // Ignore cache errors
    }
  }, [messages])

  // Fetch article for detail sheet
  const { data: selectedArticle } = useQuery({
    queryKey: ["article", selectedArticleId],
    queryFn: async () => {
      if (!selectedArticleId) return null
      const articleDoc = await getDoc(doc(db, "articles", selectedArticleId))
      if (!articleDoc.exists()) return null
      return { id: articleDoc.id, ...articleDoc.data() } as Article
    },
    enabled: !!selectedArticleId,
  })

  // RAG mutation
  const ragMutation = useMutation({
    mutationFn: async ({
      question,
      history,
    }: {
      question: string
      history: { role: "user" | "assistant"; content: string }[]
    }) => {
      const answerQuestionRag = httpsCallable<
        {
          question: string
          scope: RagScope
          category: string
          sourceIds: string[] | null
          history: { role: "user" | "assistant"; content: string }[]
        },
        RagAnswerResponse
      >(functions, "answerQuestionRag")

      // Determine source IDs
      const sourceIds =
        sourceFilterMode === "my-sources" &&
        userPrefs?.enabledSourceIds &&
        userPrefs.enabledSourceIds.length > 0
          ? userPrefs.enabledSourceIds
          : null

      const result = await answerQuestionRag({
        question,
        scope,
        category: "all",
        sourceIds,
        history,
      })
      return result.data
    },
  })

  // Auto-scroll to bottom on new messages
  useEffect(() => {
    messagesEndRef.current?.scrollIntoView({ behavior: "smooth" })
  }, [messages])

  // Auto-resize textarea
  useEffect(() => {
    if (inputRef.current) {
      inputRef.current.style.height = "auto"
      inputRef.current.style.height = Math.min(inputRef.current.scrollHeight, 120) + "px"
    }
  }, [inputValue])

  // Cycle scope with haptic
  const handleCycleScope = useCallback(() => {
    hapticSelection()
    setScope((prev) => {
      const idx = scopeOrder.indexOf(prev)
      return scopeOrder[(idx + 1) % scopeOrder.length]
    })
  }, [])

  // Stream response from SSE endpoint
  const streamResponse = useCallback(
    async (
      question: string,
      history: { role: "user" | "assistant"; content: string }[],
      assistantMessageId: string
    ): Promise<boolean> => {
      // Get auth token
      const token = await auth.currentUser?.getIdToken()
      if (!token) {
        throw new Error("Not authenticated")
      }

      // Determine source IDs
      const sourceIds =
        sourceFilterMode === "my-sources" &&
        userPrefs?.enabledSourceIds &&
        userPrefs.enabledSourceIds.length > 0
          ? userPrefs.enabledSourceIds
          : null

      // Create abort controller for cleanup
      const abortController = new AbortController()
      abortControllerRef.current = abortController

      const response = await fetch(STREAMING_ENDPOINT, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${token}`,
        },
        body: JSON.stringify({
          question,
          scope,
          category: "all",
          sourceIds,
          history,
        }),
        signal: abortController.signal,
      })

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}))
        throw new Error(errorData.error || `HTTP ${response.status}`)
      }

      const reader = response.body?.getReader()
      if (!reader) {
        throw new Error("No response body")
      }

      const decoder = new TextDecoder()
      let buffer = ""

      // eslint-disable-next-line no-constant-condition
      while (true) {
        const { done, value } = await reader.read()
        if (done) break

        buffer += decoder.decode(value, { stream: true })
        const lines = buffer.split("\n")
        buffer = lines.pop() || ""

        for (const line of lines) {
          if (line.startsWith("event: done")) {
            // Next line will be the done data
            continue
          }
          if (line.startsWith("data: ")) {
            const dataStr = line.slice(6)
            if (!dataStr) continue

            try {
              const data = JSON.parse(dataStr)

              // Check if this is the done event payload
              if (data.citations !== undefined) {
                // Final done event with metadata
                setMessages((prev) =>
                  prev.map((msg) =>
                    msg.id === assistantMessageId
                      ? {
                          ...msg,
                          content: data.answerMarkdown || msg.content,
                          citations: data.citations,
                          takeaways: data.takeaways,
                          followUps: data.followUps,
                        }
                      : msg
                  )
                )
                hapticLight()
              } else if (data.text !== undefined) {
                // Streaming text chunk
                setMessages((prev) =>
                  prev.map((msg) =>
                    msg.id === assistantMessageId
                      ? { ...msg, content: msg.content + data.text }
                      : msg
                  )
                )
              }
            } catch {
              // Ignore parse errors for malformed chunks
            }
          }
        }
      }

      return true
    },
    [scope, sourceFilterMode, userPrefs]
  )

  // Fallback to non-streaming mutation
  const fallbackToNonStreaming = useCallback(
    async (
      question: string,
      history: { role: "user" | "assistant"; content: string }[],
      assistantMessageId: string
    ) => {
      const response = await ragMutation.mutateAsync({ question, history })

      setMessages((prev) =>
        prev.map((msg) =>
          msg.id === assistantMessageId
            ? {
                ...msg,
                content: response.answerMarkdown,
                citations: response.citations,
                takeaways: response.takeaways,
                followUps: response.followUps,
              }
            : msg
        )
      )
    },
    [ragMutation]
  )

  // Handle send - tries streaming first, falls back to non-streaming
  const handleSend = useCallback(
    async (overrideQuestion?: string) => {
      const question = overrideQuestion ?? inputValue.trim()
      if (!question || isStreaming || ragMutation.isPending) return

      if (!isAuthenticated) {
        toast.error("Sign in to ask questions")
        return
      }

      hapticMedium()

      // Create user message
      const userMessage: Message = {
        id: Date.now().toString(),
        role: "user",
        content: question,
      }

      // Create placeholder assistant message for streaming
      const assistantMessageId = (Date.now() + 1).toString()
      const assistantMessage: Message = {
        id: assistantMessageId,
        role: "assistant",
        content: "",
      }

      setMessages((prev) => [...prev, userMessage, assistantMessage])
      if (!overrideQuestion) setInputValue("")
      setPendingRetry(null)
      setIsStreaming(true)

      // Track ask_sent
      const startTime = Date.now()
      trackEvent("ask_sent", { scope, source_filter: sourceFilterMode })

      // Build history from last 8 messages
      const history = messages
        .slice(-8)
        .map((m) => ({ role: m.role, content: m.content }))

      try {
        // Try streaming first
        const success = await streamResponse(question, history, assistantMessageId)

        // Track ask_answered on success
        if (success) {
          // Get the final message to check citations
          setMessages((prev) => {
            const finalMsg = prev.find((m) => m.id === assistantMessageId)
            const citationCount = finalMsg?.citations?.length || 0
            trackEvent("ask_answered", {
              scope,
              source_filter: sourceFilterMode,
              source_count: citationCount,
              has_citations: citationCount > 0,
              response_time_ms: Date.now() - startTime,
            })
            // Track no coverage if no citations
            if (citationCount === 0) {
              trackEvent("ask_no_coverage", { scope, source_filter: sourceFilterMode })
            }
            return prev
          })
        }
      } catch (streamError) {
        console.warn("Streaming failed, falling back to non-streaming:", streamError)

        // Reset the assistant message for fallback
        setMessages((prev) =>
          prev.map((msg) =>
            msg.id === assistantMessageId ? { ...msg, content: "" } : msg
          )
        )

        try {
          await fallbackToNonStreaming(question, history, assistantMessageId)
        } catch (fallbackError) {
          console.error("RAG error:", fallbackError)

          // Update the assistant message to show error
          setMessages((prev) =>
            prev.map((msg) =>
              msg.id === assistantMessageId
                ? {
                    ...msg,
                    content: "I couldn't process your question. Please try again.",
                    error: true,
                  }
                : msg
            )
          )
          setPendingRetry(question)
          toast.error("Failed to get response", {
            description: "Tap retry or try a different question",
          })
        }
      } finally {
        setIsStreaming(false)
        abortControllerRef.current = null
      }
    },
    [
      inputValue,
      messages,
      ragMutation,
      isAuthenticated,
      isStreaming,
      streamResponse,
      fallbackToNonStreaming,
    ]
  )

  // Cleanup streaming on unmount
  useEffect(() => {
    return () => {
      abortControllerRef.current?.abort()
    }
  }, [])

  // Handle retry
  const handleRetry = useCallback(() => {
    if (pendingRetry) {
      // Remove the error message
      setMessages((prev) => prev.slice(0, -1))
      handleSend(pendingRetry)
    }
  }, [pendingRetry, handleSend])

  // Handle citation click - open article detail sheet
  const handleCitationClick = useCallback((citation: RagCitation) => {
    hapticLight()
    trackEvent("citation_opened", { article_id: citation.articleId })
    setSelectedArticleId(citation.articleId)
    setArticleSheetOpen(true)
  }, [])

  // Handle follow-up click
  const handleFollowUpClick = useCallback(
    (followUp: string) => {
      hapticLight()
      trackEvent("follow_up_clicked")
      handleSend(followUp)
    },
    [handleSend]
  )

  const handleKeyDown = (e: React.KeyboardEvent) => {
    if (e.key === "Enter" && !e.shiftKey) {
      e.preventDefault()
      handleSend()
    }
  }

  const isEmpty = messages.length === 0
  const isLoading = ragMutation.isPending || isStreaming

  return (
    <div className="flex flex-col flex-1 bg-[#f8f8f8] overflow-hidden">
      {/* Scope Bar - subtle, minimal */}
      <div className="flex items-center gap-[6px] px-[16px] py-[8px] bg-white border-b border-[rgba(0,0,0,0.04)] shrink-0">
        {/* Scope Pill */}
        <button
          onClick={handleCycleScope}
          aria-label={`Time range: ${scopeLabels[scope]}. Tap to change.`}
          className="inline-flex items-center gap-[4px] rounded-full bg-[#f5f5f7] px-[10px] py-[5px] text-[12px] font-medium text-[#1a1a1a] transition-all active:scale-[0.97] min-h-[32px]"
        >
          <span>{scopeLabels[scope]}</span>
          <ChevronDown className="h-[10px] w-[10px] text-[#86868b]" />
        </button>

        {/* Sources Pill */}
        <button
          onClick={() => {
            hapticLight()
            setSourceSheetOpen(true)
          }}
          aria-label={`Sources: ${sourceFilterMode === "my-sources" ? "My Sources" : "All Sources"}. Tap to change.`}
          className="inline-flex items-center gap-[4px] rounded-full bg-[#f5f5f7] px-[10px] py-[5px] text-[12px] font-medium text-[#1a1a1a] transition-all active:scale-[0.97] min-h-[32px]"
        >
          <span>{sourceFilterMode === "my-sources" ? "My Sources" : "All Sources"}</span>
          <ChevronDown className="h-[10px] w-[10px] text-[#86868b]" />
        </button>
      </div>

      {/* Chat Transcript Area - the primary surface */}
      <div className="flex-1 overflow-y-auto flex flex-col">
        {isEmpty ? (
          <EmptyState />
        ) : (
          <div className="flex-1 px-[16px] py-[16px] space-y-[16px]">
            {messages.map((message, index) => {
              // During streaming, the last assistant message might be empty or partial
              const isStreamingMessage =
                isStreaming &&
                index === messages.length - 1 &&
                message.role === "assistant"

              return (
                <ChatMessage
                  key={message.id}
                  message={message}
                  onCitationClick={handleCitationClick}
                  onFollowUpClick={handleFollowUpClick}
                  onRetry={message.error ? handleRetry : undefined}
                  isStreaming={isStreamingMessage}
                />
              )
            })}
            {/* Only show typing indicator for non-streaming loading (fallback mode) */}
            {isLoading && !isStreaming && <TypingIndicator />}
            <div ref={messagesEndRef} />
          </div>
        )}
      </div>

      {/* Composer - ChatGPT mobile-inspired, sticky at bottom */}
      <div className="glass-nav border-t border-[rgba(0,0,0,0.04)] px-[16px] pb-[max(12px,env(safe-area-inset-bottom))] pt-[10px] shrink-0">
        <div className="relative flex items-end rounded-[24px] bg-[#f4f4f4] border border-transparent">
          <textarea
            ref={inputRef}
            value={inputValue}
            onChange={(e) => setInputValue(e.target.value)}
            onKeyDown={handleKeyDown}
            placeholder="Ask anything..."
            aria-label="Type your question"
            rows={1}
            className="flex-1 resize-none bg-transparent pl-[18px] pr-[52px] py-[14px] text-[16px] leading-[1.5] text-[#1a1a1a] placeholder:text-[#8e8e93] focus:outline-none focus:ring-0 border-none outline-none"
            style={{ maxHeight: 100 }}
          />
          <button
            onClick={() => handleSend()}
            disabled={!inputValue.trim() || isLoading}
            aria-label="Send message"
            className={cn(
              "absolute right-[8px] bottom-[8px] flex h-[36px] w-[36px] items-center justify-center rounded-full transition-all duration-200",
              inputValue.trim() && !isLoading
                ? "bg-[#1a1a1a] text-white shadow-sm active:scale-[0.95]"
                : "bg-[#e5e5ea] text-[#aeaeb2] cursor-not-allowed"
            )}
          >
            <ArrowUp className="h-[18px] w-[18px]" strokeWidth={2.5} />
          </button>
        </div>
        <p className="mt-[8px] text-center text-[11px] text-[#aeaeb2] leading-[1.4]">
          Grounded in your curated news sources
        </p>
      </div>

      {/* Sources Selection Sheet */}
      <Sheet open={sourceSheetOpen} onOpenChange={setSourceSheetOpen}>
        <SheetContent side="bottom" className="rounded-t-[20px] pb-[calc(24px+env(safe-area-inset-bottom))]">
          <div className="mx-auto mb-4 h-1 w-10 rounded-full bg-[#e5e5ea]" />
          <SheetTitle className="text-[17px] font-semibold text-[#1a1a1a] mb-[16px]">
            Source Filter
          </SheetTitle>
          <SheetDescription className="sr-only">
            Choose which sources to search
          </SheetDescription>
          <div className="space-y-[8px]">
            <button
              onClick={() => {
                hapticLight()
                setSourceFilterMode("my-sources")
                setSourceSheetOpen(false)
              }}
              aria-label="Search my sources only"
              className={cn(
                "w-full flex items-center justify-between rounded-[12px] px-[16px] py-[14px] text-left transition-all min-h-[56px]",
                sourceFilterMode === "my-sources"
                  ? "bg-[#1a1a1a]/5 border border-[#1a1a1a]"
                  : "bg-[#f5f5f7] border border-transparent"
              )}
            >
              <div>
                <div className="text-[15px] font-medium text-[#1a1a1a]">My Sources</div>
                <div className="text-[13px] text-[#86868b]">Search your selected sources only</div>
              </div>
              {sourceFilterMode === "my-sources" && (
                <div className="h-[20px] w-[20px] rounded-full bg-[#1a1a1a] flex items-center justify-center">
                  <Check className="h-[12px] w-[12px] text-white" strokeWidth={3} />
                </div>
              )}
            </button>
            <button
              onClick={() => {
                hapticLight()
                setSourceFilterMode("all-sources")
                setSourceSheetOpen(false)
              }}
              aria-label="Search all available sources"
              className={cn(
                "w-full flex items-center justify-between rounded-[12px] px-[16px] py-[14px] text-left transition-all min-h-[56px]",
                sourceFilterMode === "all-sources"
                  ? "bg-[#1a1a1a]/5 border border-[#1a1a1a]"
                  : "bg-[#f5f5f7] border border-transparent"
              )}
            >
              <div>
                <div className="text-[15px] font-medium text-[#1a1a1a]">All Sources</div>
                <div className="text-[13px] text-[#86868b]">Search all available sources</div>
              </div>
              {sourceFilterMode === "all-sources" && (
                <div className="h-[20px] w-[20px] rounded-full bg-[#1a1a1a] flex items-center justify-center">
                  <Check className="h-[12px] w-[12px] text-white" strokeWidth={3} />
                </div>
              )}
            </button>
          </div>
        </SheetContent>
      </Sheet>

      {/* Article Detail Sheet */}
      <ArticleDetailSheet
        article={selectedArticle ?? null}
        open={articleSheetOpen}
        onOpenChange={setArticleSheetOpen}
      />
    </div>
  )
}

// Sub-components

function EmptyState() {
  return (
    <div className="flex-1 flex flex-col items-center justify-center px-[20px] pb-[20px]">
      {/* Minimal headline */}
      <p className="text-[17px] font-semibold text-[#1a1a1a] mb-[4px] text-center tracking-[-0.02em]">
        Ask about P&C insurance news
      </p>
      <p className="text-[13px] text-[#86868b] text-center leading-[1.4]">
        Answers include citations to your curated sources.
      </p>
    </div>
  )
}

// Format response text with proper structure (headers, numbered lists, paragraphs)
function FormattedResponse({ content }: { content: string }) {
  if (!content) return null

  // Split content into paragraphs
  const paragraphs = content.split(/\n\n+/)

  return (
    <div className="space-y-4">
      {paragraphs.map((paragraph, pIdx) => {
        const trimmed = paragraph.trim()
        if (!trimmed) return null

        // Check for numbered list items with bold headers (e.g., "1. **Header**:")
        const numberedHeaderMatch = trimmed.match(/^(\d+)\.\s*\*\*(.+?)\*\*:?\s*(.*)$/s)
        if (numberedHeaderMatch) {
          const [, num, header, rest] = numberedHeaderMatch
          return (
            <div key={pIdx} className="space-y-1">
              <p className="font-semibold text-[#1a1a1a]">
                {num}. {header}
              </p>
              {rest && <p className="text-[#3c3c43]">{rest.trim()}</p>}
            </div>
          )
        }

        // Check for bold text patterns and render inline
        if (trimmed.includes("**")) {
          const parts = trimmed.split(/(\*\*[^*]+\*\*)/g)
          return (
            <p key={pIdx}>
              {parts.map((part, i) => {
                if (part.startsWith("**") && part.endsWith("**")) {
                  return <strong key={i} className="font-semibold">{part.slice(2, -2)}</strong>
                }
                return <span key={i}>{part}</span>
              })}
            </p>
          )
        }

        // Check for citation references like [1], [2], etc.
        if (/\[\d+\]/.test(trimmed)) {
          const parts = trimmed.split(/(\[\d+\])/g)
          return (
            <p key={pIdx}>
              {parts.map((part, i) => {
                if (/^\[\d+\]$/.test(part)) {
                  return (
                    <span key={i} className="text-[#007AFF] text-[13px] font-medium">
                      {part}
                    </span>
                  )
                }
                return <span key={i}>{part}</span>
              })}
            </p>
          )
        }

        // Regular paragraph
        return <p key={pIdx}>{trimmed}</p>
      })}
    </div>
  )
}

interface ChatMessageProps {
  message: Message
  onCitationClick: (c: RagCitation) => void
  onFollowUpClick?: (followUp: string) => void
  onRetry?: () => void
  isStreaming?: boolean
}

function ChatMessage({ message, onCitationClick, onFollowUpClick, onRetry, isStreaming }: ChatMessageProps) {
  const isUser = message.role === "user"

  // User message - black background, white text, right aligned (ChatGPT style)
  if (isUser) {
    return (
      <div className="flex justify-end">
        <div className="max-w-[85%] rounded-[20px] bg-[#1a1a1a] px-[16px] py-[12px]">
          <p className="text-[15px] leading-[1.5] text-white whitespace-pre-wrap">
            {message.content}
          </p>
        </div>
      </div>
    )
  }

  // Error state
  if (message.error) {
    return (
      <div className="flex justify-start">
        <div className="max-w-[90%]">
          <div className="rounded-[20px] bg-white border border-[#FF3B30]/20 px-[16px] py-[12px]">
            <div className="flex items-start gap-[10px]">
              <AlertCircle className="h-[16px] w-[16px] text-[#FF3B30] shrink-0 mt-[2px]" />
              <div className="flex-1">
                <p className="text-[15px] leading-[1.5] text-[#1a1a1a] mb-[10px]">
                  {message.content}
                </p>
                {onRetry && (
                  <button
                    onClick={onRetry}
                    aria-label="Retry sending message"
                    className="inline-flex items-center gap-[6px] rounded-full bg-[#f5f5f7] px-[12px] py-[6px] text-[13px] font-medium text-[#1a1a1a] transition-all active:scale-[0.97] min-h-[44px]"
                  >
                    <RotateCcw className="h-[12px] w-[12px]" />
                    <span>Retry</span>
                  </button>
                )}
              </div>
            </div>
          </div>
        </div>
      </div>
    )
  }

  // Assistant message - clean ChatGPT-style formatting without bubble
  return (
    <div className="flex justify-start w-full">
      <div className="w-full">
        {/* Answer - clean text without bubble, ChatGPT style */}
        <div className="text-[15px] leading-[1.7] text-[#1a1a1a]">
          <FormattedResponse content={message.content || (isStreaming ? "" : "...")} />
          {isStreaming && (
            <span className="inline-block w-[2px] h-[1em] bg-[#1a1a1a] ml-[2px] align-middle animate-pulse" />
          )}
        </div>

        {/* Source count badge - only show after streaming with citations */}
        {!isStreaming && message.citations && message.citations.length > 0 && (
          <p className="mt-[16px] text-[13px] text-[#8e8e93]">
            Based on {message.citations.length} source{message.citations.length !== 1 ? "s" : ""}
          </p>
        )}

        {/* Citations - horizontal row of compact chips */}
        {!isStreaming && message.citations && message.citations.length > 0 && (
          <div className="mt-[12px] flex flex-wrap gap-[8px]">
            {message.citations.map((citation) => (
              <CitationChip key={citation.articleId} citation={citation} onClick={onCitationClick} />
            ))}
          </div>
        )}

        {/* Follow-up questions - only show when not streaming */}
        {!isStreaming && message.followUps && message.followUps.length > 0 && onFollowUpClick && (
          <div className="mt-[16px] flex flex-wrap gap-[8px]">
            {message.followUps.map((followUp, idx) => (
              <button
                key={idx}
                onClick={() => onFollowUpClick(followUp)}
                aria-label={`Ask follow-up: ${followUp}`}
                className="inline-flex items-center rounded-full border border-[#e5e5ea] bg-white px-[14px] py-[8px] text-[13px] text-[#1a1a1a] transition-all hover:bg-[#f5f5f7] active:scale-[0.97] min-h-[44px]"
              >
                {followUp}
              </button>
            ))}
          </div>
        )}
      </div>
    </div>
  )
}

function CitationChip({ citation, onClick }: { citation: RagCitation; onClick: (c: RagCitation) => void }) {
  // Format date for display
  const formatDate = (dateStr: string) => {
    try {
      const date = new Date(dateStr)
      const now = new Date()
      const diffMs = now.getTime() - date.getTime()
      const diffHours = Math.floor(diffMs / (1000 * 60 * 60))
      const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24))

      if (diffHours < 1) return "Just now"
      if (diffHours < 24) return `${diffHours}h ago`
      if (diffDays === 1) return "Yesterday"
      if (diffDays < 7) return `${diffDays}d ago`
      return date.toLocaleDateString("en-US", { month: "short", day: "numeric" })
    } catch {
      return ""
    }
  }

  return (
    <button
      onClick={() => onClick(citation)}
      aria-label={`View article from ${citation.sourceName}`}
      className="inline-flex items-center gap-[5px] rounded-full bg-[#f5f5f7] px-[10px] py-[5px] text-[12px] text-[#1a1a1a] transition-all duration-200 hover:bg-[#eaeaec] active:scale-[0.97] min-h-[32px]"
    >
      <span className="max-w-[100px] truncate font-medium">{citation.sourceName}</span>
      <span className="text-[#aeaeb2]">·</span>
      <span className="text-[#86868b] shrink-0">{formatDate(citation.publishedAt)}</span>
      <ExternalLink className="h-[10px] w-[10px] text-[#86868b] shrink-0" strokeWidth={2} />
    </button>
  )
}

function TypingIndicator() {
  return (
    <div className="flex justify-start">
      <div className="max-w-[90%]">
        <div className="rounded-[20px] bg-white border border-[rgba(0,0,0,0.06)] px-[16px] py-[14px] shadow-[0_1px_2px_rgba(0,0,0,0.02)]">
          <div className="flex gap-[4px]">
            <span className="h-[6px] w-[6px] rounded-full bg-[#c7c7cc] animate-bounce [animation-delay:-0.3s]" />
            <span className="h-[6px] w-[6px] rounded-full bg-[#c7c7cc] animate-bounce [animation-delay:-0.15s]" />
            <span className="h-[6px] w-[6px] rounded-full bg-[#c7c7cc] animate-bounce" />
          </div>
        </div>
      </div>
    </div>
  )
}



=================================================================================
FILE: src/pages/BookmarksPage.tsx
=================================================================================

/**
 * Bookmarks Page - Saved articles list
 */

import { useState } from "react"
import { Bookmark as BookmarkIcon, Loader2 } from "lucide-react"
import { toast } from "sonner"
import { doc, getDoc } from "firebase/firestore"
import { useQuery } from "@tanstack/react-query"
import { Sheet, SheetContent, SheetDescription, SheetTitle } from "@/components/ui/sheet"
import {
  Card,
  Separator,
  SHEET_TOKENS,
  SheetHeaderBlock,
  SheetSection,
  SheetSnippet,
  SheetActions,
  SheetIconButton,
} from "@/components/ui"
import { useBookmarks, useToggleBookmark } from "@/lib/hooks"
import { useAuth } from "@/lib/auth-context"
import { db } from "@/lib/firebase"
import { hapticMedium, hapticSuccess, hapticLight } from "@/lib/haptics"
import type { Bookmark, Article } from "@/types/firestore"

function formatDate(date: Date): string {
  return date.toLocaleDateString("en-US", {
    month: "short",
    day: "numeric",
  })
}

function BookmarkRowSkeleton() {
  return (
    <div className="flex min-h-[68px] items-center gap-[12px] px-[16px] py-[12px]">
      <div className="min-w-0 flex-1">
        <div className="mb-[6px] h-[16px] w-4/5 rounded-[4px] skeleton-shimmer" />
        <div className="h-[13px] w-2/5 rounded-[3px] skeleton-shimmer" />
      </div>
      <div className="h-[36px] w-[36px] shrink-0 rounded-full skeleton-shimmer" />
    </div>
  )
}

interface BookmarkRowProps {
  bookmark: Bookmark
  onSelect: (bookmark: Bookmark) => void
  onRemove: (bookmark: Bookmark) => void
  isRemoving: boolean
}

function BookmarkRow({ bookmark, onSelect, onRemove, isRemoving }: BookmarkRowProps) {
  return (
    <div
      role="button"
      tabIndex={0}
      onClick={() => onSelect(bookmark)}
      onKeyDown={(e) => {
        if (e.key === "Enter" || e.key === " ") {
          e.preventDefault()
          onSelect(bookmark)
        }
      }}
      className="flex w-full min-h-[64px] cursor-pointer items-center gap-[12px] px-[16px] py-[12px] text-left transition-colors duration-[var(--duration-instant)] active:bg-[var(--color-fill-quaternary)]"
    >
      <div className="min-w-0 flex-1">
        <h3 className="line-clamp-2 text-[16px] font-medium leading-[1.32] tracking-[-0.24px] text-[var(--color-text-primary)]">
          {bookmark.title}
        </h3>
        <p className="mt-[5px] text-[13px] tracking-[-0.08px] text-[var(--color-text-tertiary)]">
          <span className="font-medium text-[var(--color-text-secondary)]">{bookmark.sourceName}</span>
          <span className="mx-[5px]">·</span>
          <span>{formatDate(bookmark.bookmarkedAt.toDate())}</span>
        </p>
      </div>
      <button
        className="flex h-[36px] w-[36px] shrink-0 items-center justify-center rounded-full transition-all duration-[var(--duration-fast)] hover:bg-[var(--color-fill-tertiary)] active:scale-[0.88] active:bg-[var(--color-fill-secondary)] disabled:opacity-50"
        onClick={(e) => {
          e.stopPropagation()
          hapticLight()
          onRemove(bookmark)
        }}
        disabled={isRemoving}
      >
        {isRemoving ? (
          <Loader2 className="h-[17px] w-[17px] animate-spin text-[var(--color-accent)]" />
        ) : (
          <BookmarkIcon className="h-[17px] w-[17px] fill-[var(--color-accent)] text-[var(--color-accent)]" />
        )}
      </button>
    </div>
  )
}

export function BookmarksPage() {
  const { isLoading: authLoading } = useAuth()
  const { data: bookmarks, isLoading: bookmarksLoading } = useBookmarks()
  const toggleBookmark = useToggleBookmark()

  const [selectedBookmark, setSelectedBookmark] = useState<Bookmark | null>(null)
  const [sheetOpen, setSheetOpen] = useState(false)
  const [removingId, setRemovingId] = useState<string | null>(null)

  // Fetch full article when bookmark is selected
  const { data: selectedArticle } = useQuery({
    queryKey: ["article", selectedBookmark?.articleId],
    queryFn: async () => {
      if (!selectedBookmark) return null
      const articleDoc = await getDoc(doc(db, "articles", selectedBookmark.articleId))
      if (!articleDoc.exists()) return null
      return { id: articleDoc.id, ...articleDoc.data() } as Article
    },
    enabled: !!selectedBookmark,
  })

  const isLoading = authLoading || bookmarksLoading

  const handleSelectBookmark = (bookmark: Bookmark) => {
    hapticMedium()
    setSelectedBookmark(bookmark)
    setSheetOpen(true)
  }

  const handleRemoveBookmark = (bookmark: Bookmark) => {
    if (!selectedArticle && bookmark.articleId !== selectedBookmark?.articleId) {
      // Create a minimal article object for removal
      const minimalArticle: Article = {
        id: bookmark.articleId,
        title: bookmark.title,
        sourceName: bookmark.sourceName,
        url: bookmark.url,
        sourceId: "",
        snippet: "",
        canonicalUrl: bookmark.url,
        guid: null,
        imageUrl: null,
        categories: [],
        publishedAt: bookmark.bookmarkedAt,
        ingestedAt: bookmark.bookmarkedAt,
        relevanceScore: 0,
        isRelevant: true,
        ai: null,
      }

      setRemovingId(bookmark.articleId)
      toggleBookmark.mutate(
        { article: minimalArticle, isCurrentlyBookmarked: true },
        {
          onSuccess: () => {
            hapticSuccess()
            toast.success("Bookmark removed")
            setRemovingId(null)
          },
          onError: () => {
            toast.error("Failed to remove bookmark")
            setRemovingId(null)
          },
        }
      )
      return
    }

    if (selectedArticle) {
      setRemovingId(bookmark.articleId)
      toggleBookmark.mutate(
        { article: selectedArticle, isCurrentlyBookmarked: true },
        {
          onSuccess: () => {
            hapticSuccess()
            toast.success("Bookmark removed")
            setRemovingId(null)
            setSheetOpen(false)
          },
          onError: () => {
            toast.error("Failed to remove bookmark")
            setRemovingId(null)
          },
        }
      )
    }
  }

  const handleOpenArticle = () => {
    if (selectedBookmark) {
      window.open(selectedBookmark.url, "_blank", "noopener,noreferrer")
    }
  }

  return (
    <div className="space-y-[20px]">
      {/* Description */}
      <div className="-mt-[4px]">
        <p className="text-[15px] leading-[1.45] tracking-[-0.16px] text-[var(--color-text-secondary)]">
          Your reading list
        </p>
        {!isLoading && bookmarks && bookmarks.length > 0 && (
          <p className="mt-[8px] text-[13px] tracking-[-0.08px] text-[var(--color-text-tertiary)]">
            {bookmarks.length} article{bookmarks.length !== 1 ? "s" : ""} saved
          </p>
        )}
      </div>

      {/* Loading state */}
      {isLoading && (
        <Card variant="grouped">
          {Array.from({ length: 4 }).map((_, i) => (
            <div key={i}>
              <BookmarkRowSkeleton />
              {i < 3 && <Separator variant="inset" />}
            </div>
          ))}
        </Card>
      )}

      {/* Empty state */}
      {!isLoading && (!bookmarks || bookmarks.length === 0) && (
        <div className="flex flex-col items-center justify-center py-[48px] text-center">
          {/* Icon */}
          <div className="mb-[16px] flex h-[60px] w-[60px] items-center justify-center rounded-[18px] bg-[var(--color-fill-tertiary)]">
            <BookmarkIcon className="h-[26px] w-[26px] text-[var(--color-text-tertiary)]" strokeWidth={1.5} />
          </div>

          {/* Title */}
          <h3 className="mb-[6px] text-[20px] font-semibold tracking-[-0.4px] text-[var(--color-text-primary)]">
            Save for later
          </h3>

          {/* Description */}
          <p className="max-w-[260px] text-[15px] leading-[1.45] tracking-[-0.16px] text-[var(--color-text-secondary)]">
            Tap the bookmark icon on any article to build your reading list.
          </p>

          {/* Hint */}
          <p className="mt-[14px] text-[13px] tracking-[-0.08px] text-[var(--color-text-tertiary)]">
            Browse the Feed to discover articles
          </p>
        </div>
      )}

      {/* Bookmarks list */}
      {!isLoading && bookmarks && bookmarks.length > 0 && (
        <Card variant="grouped">
          {bookmarks.map((bookmark, index) => (
            <div key={bookmark.articleId}>
              <BookmarkRow
                bookmark={bookmark}
                onSelect={handleSelectBookmark}
                onRemove={handleRemoveBookmark}
                isRemoving={removingId === bookmark.articleId}
              />
              {index < bookmarks.length - 1 && <Separator variant="inset" />}
            </div>
          ))}
        </Card>
      )}

      {/* Bookmark detail sheet */}
      <Sheet open={sheetOpen} onOpenChange={setSheetOpen}>
        <SheetContent
          side="bottom"
          hideCloseButton
          className={SHEET_TOKENS.containerClass}
        >
          {/* Drag indicator */}
          <div className={SHEET_TOKENS.dragIndicatorClass} />

          {selectedBookmark && (
            <>
              {/* Accessibility: Visually hidden title for screen readers */}
              <SheetTitle className="sr-only">{selectedBookmark.title}</SheetTitle>
              <SheetDescription className="sr-only">
                Saved article from {selectedBookmark.sourceName}
              </SheetDescription>

              {/* Header */}
              <SheetHeaderBlock
                source={selectedBookmark.sourceName}
                timestamp={`Saved ${formatDate(selectedBookmark.bookmarkedAt.toDate())}`}
                title={selectedBookmark.title}
              />

              {/* AI Summary if available */}
              {selectedArticle?.ai && (
                <div className="mb-[24px] overflow-hidden rounded-[var(--radius-2xl)] bg-[var(--color-fill-quaternary)]">
                  <div className="border-b border-[var(--color-separator)] px-[18px] py-[16px]">
                    <SheetSection label="TL;DR">
                      {selectedArticle.ai.tldr}
                    </SheetSection>
                  </div>

                  <div className="px-[18px] py-[16px]">
                    <SheetSection label="Why It Matters">
                      {selectedArticle.ai.whyItMatters}
                    </SheetSection>
                  </div>

                  {/* Topics */}
                  {selectedArticle.ai.topics.length > 0 && (
                    <div className="flex flex-wrap gap-[6px] border-t border-[var(--color-separator)] px-[18px] py-[13px]">
                      {selectedArticle.ai.topics.map((topic) => (
                        <span
                          key={topic}
                          className="rounded-full bg-[var(--color-surface)] px-[12px] py-[6px] text-[12px] font-medium tracking-[-0.05px] text-[var(--color-text-secondary)]"
                        >
                          {topic}
                        </span>
                      ))}
                    </div>
                  )}

                  {/* AI Disclaimer */}
                  <div className="border-t border-[var(--color-separator)] px-[18px] py-[10px]">
                    <p className="text-[11px] text-[var(--color-text-tertiary)]">
                      Summary generated by AI. Read original source for full article.
                    </p>
                  </div>
                </div>
              )}

              {/* Snippet */}
              {selectedArticle?.snippet && (
                <SheetSnippet>{selectedArticle.snippet}</SheetSnippet>
              )}

              {/* Actions */}
              <SheetActions
                onReadArticle={handleOpenArticle}
                secondaryButton={
                  <SheetIconButton
                    onClick={() => handleRemoveBookmark(selectedBookmark)}
                    disabled={removingId === selectedBookmark.articleId}
                    loading={removingId === selectedBookmark.articleId}
                  >
                    <BookmarkIcon className="h-[20px] w-[20px] fill-current" />
                  </SheetIconButton>
                }
              />
            </>
          )}
        </SheetContent>
      </Sheet>
    </div>
  )
}



=================================================================================
FILE: src/pages/FeedPage.tsx
=================================================================================

/**
 * Feed Page - Infinite scroll article list with filters
 */

import { useState, useMemo, useRef, useCallback } from "react"
import { Inbox, Search } from "lucide-react"
import { useArticles, useSources, type ArticleFilters } from "@/lib/hooks"
import {
  CategoryChips,
  TimeWindowToggle,
  SourceFilter,
  SearchBar,
  ArticleCard,
  ArticleCardSkeleton,
  ArticleDetailSheet,
} from "@/components/feed"
import { EmptyState, ErrorState } from "@/components/ui"
import { hapticMedium } from "@/lib/haptics"
import type { Article, SourceCategory } from "@/types/firestore"

export function FeedPage() {
  // Filter state
  const [category, setCategory] = useState<SourceCategory | "all">("all")
  const [timeWindow, setTimeWindow] = useState<"24h" | "7d" | "all">("7d")
  const [selectedSourceIds, setSelectedSourceIds] = useState<string[]>([])
  const [searchQuery, setSearchQuery] = useState("")

  // Article detail sheet state
  const [selectedArticle, setSelectedArticle] = useState<Article | null>(null)
  const [sheetOpen, setSheetOpen] = useState(false)

  // Build filters object
  const filters: ArticleFilters = useMemo(
    () => ({
      category,
      timeWindow,
      sourceIds: selectedSourceIds.length > 0 ? selectedSourceIds : undefined,
    }),
    [category, timeWindow, selectedSourceIds]
  )

  // Fetch articles with infinite scroll
  const {
    data,
    isLoading,
    isFetchingNextPage,
    hasNextPage,
    fetchNextPage,
    error,
  } = useArticles(filters)

  // Fetch sources for filter
  const { data: sources = [] } = useSources()

  // Flatten pages into single array
  const articles = useMemo(() => {
    if (!data?.pages) return []
    return data.pages.flatMap((page) => page.articles)
  }, [data])

  // Client-side search filter
  const filteredArticles = useMemo(() => {
    if (!searchQuery.trim()) return articles
    const query = searchQuery.toLowerCase()
    return articles.filter(
      (article) =>
        article.title.toLowerCase().includes(query) ||
        article.snippet.toLowerCase().includes(query) ||
        article.sourceName.toLowerCase().includes(query)
    )
  }, [articles, searchQuery])

  // Infinite scroll observer - triggers 150px before element comes into view
  // Conservative margin prevents over-fetching while keeping scroll smooth
  const observerRef = useRef<IntersectionObserver | null>(null)
  const loadMoreRef = useCallback(
    (node: HTMLDivElement | null) => {
      if (isFetchingNextPage) return
      if (observerRef.current) observerRef.current.disconnect()

      observerRef.current = new IntersectionObserver(
        (entries) => {
          if (entries[0].isIntersecting && hasNextPage) {
            fetchNextPage()
          }
        },
        { rootMargin: '0px 0px 150px 0px' }
      )

      if (node) observerRef.current.observe(node)
    },
    [isFetchingNextPage, hasNextPage, fetchNextPage]
  )

  const handleSelectArticle = (article: Article) => {
    hapticMedium()
    setSelectedArticle(article)
    setSheetOpen(true)
  }

  return (
    <>
      <div className="-mx-[var(--spacing-4)] -mt-[6px]">
        {/* Sticky filters header - minimal height, positioned below TopNav */}
        <div
          className="glass-nav sticky z-30 px-[var(--spacing-4)] pb-[12px] pt-[10px]"
          style={{ top: 'calc(52px + var(--safe-area-inset-top))' }}
        >
          {/* Search */}
          <div className="mb-[12px]">
            <SearchBar value={searchQuery} onChange={setSearchQuery} />
          </div>

          {/* Category pills - scrollable */}
          <CategoryChips value={category} onChange={setCategory} />

          {/* Time + Sources row - compact inline controls with hairline above */}
          <div className="mt-[12px] flex items-center gap-[8px] pt-[10px] border-t border-[var(--color-separator-opaque)]">
            <TimeWindowToggle value={timeWindow} onChange={setTimeWindow} />
            <div className="h-[16px] w-px bg-[var(--color-separator-opaque)] mx-[4px]" />
            <SourceFilter
              sources={sources}
              selectedIds={selectedSourceIds}
              onChange={setSelectedSourceIds}
            />
          </div>
        </div>

        {/* Articles list */}
        <div className="min-h-[50vh] px-[var(--spacing-4)] py-[16px]">
          {/* Loading state */}
          {isLoading && (
            <div className="space-y-[12px]">
              {Array.from({ length: 5 }).map((_, i) => (
                <ArticleCardSkeleton key={i} />
              ))}
            </div>
          )}

          {/* Error state - vertically centered */}
          {error && !filteredArticles.length && (
            <div className="flex min-h-[50vh] items-center justify-center pt-[var(--spacing-4)]">
              <ErrorState
                title="Unable to load articles"
                description="Check your connection and try again."
                onRetry={() => window.location.reload()}
              />
            </div>
          )}

          {/* Empty state - vertically centered */}
          {!isLoading && !error && filteredArticles.length === 0 && (
            <div className="flex min-h-[50vh] items-center justify-center pt-[var(--spacing-4)]">
              <EmptyState
                icon={searchQuery ? Search : Inbox}
                title={searchQuery ? "No results" : "No articles"}
                description={
                  searchQuery
                    ? "Try a different search term."
                    : "Adjust filters or check back later."
                }
              />
            </div>
          )}

          {/* Article cards - tighter spacing */}
          {!isLoading && filteredArticles.length > 0 && (
            <div className="space-y-[12px]">
              {filteredArticles.map((article) => (
                <ArticleCard
                  key={article.id}
                  article={article}
                  onSelect={handleSelectArticle}
                />
              ))}
            </div>
          )}

          {/* Load more trigger - positioned well ahead */}
          {hasNextPage && !searchQuery && (
            <div ref={loadMoreRef} className="py-[32px]">
              {isFetchingNextPage && (
                <div className="flex justify-center">
                  <div className="h-[18px] w-[18px] rounded-full border-[2px] border-[var(--color-accent)] border-t-transparent spinner" />
                </div>
              )}
            </div>
          )}

          {/* End of list */}
          {!hasNextPage && filteredArticles.length > 0 && !searchQuery && (
            <p className="py-[40px] text-center text-[13px] text-[var(--color-text-quaternary)]">
              You're all caught up
            </p>
          )}
        </div>
      </div>

      {/* Article detail sheet */}
      <ArticleDetailSheet
        article={selectedArticle}
        open={sheetOpen}
        onOpenChange={setSheetOpen}
      />
    </>
  )
}



=================================================================================
FILE: src/pages/index.ts
=================================================================================

export { TodayPage } from "./TodayPage"
export { FeedPage } from "./FeedPage"
export { SourcesPage } from "./SourcesPage"
export { BookmarksPage } from "./BookmarksPage"
export { SettingsPage } from "./SettingsPage"
export { AskPage } from "./AskPage"



=================================================================================
FILE: src/pages/SettingsPage.tsx
=================================================================================

import { Switch } from "@/components/ui/switch"
import { SectionLabel, SectionFooter, Card, Separator } from "@/components/ui"
import { ChevronRight, Bell, Tag, TextCursor, Info, FileText, Shield } from "lucide-react"
import {
  useUserPreferences,
  useToggleNotifications,
  usePushNotifications,
} from "@/lib/hooks"
import { hapticLight, hapticSuccess } from "@/lib/haptics"

export function SettingsPage() {
  const { data: prefs, isLoading: prefsLoading } = useUserPreferences()
  const toggleNotifications = useToggleNotifications()
  const {
    isSupported: pushSupported,
    isLoading: pushLoading,
    permissionStatus,
    enableNotifications,
  } = usePushNotifications()

  const notificationsEnabled = prefs?.notifications?.dailyBrief ?? true
  const canEnableNotifications = pushSupported && permissionStatus !== "denied"

  const handleNotificationToggle = async (checked: boolean) => {
    hapticLight()

    if (checked && permissionStatus !== "granted") {
      const success = await enableNotifications()
      if (success) {
        hapticSuccess()
      }
      if (!success) return
    }
    toggleNotifications.mutate({ dailyBrief: checked })
  }

  return (
    <div className="space-y-[24px] pb-[20px]">
      {/* Notifications Section */}
      <section className="space-y-[6px]">
        <SectionLabel inset>Notifications</SectionLabel>
        <Card variant="grouped">
          {/* Daily Brief row */}
          <div className="flex min-h-[44px] items-center px-[16px] py-[8px]">
            <div className="flex h-[29px] w-[29px] shrink-0 items-center justify-center rounded-[6px] bg-[#FF3B30]">
              <Bell className="h-[17px] w-[17px] text-white" strokeWidth={1.75} />
            </div>
            <span className="ml-[12px] flex-1 text-[17px] leading-[22px] text-[var(--color-text-primary)]">
              Daily Brief
            </span>
            <Switch
              checked={notificationsEnabled}
              onCheckedChange={handleNotificationToggle}
              disabled={
                prefsLoading ||
                pushLoading ||
                toggleNotifications.isPending ||
                !canEnableNotifications
              }
            />
          </div>
        </Card>
        {permissionStatus === "denied" ? (
          <SectionFooter inset>
            Notifications are turned off. To enable, go to{" "}
            <span className="font-medium">Settings → P&C Brief → Notifications</span>.
          </SectionFooter>
        ) : !pushSupported && !pushLoading ? (
          <SectionFooter inset>
            Push notifications aren't available on this device.
          </SectionFooter>
        ) : (
          <SectionFooter inset>
            Get a notification each morning when your brief is ready.
          </SectionFooter>
        )}
      </section>

      {/* Preferences Section */}
      <section className="space-y-[6px]">
        <SectionLabel inset>Preferences</SectionLabel>
        <Card variant="grouped">
          {/* Topics row - disabled */}
          <div className="flex min-h-[44px] items-center px-[16px] py-[8px]">
            <div className="flex h-[29px] w-[29px] shrink-0 items-center justify-center rounded-[6px] bg-[#5856D6] opacity-50">
              <Tag className="h-[17px] w-[17px] text-white" strokeWidth={1.75} />
            </div>
            <span className="ml-[12px] flex-1 text-[17px] leading-[22px] text-[var(--color-text-tertiary)]">
              Topics
            </span>
            <span className="mr-[6px] text-[15px] text-[var(--color-text-tertiary)]">
              Coming Soon
            </span>
            <ChevronRight className="h-[14px] w-[14px] text-[var(--color-text-tertiary)]" strokeWidth={2} />
          </div>
          <Separator variant="inset-icon" />
          {/* Reading row - disabled */}
          <div className="flex min-h-[44px] items-center px-[16px] py-[8px]">
            <div className="flex h-[29px] w-[29px] shrink-0 items-center justify-center rounded-[6px] bg-[#007AFF] opacity-50">
              <TextCursor className="h-[17px] w-[17px] text-white" strokeWidth={1.75} />
            </div>
            <span className="ml-[12px] flex-1 text-[17px] leading-[22px] text-[var(--color-text-tertiary)]">
              Reading
            </span>
            <span className="mr-[6px] text-[15px] text-[var(--color-text-tertiary)]">
              Coming Soon
            </span>
            <ChevronRight className="h-[14px] w-[14px] text-[var(--color-text-tertiary)]" strokeWidth={2} />
          </div>
        </Card>
      </section>

      {/* About Section */}
      <section className="space-y-[6px]">
        <SectionLabel inset>About</SectionLabel>
        <Card variant="grouped">
          {/* Version row */}
          <div className="flex min-h-[44px] items-center px-[16px] py-[8px]">
            <div className="flex h-[29px] w-[29px] shrink-0 items-center justify-center rounded-[6px] bg-[var(--color-fill-secondary)]">
              <Info className="h-[17px] w-[17px] text-[var(--color-text-secondary)]" strokeWidth={1.75} />
            </div>
            <span className="ml-[12px] flex-1 text-[17px] leading-[22px] text-[var(--color-text-primary)]">
              Version
            </span>
            <span className="text-[17px] text-[var(--color-text-tertiary)]">
              1.0.0
            </span>
          </div>
          <Separator variant="inset-icon" />
          {/* Terms of Service row */}
          <button
            className="flex min-h-[44px] w-full items-center px-[16px] py-[8px] text-left transition-colors active:bg-[var(--color-fill-quaternary)]"
            onClick={() => hapticLight()}
          >
            <div className="flex h-[29px] w-[29px] shrink-0 items-center justify-center rounded-[6px] bg-[var(--color-fill-secondary)]">
              <FileText className="h-[17px] w-[17px] text-[var(--color-text-secondary)]" strokeWidth={1.75} />
            </div>
            <span className="ml-[12px] flex-1 text-[17px] leading-[22px] text-[var(--color-text-primary)]">
              Terms of Service
            </span>
            <ChevronRight className="h-[14px] w-[14px] text-[var(--color-text-tertiary)]" strokeWidth={2} />
          </button>
          <Separator variant="inset-icon" />
          {/* Privacy Policy row */}
          <button
            className="flex min-h-[44px] w-full items-center px-[16px] py-[8px] text-left transition-colors active:bg-[var(--color-fill-quaternary)]"
            onClick={() => hapticLight()}
          >
            <div className="flex h-[29px] w-[29px] shrink-0 items-center justify-center rounded-[6px] bg-[var(--color-fill-secondary)]">
              <Shield className="h-[17px] w-[17px] text-[var(--color-text-secondary)]" strokeWidth={1.75} />
            </div>
            <span className="ml-[12px] flex-1 text-[17px] leading-[22px] text-[var(--color-text-primary)]">
              Privacy Policy
            </span>
            <ChevronRight className="h-[14px] w-[14px] text-[var(--color-text-tertiary)]" strokeWidth={2} />
          </button>
        </Card>
      </section>

      {/* Sign Out */}
      <section className="pt-[8px]">
        <Card variant="grouped">
          <button
            className="flex min-h-[44px] w-full items-center justify-center text-[17px] text-[var(--color-destructive)] transition-colors active:bg-[var(--color-fill-quaternary)]"
            onClick={() => hapticLight()}
          >
            Sign Out
          </button>
        </Card>
      </section>

      {/* Footer */}
      <footer className="pt-[8px] text-center">
        <p className="text-[13px] text-[var(--color-text-tertiary)]">
          P&C Brief
        </p>
      </footer>
    </div>
  )
}



=================================================================================
FILE: src/pages/SourcesPage.tsx
=================================================================================

/**
 * Sources Page - Manage followed news sources
 */

import { useMemo } from "react"
import { Globe } from "lucide-react"
import { toast } from "sonner"
import {
  useAllSources,
  useUserPreferences,
  useToggleSource,
  useResetSourcePreferences,
} from "@/lib/hooks"
import { useAuth } from "@/lib/auth-context"
import { SourceRow, SourceRowSkeleton } from "@/components/sources"
import { Card, Separator, EmptyState, ErrorState } from "@/components/ui"
import { hapticLight, hapticSuccess } from "@/lib/haptics"

export function SourcesPage() {
  const { isLoading: authLoading } = useAuth()
  const { data: sources, isLoading: sourcesLoading, error: sourcesError } = useAllSources()
  const { data: preferences, isLoading: prefsLoading } = useUserPreferences()
  const toggleSource = useToggleSource()
  const resetPreferences = useResetSourcePreferences()

  // Determine which sources the user is following
  // Empty enabledSourceIds means "follow all"
  const followedSourceIds = useMemo(() => {
    if (!preferences?.enabledSourceIds || preferences.enabledSourceIds.length === 0) {
      // Following all sources
      return sources?.map((s) => s.id) ?? []
    }
    return preferences.enabledSourceIds
  }, [preferences, sources])

  const isFollowingAll =
    !preferences?.enabledSourceIds || preferences.enabledSourceIds.length === 0

  const followingCount = isFollowingAll
    ? sources?.length ?? 0
    : followedSourceIds.length

  const isLoading = authLoading || sourcesLoading || prefsLoading

  const handleToggle = (sourceId: string, enabled: boolean) => {
    hapticLight()

    // If currently following all and toggling off, we need to set explicit list
    let currentIds: string[]
    if (isFollowingAll) {
      // Start with all sources, then remove the one being toggled off
      currentIds = sources?.map((s) => s.id) ?? []
    } else {
      currentIds = [...followedSourceIds]
    }

    toggleSource.mutate(
      { sourceId, enabled, currentEnabledIds: currentIds },
      {
        onError: (error) => {
          console.error("Failed to toggle source:", error)
          toast.error("Failed to update preference", {
            description: "Please try again",
          })
        },
      }
    )
  }

  const handleFollowAll = () => {
    resetPreferences.mutate(undefined, {
      onSuccess: () => {
        hapticSuccess()
        toast.success("Following all sources")
      },
      onError: (error) => {
        console.error("Failed to reset preferences:", error)
        toast.error("Failed to update preferences")
      },
    })
  }

  return (
    <div className="space-y-[24px]">
      {/* Description */}
      <p className="-mt-[6px] text-[14px] leading-[1.5] tracking-[-0.14px] text-[var(--color-text-secondary)]">
        Choose which sources appear in your feed. Changes only affect your personal view.
      </p>

      {/* Stats and actions bar */}
      {!isLoading && sources && (
        <div className="flex min-h-[44px] items-center justify-between py-[2px]">
          <p className="text-[13px] tracking-[-0.08px] text-[var(--color-text-tertiary)]">
            Following{" "}
            <span className="font-medium tabular-nums text-[var(--color-text-secondary)]">
              {followingCount}
            </span>{" "}
            of {sources.length}
          </p>
          {!isFollowingAll && (
            <button
              onClick={handleFollowAll}
              disabled={resetPreferences.isPending}
              className="min-h-[34px] min-w-[44px] px-[var(--spacing-2)] text-[15px] font-normal tracking-[-0.2px] text-[var(--color-accent)] transition-opacity active:opacity-50 disabled:opacity-38"
            >
              Follow All
            </button>
          )}
        </div>
      )}

      {/* Sources list */}
      <div className="min-h-[40vh]">
        {/* Loading state */}
        {isLoading && (
          <Card variant="grouped">
            {Array.from({ length: 6 }).map((_, i) => (
              <div key={i}>
                <SourceRowSkeleton />
                {i < 5 && <Separator variant="inset" />}
              </div>
            ))}
          </Card>
        )}

        {/* Error state */}
        {sourcesError && (
          <ErrorState
            title="Unable to load sources"
            description="We couldn't fetch the sources list. Please try again."
            onRetry={() => window.location.reload()}
          />
        )}

        {/* Empty state */}
        {!isLoading && !sourcesError && sources?.length === 0 && (
          <EmptyState
            icon={Globe}
            title="No sources available"
            description="News sources will appear here once configured."
          />
        )}

        {/* Sources grouped list - iOS Settings style */}
        {!isLoading && sources && sources.length > 0 && (
          <Card variant="grouped">
            {sources.map((source, index) => (
              <div key={source.id}>
                <SourceRow
                  source={source}
                  isFollowing={followedSourceIds.includes(source.id)}
                  onToggle={(enabled) => handleToggle(source.id, enabled)}
                  isLoading={toggleSource.isPending}
                />
                {index < sources.length - 1 && <Separator variant="inset" />}
              </div>
            ))}
          </Card>
        )}
      </div>
    </div>
  )
}



=================================================================================
FILE: src/pages/TodayPage.tsx
=================================================================================

/**
 * Today Screen - Premium Daily Brief View
 *
 * Apple-inspired design with refined hierarchy:
 * - Date header with AI badge
 * - Executive summary with accent bullets
 * - Top stories carousel with gradient overlays
 * - Category sections with muted icon chips
 * - Topics and sources footer
 */

import { useState } from "react"
import { Newspaper, Sparkles } from "lucide-react"
import { useTodayBrief, type TopStoryWithArticle } from "@/lib/hooks/use-today-brief"
import {
  TodayScreenSkeleton,
  TopStoriesCarousel,
  BriefSections,
  ArticleSheet,
} from "@/components/brief"
import { EmptyState, ErrorState, SectionLabel, Card } from "@/components/ui"
import { hapticMedium } from "@/lib/haptics"

function formatDate(dateString: string): string {
  const date = new Date(dateString + "T12:00:00")
  return date.toLocaleDateString("en-US", {
    weekday: "long",
    month: "long",
    day: "numeric",
  })
}

function formatUpdateTime(createdAt: { toDate?: () => Date } | null): string {
  if (!createdAt || !createdAt.toDate) {
    return "Updated this morning"
  }
  try {
    const date = createdAt.toDate()
    const hours = date.getHours()
    const minutes = date.getMinutes()
    const ampm = hours >= 12 ? "PM" : "AM"
    const displayHours = hours % 12 || 12
    const displayMinutes = minutes.toString().padStart(2, "0")
    return `Updated ${displayHours}:${displayMinutes} ${ampm} ET`
  } catch {
    return "Updated this morning"
  }
}

export function TodayPage() {
  const { data, isLoading, error, refetch } = useTodayBrief()
  const [selectedStory, setSelectedStory] = useState<TopStoryWithArticle | null>(null)
  const [sheetOpen, setSheetOpen] = useState(false)

  const handleSelectStory = (story: TopStoryWithArticle) => {
    hapticMedium()
    setSelectedStory(story)
    setSheetOpen(true)
  }

  // Loading state (only show skeleton if no cached data)
  if (isLoading && !data) {
    return <TodayScreenSkeleton />
  }

  // Error state
  if (error && !data) {
    return (
      <ErrorState
        title="Unable to load brief"
        description="We couldn't fetch today's briefing. Please try again."
        onRetry={() => refetch()}
      />
    )
  }

  // No brief found
  if (!data?.found || !data.brief) {
    return (
      <EmptyState
        icon={Newspaper}
        title="No brief available yet"
        description="Check back soon for today's industry briefing."
      />
    )
  }

  const { brief, topStoriesWithArticles } = data

  return (
    <>
      <div className="space-y-[20px]">
        {/* Date Header */}
        <header>
          <p className="text-[14px] font-medium tracking-[-0.15px] text-[var(--color-text-secondary)]">
            {formatDate(brief.date)}
          </p>
        </header>

        {/* Executive Summary Card */}
        <Card>
          {/* Card Header with AI Badge */}
          <div className="flex items-center justify-between border-b border-[var(--color-separator)] px-[14px] py-[10px]">
            <div className="flex items-center gap-[6px]">
              <div className="flex h-[20px] items-center gap-[4px] rounded-full bg-[#007AFF]/8 px-[8px]">
                <Sparkles className="h-[10px] w-[10px] text-[#007AFF]" strokeWidth={2.25} />
                <span className="text-[10px] font-semibold tracking-[0.1px] text-[#007AFF]/90">
                  AI Daily Brief
                </span>
              </div>
            </div>
            <span className="text-[12px] font-medium tracking-[-0.1px] text-[var(--color-text-secondary)]">
              {formatUpdateTime(brief.createdAt)}
            </span>
          </div>

          {/* Executive Summary Bullets */}
          <div className="px-[14px] py-[12px]">
            <ul className="space-y-[8px]">
              {brief.executiveSummary.map((bullet, index) => (
                <li
                  key={index}
                  className="flex gap-[10px] text-[15px] leading-[1.45] tracking-[-0.2px] text-[var(--color-text-primary)]"
                >
                  <span className="mt-[7px] h-[5px] w-[5px] shrink-0 rounded-full bg-gradient-to-br from-[#007AFF] to-[#5856D6]" />
                  <span>{bullet}</span>
                </li>
              ))}
            </ul>
          </div>
        </Card>

        {/* Top Stories */}
        {topStoriesWithArticles.length > 0 && (
          <section className="space-y-[6px]">
            <SectionLabel>Top Stories</SectionLabel>
            <TopStoriesCarousel
              stories={topStoriesWithArticles}
              onSelectStory={handleSelectStory}
            />
          </section>
        )}

        {/* Category Sections */}
        <section className="space-y-[6px]">
          <SectionLabel>By Category</SectionLabel>
          <BriefSections sections={brief.sections} />
        </section>

        {/* Topics */}
        {brief.topics.length > 0 && (
          <section className="space-y-[6px]">
            <SectionLabel>Topics Covered</SectionLabel>
            <div className="flex flex-wrap gap-[5px]">
              {brief.topics.map((topic, index) => (
                <span
                  key={index}
                  className="rounded-full bg-[var(--color-fill-tertiary)] px-[10px] py-[5px] text-[12px] font-medium tracking-[-0.08px] text-[var(--color-text-secondary)] transition-colors duration-[var(--duration-fast)] active:bg-[var(--color-fill-secondary)]"
                >
                  {topic}
                </span>
              ))}
            </div>
          </section>
        )}

        {/* Sources Footer */}
        <footer className="border-t border-[var(--color-separator)] pt-[12px]">
          <p className="text-[12px] leading-[1.55] tracking-[-0.06px] text-[var(--color-text-secondary)]">
            Compiled from {brief.sourcesUsed.length} sources:{" "}
            <span className="text-[var(--color-text-tertiary)]">
              {brief.sourcesUsed.map((s) => s.name).join(" · ")}
            </span>
          </p>
        </footer>
      </div>

      {/* Article Sheet */}
      <ArticleSheet
        story={selectedStory}
        open={sheetOpen}
        onOpenChange={setSheetOpen}
      />
    </>
  )
}



=================================================================================
FILE: src/types/firestore.ts
=================================================================================

/**
 * Firestore Document Types for P&C Insurance News AI
 *
 * Collections:
 * - sources/{sourceId}
 * - articles/{articleId}
 * - briefs/{yyyy-mm-dd}
 * - users/{uid}
 *   - bookmarks/{articleId}
 *   - prefs/main
 */

import type { Timestamp } from "firebase/firestore";

// ============================================================================
// Sources Collection: sources/{sourceId}
// ============================================================================

export type SourceCategory =
  | "property_cat"
  | "casualty_liability"
  | "regulation"
  | "claims"
  | "reinsurance"
  | "insurtech";

/** Source tier indicating trustworthiness/quality */
export type SourceTier = "reputable" | "community" | "user-submitted";

/** Fetch state for conditional RSS requests */
export interface SourceFetchState {
  /** ETag from last fetch (for conditional requests) */
  etag: string | null;
  /** Last-Modified header from last fetch */
  lastModified: string | null;
  /** Last successful fetch timestamp */
  lastFetchedAt: Timestamp | null;
  /** Last fetch error message (null if successful) */
  lastError: string | null;
}

export interface Source {
  /** Unique identifier (slug-style, e.g., "insurance-journal") */
  id: string;
  /** Display name */
  name: string;
  /** Publisher website URL */
  siteUrl: string;
  /** RSS feed URL (legacy single-feed) */
  rssUrl: string;
  /** RSS feed URLs (supports multiple feeds per source) */
  rssUrls?: string[];
  /** Whether this source is enabled for ingestion */
  enabled: boolean;
  /** Whether this source is enabled by default for new users */
  enabledByDefault?: boolean;
  /** Source tier indicating trustworthiness */
  tier: SourceTier;
  /** Tags for categorization and filtering */
  tags: SourceCategory[];
  /** Region/geography focus (optional) */
  region?: string;
  /** Created timestamp */
  createdAt: Timestamp;
  /** Updated timestamp */
  updatedAt: Timestamp;
  /** Fetch state for conditional requests (keyed by rssUrl for multi-feed) */
  fetchState: SourceFetchState;
  /** Fetch states per RSS URL (for multi-feed sources) */
  fetchStates?: Record<string, SourceFetchState>;
}

// ============================================================================
// Articles Collection: articles/{articleId}
// ============================================================================

export interface Article {
  /** Unique identifier (SHA256 hash of canonical URL or GUID) */
  id: string;
  /** Source ID reference */
  sourceId: string;
  /** Source display name (denormalized for display) */
  sourceName: string;
  /** Article headline/title */
  title: string;
  /** Short snippet/excerpt (≤200 chars, respecting publisher policies) */
  snippet: string;
  /** Original article URL */
  url: string;
  /** Normalized canonical URL (for deduplication) */
  canonicalUrl: string;
  /** RSS GUID if available (fallback for deduplication) */
  guid: string | null;
  /** Article image URL if present in RSS */
  imageUrl: string | null;
  /** Article categories */
  categories: SourceCategory[];
  /** Publication timestamp */
  publishedAt: Timestamp;
  /** When we ingested this article */
  ingestedAt: Timestamp;
  /** P&C relevance score (0-1) from heuristic filter */
  relevanceScore: number;
  /** Whether article passes P&C relevance filter */
  isRelevant: boolean;
  /** AI-generated content (cached, generated on first request) */
  ai: ArticleAI | null;
  /** Vector embedding for semantic search (optional, computed on-demand) */
  embedding?: ArticleEmbedding;
  /** Search tokens for lexical narrowing (optional, computed at ingest) */
  searchTokens?: string[];
}

/**
 * Vector embedding for an article
 */
export interface ArticleEmbedding {
  /** Number of dimensions in the vector */
  dims: number;
  /** The embedding vector */
  vector: number[];
  /** Model used to generate the embedding */
  model: string;
  /** When the embedding was generated */
  updatedAt: Timestamp;
}

/**
 * AI-generated article content
 */
export interface ArticleAI {
  /** 2-3 sentence executive summary */
  tldr: string;
  /** Why this matters for P&C professionals */
  whyItMatters: string;
  /** 2-4 relevant topic tags */
  topics: string[];
  /** Primary category */
  category: "property" | "casualty" | "reinsurance" | "regulation" | "claims" | "insurtech" | "market" | "litigation";
  /** When AI content was generated */
  generatedAt: Timestamp;
  /** Model used for generation */
  model: string;
}

// ============================================================================
// Briefs Collection: briefs/{yyyy-mm-dd}
// ============================================================================

export interface BriefTopStory {
  /** Article ID reference */
  articleId: string;
  /** Article headline (synthesized, not copied) */
  headline: string;
  /** Why this story matters for P&C professionals */
  whyItMatters: string;
}

export interface BriefSection {
  /** Section bullets (2-4 items) */
  bullets: string[];
  /** Related article IDs */
  articleIds: string[];
}

export interface BriefSourceUsed {
  /** Source ID */
  sourceId: string;
  /** Source display name */
  name: string;
}

export interface Brief {
  /** Date in yyyy-mm-dd format */
  date: string;
  /** When this brief was created */
  createdAt: Timestamp;
  /** Executive summary bullets (3-5 items) */
  executiveSummary: string[];
  /** Top stories with "why it matters" */
  topStories: BriefTopStory[];
  /** Category sections */
  sections: {
    propertyCat: BriefSection;
    casualtyLiability: BriefSection;
    regulation: BriefSection;
    claims: BriefSection;
    reinsurance: BriefSection;
    insurtech: BriefSection;
    market: BriefSection;
  };
  /** Key topics covered */
  topics: string[];
  /** Sources used to generate this brief */
  sourcesUsed: BriefSourceUsed[];
  /** Article IDs used to generate this brief (for grounded chat) */
  sourceArticleIds: string[];
  /** Model used for generation */
  model: string;
}

// ============================================================================
// Users Collection: users/{uid}
// ============================================================================

export interface UserProfile {
  /** User's Firebase UID */
  uid: string;
  /** Email address */
  email: string | null;
  /** Display name */
  displayName: string | null;
  /** Account created timestamp */
  createdAt: Timestamp;
  /** Last login timestamp */
  lastLoginAt: Timestamp;
}

// ============================================================================
// User Bookmarks Subcollection: users/{uid}/bookmarks/{articleId}
// ============================================================================

export interface Bookmark {
  /** Article ID (same as document ID) */
  articleId: string;
  /** Article title (denormalized for display) */
  title: string;
  /** Source name (denormalized) */
  sourceName: string;
  /** Article URL */
  url: string;
  /** When bookmarked */
  bookmarkedAt: Timestamp;
}

// ============================================================================
// User Preferences Subcollection: users/{uid}/prefs/main
// ============================================================================

export interface UserPreferences {
  /** Source IDs the user has enabled */
  enabledSourceIds: string[];
  /** Categories the user wants to see */
  enabledCategories: SourceCategory[];
  /** Notification preferences */
  notifications: {
    dailyBrief: boolean;
    breakingNews: boolean;
  };
  /** Last updated timestamp */
  updatedAt: Timestamp;
}

// ============================================================================
// Chat Threads Subcollection: users/{uid}/chatThreads/{threadId}
// ============================================================================

/** Time scope for chat queries */
export type ChatTimeScope = "today" | "7d" | "30d";

/** Source filter mode */
export type ChatSourceFilter = "all" | "selected";

/** Category filter for chat */
export type ChatCategory = "all" | "property" | "casualty" | "regulation" | "claims" | "reinsurance";

/** Citation reference in a chat message */
export interface ChatCitation {
  /** Article ID reference */
  articleId: string;
  /** Article title */
  title: string;
  /** Source name */
  sourceName: string;
  /** Article URL */
  url: string;
  /** Publication timestamp (ISO string for serialization) */
  publishedAt: string;
}

/** Chat thread document */
export interface ChatThread {
  /** Thread ID (document ID) */
  id: string;
  /** Thread title (auto-generated from first message or user-set) */
  title: string;
  /** When thread was created */
  createdAt: Timestamp;
  /** When thread was last updated */
  updatedAt: Timestamp;
  /** Time scope filter */
  scope: ChatTimeScope;
  /** Source filter mode */
  sourceFilter: ChatSourceFilter;
  /** Category filter */
  category: ChatCategory;
}

/** Chat message document */
export interface ChatMessage {
  /** Message ID (document ID) */
  id: string;
  /** Message role */
  role: "user" | "assistant";
  /** Message content */
  content: string;
  /** When message was created */
  createdAt: Timestamp;
  /** Citations (only for assistant messages) */
  citations?: ChatCitation[];
}



=================================================================================
FILE: src/types/index.ts
=================================================================================

/**
 * Type exports for P&C Insurance News AI
 */

export type {
  // Source types
  Source,
  SourceCategory,
  SourceTier,
  SourceFetchState,
  // Article types
  Article,
  ArticleAI,
  ArticleEmbedding,
  // Brief types
  Brief,
  BriefTopStory,
  BriefSection,
  BriefSourceUsed,
  // User types
  UserProfile,
  Bookmark,
  UserPreferences,
  // Chat types
  ChatTimeScope,
  ChatSourceFilter,
  ChatCategory,
  ChatCitation,
  ChatThread,
  ChatMessage,
} from "./firestore";



=================================================================================
FILE: public/manifest.json
=================================================================================

{
  "name": "P&C Brief",
  "short_name": "P&C Brief",
  "description": "Insurance industry news and insights powered by AI",
  "start_url": "/",
  "display": "standalone",
  "background_color": "#ffffff",
  "theme_color": "#FFFFFF",
  "orientation": "portrait",
  "icons": [
    {
      "src": "/logo.svg",
      "sizes": "any",
      "type": "image/svg+xml",
      "purpose": "any"
    },
    {
      "src": "/icons/icon-192.png",
      "sizes": "192x192",
      "type": "image/png",
      "purpose": "any maskable"
    },
    {
      "src": "/icons/icon-512.png",
      "sizes": "512x512",
      "type": "image/png",
      "purpose": "any maskable"
    }
  ]
}



=================================================================================
FILE: public/firebase-messaging-sw.js
=================================================================================

/**
 * Firebase Cloud Messaging Service Worker
 *
 * This service worker handles background push notifications for the web app.
 * It must be placed in the public directory to be served from the root.
 */

// Import Firebase scripts for service worker
importScripts('https://www.gstatic.com/firebasejs/10.7.0/firebase-app-compat.js');
importScripts('https://www.gstatic.com/firebasejs/10.7.0/firebase-messaging-compat.js');

// Firebase configuration (must match the main app config)
const firebaseConfig = {
  apiKey: "AIzaSyC55lowlixG6V8KI-bWV4T-x6MiuNp38-g",
  projectId: "insurance-news-ai",
  authDomain: "insurance-news-ai.firebaseapp.com",
  storageBucket: "insurance-news-ai.firebasestorage.app",
  messagingSenderId: "695640024145",
  appId: "1:695640024145:web:ab17c496e14b3d915ac470",
};

// Initialize Firebase in the service worker
firebase.initializeApp(firebaseConfig);

// Get messaging instance
const messaging = firebase.messaging();

/**
 * Handle background messages
 * This is called when the app is in the background or closed
 */
messaging.onBackgroundMessage((payload) => {
  console.log('[firebase-messaging-sw.js] Received background message:', payload);

  // Extract notification data
  const notificationTitle = payload.notification?.title || 'P&C Brief';
  const notificationOptions = {
    body: payload.notification?.body || 'You have a new update',
    icon: '/pwa-192x192.png',
    badge: '/pwa-192x192.png',
    tag: payload.data?.type || 'default',
    data: payload.data,
    // iOS-style notification options
    vibrate: [100, 50, 100],
    requireInteraction: false,
    actions: [
      {
        action: 'open',
        title: 'Open',
      },
    ],
  };

  // Show the notification
  self.registration.showNotification(notificationTitle, notificationOptions);
});

/**
 * Handle notification click
 */
self.addEventListener('notificationclick', (event) => {
  console.log('[firebase-messaging-sw.js] Notification clicked:', event);

  event.notification.close();

  // Determine the URL to open based on notification data
  let urlToOpen = '/';
  
  if (event.notification.data?.type === 'daily_brief') {
    urlToOpen = '/'; // Daily brief is on the home page
  }

  // Focus existing window or open new one
  event.waitUntil(
    clients.matchAll({ type: 'window', includeUncontrolled: true }).then((windowClients) => {
      // Check if there's already a window open
      for (const client of windowClients) {
        if (client.url.includes(self.location.origin) && 'focus' in client) {
          client.focus();
          if (urlToOpen !== '/') {
            client.navigate(urlToOpen);
          }
          return;
        }
      }
      // Open new window if none exists
      if (clients.openWindow) {
        return clients.openWindow(urlToOpen);
      }
    })
  );
});

/**
 * Handle service worker installation
 */
self.addEventListener('install', (event) => {
  console.log('[firebase-messaging-sw.js] Service worker installed');
  self.skipWaiting();
});

/**
 * Handle service worker activation
 */
self.addEventListener('activate', (event) => {
  console.log('[firebase-messaging-sw.js] Service worker activated');
  event.waitUntil(clients.claim());
});



=================================================================================
FILE: scripts/get-vapid-key.mjs
=================================================================================

#!/usr/bin/env node
/**
 * Get VAPID Key from Firebase
 * 
 * Uses the Firebase CLI's stored credentials to make authenticated API calls
 * to retrieve the web push certificate (VAPID key) from Firebase.
 */

import { readFileSync, writeFileSync, existsSync } from 'fs';
import { homedir } from 'os';
import { join } from 'path';
import https from 'https';

const PROJECT_ID = 'insurance-news-ai';
const WEB_APP_ID = '1:695640024145:web:ab17c496e14b3d915ac470';

// Read Firebase CLI credentials
function getFirebaseCredentials() {
  const configPath = join(homedir(), '.config', 'configstore', 'firebase-tools.json');
  
  if (!existsSync(configPath)) {
    console.error('Firebase CLI not configured. Run: npx firebase login');
    return null;
  }
  
  const config = JSON.parse(readFileSync(configPath, 'utf-8'));
  return config.tokens;
}

// Refresh access token if needed
async function refreshAccessToken(refreshToken) {
  return new Promise((resolve, reject) => {
    const data = new URLSearchParams({
      client_id: '563584335869-fgrhgmd47bqnekij5i8b5pr03ho849e6.apps.googleusercontent.com',
      client_secret: 'j9iVZfS8kkCEFUPaAeJV0sAi',
      refresh_token: refreshToken,
      grant_type: 'refresh_token'
    }).toString();

    const options = {
      hostname: 'oauth2.googleapis.com',
      path: '/token',
      method: 'POST',
      headers: {
        'Content-Type': 'application/x-www-form-urlencoded',
        'Content-Length': data.length
      }
    };

    const req = https.request(options, (res) => {
      let body = '';
      res.on('data', chunk => body += chunk);
      res.on('end', () => {
        try {
          const result = JSON.parse(body);
          resolve(result.access_token);
        } catch (e) {
          reject(new Error('Failed to parse token response'));
        }
      });
    });

    req.on('error', reject);
    req.write(data);
    req.end();
  });
}

// Make authenticated API request
function apiRequest(accessToken, path) {
  return new Promise((resolve, reject) => {
    const options = {
      hostname: 'fcmregistrations.googleapis.com',
      path: path,
      method: 'GET',
      headers: {
        'Authorization': `Bearer ${accessToken}`,
        'Content-Type': 'application/json'
      }
    };

    const req = https.request(options, (res) => {
      let body = '';
      res.on('data', chunk => body += chunk);
      res.on('end', () => resolve({ status: res.statusCode, body }));
    });

    req.on('error', reject);
    req.end();
  });
}

// Generic API request helper
function makeRequest(hostname, path, accessToken, method = 'GET', body = null) {
  return new Promise((resolve, reject) => {
    const options = {
      hostname,
      path,
      method,
      headers: {
        'Authorization': `Bearer ${accessToken}`,
        'Content-Type': 'application/json'
      }
    };

    const req = https.request(options, (res) => {
      let data = '';
      res.on('data', chunk => data += chunk);
      res.on('end', () => resolve({ status: res.statusCode, body: data }));
    });

    req.on('error', reject);
    if (body) req.write(JSON.stringify(body));
    req.end();
  });
}

// Get FCM sender ID config
async function getFcmConfig(accessToken) {
  // Try the GCM/FCM sender endpoint
  const result = await makeRequest(
    'fcm.googleapis.com',
    `/v1/projects/${PROJECT_ID}/messages:send`,
    accessToken,
    'POST',
    { validate_only: true, message: { topic: 'test' } }
  );
  return result;
}

// Get web push certificates from Identity Toolkit
async function getWebPushCerts(accessToken) {
  // The web push certificates are stored in the project's FCM settings
  // We can access them via the Firebase Management API
  const result = await makeRequest(
    'firebase.googleapis.com',
    `/v1beta1/projects/${PROJECT_ID}`,
    accessToken
  );
  return result;
}

// Create a web push certificate
async function createWebPushCert(accessToken) {
  // Generate VAPID keys locally since Firebase doesn't expose an API for this
  const { execSync } = await import('child_process');
  const keysJson = execSync('npx web-push generate-vapid-keys --json', { encoding: 'utf-8' });
  const keys = JSON.parse(keysJson.trim());

  return keys;
}

// Save VAPID key to .env.local
function saveVapidKey(publicKey) {
  const envPath = '.env.local';
  let content = '';

  if (existsSync(envPath)) {
    content = readFileSync(envPath, 'utf-8');
    if (content.includes('VITE_FIREBASE_VAPID_KEY=')) {
      content = content.replace(/VITE_FIREBASE_VAPID_KEY=.*/, `VITE_FIREBASE_VAPID_KEY=${publicKey}`);
    } else {
      content += `\n# Firebase Cloud Messaging VAPID Key\nVITE_FIREBASE_VAPID_KEY=${publicKey}\n`;
    }
  } else {
    content = `# Firebase Cloud Messaging VAPID Key\nVITE_FIREBASE_VAPID_KEY=${publicKey}\n`;
  }

  writeFileSync(envPath, content.trim() + '\n');
  return envPath;
}

async function main() {
  console.log('🔑 Firebase Cloud Messaging Setup\n');
  console.log('='.repeat(50) + '\n');

  // Get stored credentials
  const creds = getFirebaseCredentials();
  if (!creds) {
    process.exit(1);
  }

  console.log('📋 Found Firebase CLI credentials');
  console.log('   Refreshing access token...\n');

  // Refresh the access token
  const accessToken = await refreshAccessToken(creds.refresh_token);
  console.log('✅ Access token refreshed\n');

  // Get project info
  console.log('🔍 Fetching project configuration...\n');
  const projectResult = await getWebPushCerts(accessToken);
  const projectData = JSON.parse(projectResult.body);
  console.log(`   Project: ${projectData.displayName || PROJECT_ID}`);
  console.log(`   Project Number: ${projectData.projectNumber || 'N/A'}\n`);

  // Generate VAPID keys
  console.log('🔑 Generating VAPID key pair...\n');
  const vapidKeys = await createWebPushCert(accessToken);
  console.log(`   Public Key: ${vapidKeys.publicKey.substring(0, 40)}...`);
  console.log('   Private Key: [GENERATED]\n');

  // Save to environment
  const envPath = saveVapidKey(vapidKeys.publicKey);
  console.log(`✅ Saved VAPID public key to ${envPath}\n`);

  // Also save private key for reference (needed for custom VAPID)
  const privateKeyPath = '.vapid-private-key';
  writeFileSync(privateKeyPath, vapidKeys.privateKey);
  console.log(`✅ Saved VAPID private key to ${privateKeyPath}\n`);

  console.log('='.repeat(50));
  console.log('\n📋 IMPORTANT NOTES:\n');
  console.log('For Firebase Cloud Messaging to work with web push, you have two options:\n');
  console.log('Option 1: Use Firebase Console VAPID Key (Recommended)');
  console.log('   1. Go to Firebase Console → Project Settings → Cloud Messaging');
  console.log('   2. Under "Web configuration", click "Generate key pair"');
  console.log('   3. Copy the generated key and update .env.local\n');
  console.log('Option 2: Use the generated VAPID key (already saved)');
  console.log('   The key has been saved to .env.local and is ready to use.\n');
  console.log('='.repeat(50) + '\n');
}

main().catch(console.error);



=================================================================================
FILE: scripts/setup-fcm.mjs
=================================================================================

#!/usr/bin/env node
/**
 * FCM Setup Script
 * 
 * This script helps configure Firebase Cloud Messaging for web push notifications.
 * It uses the Google Cloud Identity Platform API to get/create web push certificates.
 */

import { execSync } from 'child_process';
import { writeFileSync, existsSync, readFileSync } from 'fs';

const PROJECT_ID = 'insurance-news-ai';

// Get Firebase access token using the Firebase CLI
function getAccessToken() {
  try {
    // Firebase CLI stores credentials that we can use
    const result = execSync('npx firebase --json projects:list', { 
      encoding: 'utf-8',
      stdio: ['pipe', 'pipe', 'pipe']
    });
    // If this works, Firebase CLI is authenticated
    return true;
  } catch (error) {
    console.error('Firebase CLI not authenticated. Run: npx firebase login');
    return false;
  }
}

// Use Firebase CLI to make authenticated API calls
async function getWebPushCertificate() {
  console.log('🔍 Checking for existing web push certificate...\n');
  
  // The Firebase Console generates VAPID keys automatically when you enable Cloud Messaging
  // We can retrieve them via the Firebase Management REST API
  
  try {
    // Use firebase CLI to get the web app config which may include messaging config
    const configResult = execSync(
      `npx firebase apps:sdkconfig WEB --project ${PROJECT_ID}`,
      { encoding: 'utf-8', stdio: ['pipe', 'pipe', 'pipe'] }
    );
    
    console.log('📱 Firebase Web App Config retrieved successfully');
    
    // Parse the config to get messagingSenderId
    const configMatch = configResult.match(/"messagingSenderId":\s*"(\d+)"/);
    if (configMatch) {
      console.log(`   Messaging Sender ID: ${configMatch[1]}`);
    }
    
    return configMatch ? configMatch[1] : null;
  } catch (error) {
    console.error('Failed to get web app config:', error.message);
    return null;
  }
}

// Generate VAPID keys using web-push
function generateVapidKeys() {
  console.log('\n🔑 Generating VAPID key pair...\n');
  
  try {
    const result = execSync('npx web-push generate-vapid-keys --json', {
      encoding: 'utf-8',
      stdio: ['pipe', 'pipe', 'pipe']
    });
    
    const keys = JSON.parse(result.trim());
    console.log('   Public Key:', keys.publicKey.substring(0, 30) + '...');
    console.log('   Private Key: [HIDDEN]');
    
    return keys;
  } catch (error) {
    console.error('Failed to generate VAPID keys:', error.message);
    return null;
  }
}

// Create or update .env.local file
function updateEnvFile(vapidPublicKey) {
  const envPath = '.env.local';
  let envContent = '';
  
  if (existsSync(envPath)) {
    envContent = readFileSync(envPath, 'utf-8');
  }
  
  // Check if VAPID key already exists
  if (envContent.includes('VITE_FIREBASE_VAPID_KEY=')) {
    // Update existing key
    envContent = envContent.replace(
      /VITE_FIREBASE_VAPID_KEY=.*/,
      `VITE_FIREBASE_VAPID_KEY=${vapidPublicKey}`
    );
  } else {
    // Add new key
    envContent += `\n# Firebase Cloud Messaging VAPID Key\nVITE_FIREBASE_VAPID_KEY=${vapidPublicKey}\n`;
  }
  
  writeFileSync(envPath, envContent.trim() + '\n');
  console.log(`\n✅ Updated ${envPath} with VAPID public key`);
}

// Main setup function
async function main() {
  console.log('🚀 Firebase Cloud Messaging Setup\n');
  console.log('='.repeat(50) + '\n');
  
  // Check Firebase CLI authentication
  if (!getAccessToken()) {
    process.exit(1);
  }
  
  // Get messaging sender ID
  const senderId = await getWebPushCertificate();
  
  // Generate VAPID keys
  const vapidKeys = generateVapidKeys();
  
  if (vapidKeys) {
    // Update environment file
    updateEnvFile(vapidKeys.publicKey);
    
    // Save private key securely (for reference - Firebase handles this)
    console.log('\n📋 Setup Summary:');
    console.log('='.repeat(50));
    console.log(`   Project: ${PROJECT_ID}`);
    console.log(`   Sender ID: ${senderId || 'N/A'}`);
    console.log(`   VAPID Public Key: ${vapidKeys.publicKey.substring(0, 40)}...`);
    console.log('\n⚠️  IMPORTANT: For Firebase Cloud Messaging, you should use');
    console.log('   the VAPID key from Firebase Console instead of a custom one.');
    console.log('   Go to: Firebase Console → Project Settings → Cloud Messaging');
    console.log('   → Web configuration → Generate key pair\n');
  }
}

main().catch(console.error);



=================================================================================
FILE: functions/package.json
=================================================================================

{
  "name": "functions",
  "scripts": {
    "lint": "eslint --ext .js,.ts .",
    "build": "tsc",
    "build:watch": "tsc --watch",
    "serve": "npm run build && firebase emulators:start --only functions",
    "shell": "npm run build && firebase functions:shell",
    "start": "npm run shell",
    "deploy": "firebase deploy --only functions",
    "logs": "firebase functions:log",
    "seed-sources": "npm run build && node lib/scripts/seed-sources.js",
    "backfill": "npm run build && node lib/scripts/backfill-and-brief.js",
    "backfill-embeddings": "npm run build && node lib/scripts/backfill-embeddings.js",
    "check-data": "npm run build && node lib/scripts/check-data.js",
    "show-brief": "npm run build && node lib/scripts/show-brief.js",
    "regenerate-brief": "npm run build && node lib/scripts/regenerate-brief.js"
  },
  "engines": {
    "node": "22"
  },
  "main": "lib/index.js",
  "dependencies": {
    "firebase-admin": "^13.0.2",
    "firebase-functions": "^6.3.0",
    "openai": "^6.18.0",
    "rss-parser": "^3.13.0"
  },
  "devDependencies": {
    "@typescript-eslint/eslint-plugin": "^8.20.0",
    "@typescript-eslint/parser": "^8.20.0",
    "eslint": "^9.18.0",
    "firebase-functions-test": "^3.4.0",
    "globals": "^17.3.0",
    "typescript": "^5.7.3"
  },
  "private": true
}


=================================================================================
FILE: functions/tsconfig.json
=================================================================================

{
  "compilerOptions": {
    "module": "NodeNext",
    "moduleResolution": "NodeNext",
    "noImplicitReturns": true,
    "noUnusedLocals": true,
    "outDir": "lib",
    "sourceMap": true,
    "strict": true,
    "target": "ES2022",
    "skipLibCheck": true
  },
  "compileOnSave": true,
  "include": [
    "src"
  ]
}



=================================================================================
FILE: functions/eslint.config.mjs
=================================================================================

import eslint from "@eslint/js";
import tseslint from "@typescript-eslint/eslint-plugin";
import tsparser from "@typescript-eslint/parser";
import globals from "globals";

export default [
  {
    ignores: ["lib/**/*", "node_modules/**/*", "scripts/**/*"],
  },
  eslint.configs.recommended,
  {
    files: ["**/*.ts"],
    languageOptions: {
      parser: tsparser,
      parserOptions: {
        project: "./tsconfig.json",
      },
      globals: {
        ...globals.node,
      },
    },
    plugins: {
      "@typescript-eslint": tseslint,
    },
    rules: {
      ...tseslint.configs.recommended.rules,
      "quotes": ["error", "double"],
      "import/no-unresolved": "off",
    },
  },
];



=================================================================================
FILE: functions/src/config/admin.ts
=================================================================================

/**
 * Admin Configuration
 *
 * Hardcoded allowlist of admin emails for MVP.
 * In production, consider using Firebase custom claims instead.
 */

/** List of email addresses with admin privileges */
export const ADMIN_EMAILS: readonly string[] = [
  "sal.scrudato@gmail.com",
] as const;

/**
 * Check if an email is in the admin allowlist
 */
export function isAdminEmail(email: string | undefined | null): boolean {
  if (!email) return false;
  return ADMIN_EMAILS.includes(email.toLowerCase());
}



=================================================================================
FILE: functions/src/index.ts
=================================================================================

/**
 * Firebase Cloud Functions (v2)
 */

import { onRequest, onCall, HttpsError } from "firebase-functions/v2/https";
import { onSchedule } from "firebase-functions/v2/scheduler";
import { initializeApp, getApps } from "firebase-admin/app";
import { getAuth } from "firebase-admin/auth";
import { getFirestore, FieldValue, Timestamp } from "firebase-admin/firestore";
import { isAdminEmail } from "./config/admin.js";
import { ingestAllEnabledSources, fetchOgImage } from "./lib/ingestion/index.js";
import {
  ensureArticleVector,
  EMBEDDING_MODEL,
  DEFAULT_EMBEDDING_DIMS,
} from "./lib/embeddings/index.js";
import {
  getOpenAIClient,
  openaiApiKey,
  AI_MODEL,
  AI_MODEL_PREMIUM,
  ARTICLE_AI_SCHEMA,
  DAILY_BRIEF_SCHEMA,
  ARTICLE_SUMMARIZE_SYSTEM,
  DAILY_BRIEF_SYSTEM,
  buildArticleSummarizePrompt,
  buildDailyBriefPrompt,
  checkRateLimit,
  selectArticlesForBrief,
  logSelectionMetrics,
  type ArticleAIResponse,
  type DailyBriefResponse,
} from "./lib/ai/index.js";
import {
  answerQuestion,
  performRetrieval,
  streamRagAnswer,
  type RagScope,
  type ChatMessage,
} from "./lib/rag/index.js";
import {
  sendNotificationToOptedInUsers,
  formatDateForNotification,
} from "./lib/notifications/index.js";
import type { Article, Brief } from "./types/firestore.js";

// Initialize Firebase Admin
if (getApps().length === 0) {
  initializeApp();
}

const db = getFirestore();

/**
 * Health check endpoint
 * Returns { ok: true, ts: <ISO timestamp> }
 */
export const apiHealth = onRequest((req, res) => {
  res.json({
    ok: true,
    ts: new Date().toISOString(),
  });
});

// ============================================================================
// Admin Functions
// ============================================================================

interface AdminSetSourceEnabledData {
  sourceId: string;
  enabled: boolean;
}

/**
 * Admin-only callable function to enable/disable a source
 *
 * Requires:
 * - Authenticated user
 * - User email in admin allowlist
 *
 * @param sourceId - The source document ID
 * @param enabled - Whether to enable or disable the source
 */
export const adminSetSourceEnabled = onCall<AdminSetSourceEnabledData>(
  async (request) => {
    // Check authentication
    if (!request.auth) {
      throw new HttpsError(
        "unauthenticated",
        "You must be logged in to perform this action."
      );
    }

    // Check admin privileges
    const userEmail = request.auth.token.email;
    if (!isAdminEmail(userEmail)) {
      throw new HttpsError(
        "permission-denied",
        "You do not have permission to perform this action."
      );
    }

    // Validate input
    const { sourceId, enabled } = request.data;

    if (typeof sourceId !== "string" || sourceId.trim() === "") {
      throw new HttpsError(
        "invalid-argument",
        "sourceId must be a non-empty string."
      );
    }

    if (typeof enabled !== "boolean") {
      throw new HttpsError("invalid-argument", "enabled must be a boolean.");
    }

    // Check if source exists
    const sourceRef = db.collection("sources").doc(sourceId);
    const sourceDoc = await sourceRef.get();

    if (!sourceDoc.exists) {
      throw new HttpsError("not-found", `Source "${sourceId}" not found.`);
    }

    // Update the source
    await sourceRef.update({
      enabled,
      updatedAt: FieldValue.serverTimestamp(),
    });

    console.log(
      `[Admin] ${userEmail} set source "${sourceId}" enabled=${enabled}`
    );

    return {
      success: true,
      sourceId,
      enabled,
      updatedBy: userEmail,
    };
  }
);

// ============================================================================
// Scheduled RSS Ingestion
// ============================================================================

/**
 * Scheduled function that runs every 60 minutes to ingest RSS feeds.
 *
 * - Fetches all enabled sources
 * - Uses conditional GET (ETag/Last-Modified) to minimize bandwidth
 * - Parses items, filters for P&C relevance, deduplicates
 * - Stores articles in Firestore
 */
export const ingestRssFeeds = onSchedule(
  {
    schedule: "every 60 minutes",
    timeZone: "America/New_York",
    memory: "512MiB",
    timeoutSeconds: 540, // 9 minutes max
  },
  async () => {
    console.log("[ingestRssFeeds] Starting scheduled ingestion...");

    try {
      const summary = await ingestAllEnabledSources();

      // Log individual source errors
      const failedSources = summary.results.filter((r) => !r.success);
      for (const result of failedSources) {
        console.error(
          `[ingestRssFeeds] Source "${result.sourceName}" failed: ${result.error}`
        );
      }

      // Clear success/failure summary for easy log parsing
      if (failedSources.length === 0) {
        console.log(
          `[ingestRssFeeds] ✓ SUCCESS: Completed in ${summary.durationMs}ms. ` +
            `Sources: ${summary.sourcesProcessed}, ` +
            `Fetched: ${summary.totalItemsFetched}, ` +
            `Ingested: ${summary.totalItemsIngested}`
        );
      } else {
        console.log(
          `[ingestRssFeeds] ⚠ PARTIAL: ${failedSources.length}/${summary.sourcesProcessed} sources failed. ` +
            `Completed in ${summary.durationMs}ms. ` +
            `Fetched: ${summary.totalItemsFetched}, ` +
            `Ingested: ${summary.totalItemsIngested}`
        );
      }
    } catch (error) {
      console.error(
        "[ingestRssFeeds] ✗ FAILURE: Unexpected error during ingestion:",
        error instanceof Error ? error.message : error
      );
      throw error; // Re-throw so Cloud Functions marks the execution as failed
    }
  }
);

/**
 * Admin-only callable function to backfill articles from the last 7 days.
 *
 * This is intended for one-time use after initial deployment to populate
 * the database with recent articles from all enabled sources.
 */
export const adminBackfillLast7Days = onCall(
  {
    memory: "512MiB",
    timeoutSeconds: 540,
  },
  async (request) => {
    // Check authentication
    if (!request.auth) {
      throw new HttpsError(
        "unauthenticated",
        "You must be logged in to perform this action."
      );
    }

    // Check admin privileges
    const userEmail = request.auth.token.email;
    if (!isAdminEmail(userEmail)) {
      throw new HttpsError(
        "permission-denied",
        "You do not have permission to perform this action."
      );
    }

    console.log(`[adminBackfillLast7Days] Started by ${userEmail}`);

    // Run ingestion with 7-day lookback
    const summary = await ingestAllEnabledSources({
      maxAgeDays: 7,
      forceRefresh: true,
    });

    console.log(
      `[adminBackfillLast7Days] Completed in ${summary.durationMs}ms. ` +
        `Sources: ${summary.sourcesProcessed}, ` +
        `Ingested: ${summary.totalItemsIngested}`
    );

    return {
      success: true,
      startedAt: summary.startedAt.toISOString(),
      completedAt: summary.completedAt.toISOString(),
      durationMs: summary.durationMs,
      sourcesProcessed: summary.sourcesProcessed,
      totalItemsFetched: summary.totalItemsFetched,
      totalItemsIngested: summary.totalItemsIngested,
      results: summary.results.map((r) => ({
        sourceId: r.sourceId,
        sourceName: r.sourceName,
        success: r.success,
        itemsIngested: r.itemsIngested,
        itemsSkipped: r.itemsSkipped,
        itemsDuplicate: r.itemsDuplicate,
        error: r.error,
      })),
      triggeredBy: userEmail,
    };
  }
);

/**
 * HTTP endpoint to manually trigger ingestion (for testing).
 * Requires admin authentication via query parameter.
 */
export const triggerIngestion = onRequest(
  {
    memory: "512MiB",
    timeoutSeconds: 540,
  },
  async (req, res) => {
    // Simple API key check for manual triggers
    const apiKey = req.query.key;
    if (apiKey !== process.env.INGESTION_API_KEY && !process.env.FUNCTIONS_EMULATOR) {
      res.status(401).json({ error: "Unauthorized" });
      return;
    }

    console.log("[triggerIngestion] Manual ingestion triggered");

    const maxAgeDays = parseInt(req.query.days as string) || 7;

    const summary = await ingestAllEnabledSources({ maxAgeDays });

    res.json({
      success: true,
      durationMs: summary.durationMs,
      sourcesProcessed: summary.sourcesProcessed,
      totalItemsFetched: summary.totalItemsFetched,
      totalItemsIngested: summary.totalItemsIngested,
      results: summary.results,
    });
  }
);

/**
 * Admin-only callable function to backfill missing images for existing articles.
 *
 * Fetches og:image from article pages for articles that don't have an imageUrl.
 * Processes in batches to avoid timeout.
 */
export const adminBackfillMissingImages = onCall(
  {
    memory: "512MiB",
    timeoutSeconds: 540,
  },
  async (request) => {
    // Check authentication
    if (!request.auth) {
      throw new HttpsError(
        "unauthenticated",
        "You must be logged in to perform this action."
      );
    }

    const userEmail = request.auth.token.email || "";
    if (!isAdminEmail(userEmail)) {
      throw new HttpsError(
        "permission-denied",
        "Only admins can backfill images."
      );
    }

    console.log(`[adminBackfillMissingImages] Started by ${userEmail}`);

    // Get articles without images from the last 30 days
    const thirtyDaysAgo = new Date();
    thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);

    const articlesSnap = await db
      .collection("articles")
      .where("imageUrl", "==", null)
      .where("publishedAt", ">=", Timestamp.fromDate(thirtyDaysAgo))
      .limit(100) // Process in batches
      .get();

    console.log(
      `[adminBackfillMissingImages] Found ${articlesSnap.size} articles without images`
    );

    let updated = 0;
    let failed = 0;

    for (const doc of articlesSnap.docs) {
      const article = doc.data();
      const url = article.url;

      if (!url) {
        failed++;
        continue;
      }

      try {
        const imageUrl = await fetchOgImage(url);
        if (imageUrl) {
          await doc.ref.update({ imageUrl });
          updated++;
          console.log(`[adminBackfillMissingImages] Updated ${doc.id}: ${imageUrl}`);
        } else {
          failed++;
        }
      } catch (error) {
        failed++;
        console.error(`[adminBackfillMissingImages] Error for ${doc.id}:`, error);
      }
    }

    console.log(
      `[adminBackfillMissingImages] Completed. Updated: ${updated}, Failed: ${failed}`
    );

    return {
      success: true,
      articlesProcessed: articlesSnap.size,
      updated,
      failed,
      triggeredBy: userEmail,
    };
  }
);

// ============================================================================
// AI Functions
// ============================================================================

interface GetOrCreateArticleAIData {
  articleId: string;
}

/**
 * Generate or retrieve cached AI summary for an article.
 *
 * Requires authentication. Rate limited per user.
 * Uses OpenAI gpt-4o-mini with structured output.
 *
 * @param articleId - The article document ID
 * @returns AI-generated content (tldr, whyItMatters, topics, category)
 */
export const getOrCreateArticleAI = onCall<GetOrCreateArticleAIData>(
  {
    secrets: [openaiApiKey],
    memory: "256MiB",
    timeoutSeconds: 60,
  },
  async (request) => {
    // Require authentication
    if (!request.auth) {
      throw new HttpsError(
        "unauthenticated",
        "You must be logged in to use this feature."
      );
    }

    const uid = request.auth.uid;
    const { articleId } = request.data;

    // Validate input
    if (typeof articleId !== "string" || articleId.trim() === "") {
      throw new HttpsError(
        "invalid-argument",
        "articleId must be a non-empty string."
      );
    }

    // Check rate limit
    const rateLimit = await checkRateLimit(uid, "articleAI");
    if (!rateLimit.isAllowed) {
      throw new HttpsError(
        "resource-exhausted",
        `Daily limit reached. Try again tomorrow. (${rateLimit.limit} requests/day)`
      );
    }

    // Fetch article
    const articleDoc = await db.collection("articles").doc(articleId).get();
    if (!articleDoc.exists) {
      throw new HttpsError("not-found", `Article "${articleId}" not found.`);
    }

    const article = articleDoc.data() as Article;

    // Return cached AI if exists
    if (article.ai) {
      console.log(`[getOrCreateArticleAI] Returning cached AI for ${articleId}`);
      return {
        cached: true,
        ai: {
          tldr: article.ai.tldr,
          whyItMatters: article.ai.whyItMatters,
          topics: article.ai.topics,
          category: article.ai.category,
          generatedAt: article.ai.generatedAt.toDate().toISOString(),
          model: article.ai.model,
        },
        remaining: rateLimit.remaining,
      };
    }

    // Generate AI summary
    console.log(`[getOrCreateArticleAI] Generating AI for ${articleId}`);

    const openai = getOpenAIClient();

    const prompt = buildArticleSummarizePrompt({
      title: article.title,
      snippet: article.snippet,
      sourceName: article.sourceName,
      publishedAt: article.publishedAt.toDate().toISOString().split("T")[0],
      url: article.url,
    });

    const response = await openai.responses.create({
      model: AI_MODEL,
      input: [
        { role: "system", content: ARTICLE_SUMMARIZE_SYSTEM },
        { role: "user", content: prompt },
      ],
      text: {
        format: {
          type: "json_schema",
          name: "article_ai",
          schema: ARTICLE_AI_SCHEMA,
          strict: true,
        },
      },
    });

    // Parse structured output
    const outputText = response.output_text;
    let aiResult: ArticleAIResponse;
    try {
      aiResult = JSON.parse(outputText) as ArticleAIResponse;
    } catch (parseError) {
      const truncatedOutput = outputText?.slice(0, 500) ?? "(empty response)";
      console.error(
        "[getOrCreateArticleAI] Failed to parse AI response as ArticleAIResponse JSON.",
        "Expected: { tldr: string, whyItMatters: string, topics: string[], category: string }.",
        `Parse error: ${parseError instanceof Error ? parseError.message : "unknown"}`,
        `Raw response (first 500 chars): ${truncatedOutput}`
      );
      throw new HttpsError("internal", "Failed to parse AI response as valid JSON");
    }

    // Save to Firestore
    const now = Timestamp.now();
    await articleDoc.ref.update({
      ai: {
        tldr: aiResult.tldr,
        whyItMatters: aiResult.whyItMatters,
        topics: aiResult.topics,
        category: aiResult.category,
        generatedAt: now,
        model: AI_MODEL,
      },
    });

    console.log(`[getOrCreateArticleAI] Saved AI for ${articleId}`);

    return {
      cached: false,
      ai: {
        tldr: aiResult.tldr,
        whyItMatters: aiResult.whyItMatters,
        topics: aiResult.topics,
        category: aiResult.category,
        generatedAt: now.toDate().toISOString(),
        model: AI_MODEL,
      },
      remaining: rateLimit.remaining,
    };
  }
);

// ============================================================================
// Daily Brief Functions
// ============================================================================

/**
 * Get today's date in America/New_York timezone formatted as yyyy-mm-dd
 */
function getTodayDateET(): string {
  const now = new Date();
  const formatter = new Intl.DateTimeFormat("en-CA", {
    timeZone: "America/New_York",
    year: "numeric",
    month: "2-digit",
    day: "2-digit",
  });
  return formatter.format(now); // returns yyyy-mm-dd
}

/**
 * Scheduled function to generate daily brief at 6:00 AM ET
 *
 * - Fetches articles from last 24-36 hours
 * - Uses OpenAI to synthesize a brief
 * - Stores in briefs/{yyyy-mm-dd}
 * - Safe regeneration: skips if brief already exists
 */
export const generateDailyBrief = onSchedule(
  {
    schedule: "0 6 * * *", // 6:00 AM daily
    timeZone: "America/New_York",
    secrets: [openaiApiKey],
  },
  async () => {
    const dateKey = getTodayDateET();
    console.log(`[generateDailyBrief] Starting brief generation for ${dateKey}`);

    // Check if brief already exists
    const briefRef = db.collection("briefs").doc(dateKey);
    const existingBrief = await briefRef.get();

    if (existingBrief.exists) {
      console.log(`[generateDailyBrief] Brief already exists for ${dateKey}, skipping`);
      return;
    }

    // Fetch articles from last 36 hours (get more candidates for filtering)
    const cutoffTime = new Date(Date.now() - 36 * 60 * 60 * 1000);
    const articlesSnap = await db
      .collection("articles")
      .where("isRelevant", "==", true)
      .where("publishedAt", ">=", Timestamp.fromDate(cutoffTime))
      .orderBy("publishedAt", "desc")
      .limit(100) // Fetch more to allow relevance gate filtering
      .get();

    if (articlesSnap.empty) {
      console.log(`[generateDailyBrief] No relevant articles found for ${dateKey}`);
      return;
    }

    console.log(`[generateDailyBrief] Found ${articlesSnap.size} candidate articles`);

    // Apply relevance gate: prioritize by score, ensure diversity
    const rawArticles = articlesSnap.docs.map((doc) => {
      const data = doc.data() as Article;
      return { ...data, id: doc.id };
    });

    const { articles: selectedArticles, metrics } = selectArticlesForBrief(rawArticles);
    logSelectionMetrics("generateDailyBrief", metrics);

    if (selectedArticles.length === 0) {
      console.log(`[generateDailyBrief] No articles passed relevance gate for ${dateKey}`);
      return;
    }

    // Prepare article data for prompt
    const articles = selectedArticles.map((a) => ({
      id: a.id,
      title: a.title,
      sourceName: a.sourceName,
      sourceId: a.sourceId,
      snippet: a.snippet,
    }));

    // Build sources used map
    const sourceMap = new Map<string, string>();
    articles.forEach((a) => {
      if (!sourceMap.has(a.sourceId)) {
        sourceMap.set(a.sourceId, a.sourceName);
      }
    });

    // Generate brief using OpenAI
    const openai = getOpenAIClient();
    const prompt = buildDailyBriefPrompt(dateKey, articles);

    console.log("[generateDailyBrief] Calling OpenAI with premium model...");

    const response = await openai.responses.create({
      model: AI_MODEL_PREMIUM,
      input: [
        { role: "system", content: DAILY_BRIEF_SYSTEM },
        { role: "user", content: prompt },
      ],
      text: {
        format: {
          type: "json_schema",
          name: "daily_brief",
          schema: DAILY_BRIEF_SCHEMA,
          strict: true,
        },
      },
    });

    // Parse structured output
    const outputText = response.output_text;
    let briefData: DailyBriefResponse;
    try {
      briefData = JSON.parse(outputText) as DailyBriefResponse;
    } catch (parseError) {
      const truncatedOutput = outputText?.slice(0, 500) ?? "(empty response)";
      console.error(
        "[generateDailyBrief] Failed to parse AI response as DailyBriefResponse JSON.",
        "Expected: { executiveSummary, topStories, sections, signals, watchlistMentions }.",
        `Parse error: ${parseError instanceof Error ? parseError.message : "unknown"}`,
        `Raw response (first 500 chars): ${truncatedOutput}`
      );
      throw new Error("Failed to parse AI response for daily brief");
    }

    // Build the brief document
    const brief: Brief = {
      date: dateKey,
      createdAt: Timestamp.now(),
      executiveSummary: briefData.executiveSummary,
      topStories: briefData.topStories,
      sections: briefData.sections,
      topics: briefData.topics,
      sourcesUsed: Array.from(sourceMap.entries()).map(([sourceId, name]) => ({
        sourceId,
        name,
      })),
      sourceArticleIds: articles.map((a) => a.id),
      model: AI_MODEL_PREMIUM,
    };

    // Save to Firestore
    await briefRef.set(brief);

    // Send push notifications to opted-in users
    let notificationInfo = "";
    try {
      const formattedDate = formatDateForNotification(dateKey);
      const notificationResult = await sendNotificationToOptedInUsers({
        title: "Morning Brief",
        body: `Top P&C updates for ${formattedDate}`,
        data: {
          type: "daily_brief",
          date: dateKey,
        },
      });
      notificationInfo = ` Notifications: ${notificationResult.sent} sent, ${notificationResult.failed} failed.`;
    } catch (error) {
      // Don't fail the function if notifications fail
      console.error("[generateDailyBrief] Notification send error:", error);
      notificationInfo = " Notifications: failed to send.";
    }

    // Clear success log
    console.log(
      `[generateDailyBrief] ✓ SUCCESS for ${dateKey}: ` +
        `${brief.executiveSummary.length} summary items, ` +
        `${brief.topStories.length} top stories, ` +
        `${brief.topics.length} topics.${notificationInfo}`
    );
  }
);

/**
 * HTTP trigger to manually generate daily brief (for testing)
 */
export const triggerDailyBrief = onRequest(
  { secrets: [openaiApiKey] },
  async (req, res) => {
    const dateKey = (req.query.date as string) || getTodayDateET();
    console.log(`[triggerDailyBrief] Manual trigger for ${dateKey}`);

    // Check if brief already exists
    const briefRef = db.collection("briefs").doc(dateKey);
    const existingBrief = await briefRef.get();

    if (existingBrief.exists) {
      res.json({
        ok: false,
        message: `Brief already exists for ${dateKey}`,
        date: dateKey,
      });
      return;
    }

    // Fetch articles from last 36 hours (get more candidates for filtering)
    const cutoffTime = new Date(Date.now() - 36 * 60 * 60 * 1000);
    const articlesSnap = await db
      .collection("articles")
      .where("isRelevant", "==", true)
      .where("publishedAt", ">=", Timestamp.fromDate(cutoffTime))
      .orderBy("publishedAt", "desc")
      .limit(100) // Fetch more to allow relevance gate filtering
      .get();

    if (articlesSnap.empty) {
      res.json({
        ok: false,
        message: `No relevant articles found for ${dateKey}`,
        date: dateKey,
      });
      return;
    }

    console.log(`[triggerDailyBrief] Found ${articlesSnap.size} candidate articles`);

    // Apply relevance gate: prioritize by score, ensure diversity
    const rawArticles = articlesSnap.docs.map((doc) => {
      const data = doc.data() as Article;
      return { ...data, id: doc.id };
    });

    const { articles: selectedArticles, metrics } = selectArticlesForBrief(rawArticles);
    logSelectionMetrics("triggerDailyBrief", metrics);

    if (selectedArticles.length === 0) {
      res.json({
        ok: false,
        message: `No articles passed relevance gate for ${dateKey}`,
        date: dateKey,
        metrics,
      });
      return;
    }

    // Prepare article data for prompt
    const articles = selectedArticles.map((a) => ({
      id: a.id,
      title: a.title,
      sourceName: a.sourceName,
      sourceId: a.sourceId,
      snippet: a.snippet,
    }));

    // Build sources used map
    const sourceMap = new Map<string, string>();
    articles.forEach((a) => {
      if (!sourceMap.has(a.sourceId)) {
        sourceMap.set(a.sourceId, a.sourceName);
      }
    });

    // Generate brief using OpenAI with premium model
    const openai = getOpenAIClient();
    const prompt = buildDailyBriefPrompt(dateKey, articles);

    const response = await openai.responses.create({
      model: AI_MODEL_PREMIUM,
      input: [
        { role: "system", content: DAILY_BRIEF_SYSTEM },
        { role: "user", content: prompt },
      ],
      text: {
        format: {
          type: "json_schema",
          name: "daily_brief",
          schema: DAILY_BRIEF_SCHEMA,
          strict: true,
        },
      },
    });

    // Parse structured output
    const outputText = response.output_text;
    let briefData: DailyBriefResponse;
    try {
      briefData = JSON.parse(outputText) as DailyBriefResponse;
    } catch (parseError) {
      const truncatedOutput = outputText?.slice(0, 500) ?? "(empty response)";
      console.error(
        "[triggerDailyBrief] Failed to parse AI response as DailyBriefResponse JSON.",
        `Parse error: ${parseError instanceof Error ? parseError.message : "unknown"}`,
        `Raw response (first 500 chars): ${truncatedOutput}`
      );
      res.status(500).json({
        ok: false,
        message: "Failed to parse AI response as valid JSON",
        date: dateKey,
      });
      return;
    }

    // Build the brief document
    const brief: Brief = {
      date: dateKey,
      createdAt: Timestamp.now(),
      executiveSummary: briefData.executiveSummary,
      topStories: briefData.topStories,
      sections: briefData.sections,
      topics: briefData.topics,
      sourcesUsed: Array.from(sourceMap.entries()).map(([sourceId, name]) => ({
        sourceId,
        name,
      })),
      sourceArticleIds: articles.map((a) => a.id),
      model: AI_MODEL_PREMIUM,
    };

    // Save to Firestore
    await briefRef.set(brief);

    res.json({
      ok: true,
      message: `Brief created for ${dateKey}`,
      date: dateKey,
      stats: {
        summaryItems: brief.executiveSummary.length,
        topStories: brief.topStories.length,
        topics: brief.topics.length,
        articlesUsed: brief.sourceArticleIds.length,
      },
      selectionMetrics: metrics,
    });
  }
);

interface GetTodayBriefData {
  date?: string;
}

/**
 * Callable function to get today's brief with article cards
 *
 * @param date - Optional date in yyyy-mm-dd format (defaults to today ET)
 * @returns Brief with topStories populated with full article data
 */
export const getTodayBrief = onCall<GetTodayBriefData>(async (request) => {
  const { date } = request.data || {};

  // Get date key (default to today in ET)
  const dateKey = date || getTodayDateET();

  console.log(`[getTodayBrief] Fetching brief for ${dateKey}`);

  // Fetch brief
  const briefDoc = await db.collection("briefs").doc(dateKey).get();

  if (!briefDoc.exists) {
    return {
      found: false,
      date: dateKey,
      brief: null,
      topStoriesWithArticles: [],
    };
  }

  const brief = briefDoc.data() as Brief;

  // Fetch full article data for top stories
  const topStoryIds = brief.topStories.map((s) => s.articleId);
  const articleDocs = await Promise.all(
    topStoryIds.map((id) => db.collection("articles").doc(id).get())
  );

  const topStoriesWithArticles = brief.topStories.map((story, index) => {
    const articleDoc = articleDocs[index];
    if (!articleDoc.exists) {
      return {
        ...story,
        article: null,
      };
    }

    const article = articleDoc.data() as Article;
    return {
      ...story,
      article: {
        id: articleDoc.id,
        title: article.title,
        url: article.url,
        sourceName: article.sourceName,
        sourceId: article.sourceId,
        publishedAt: article.publishedAt.toDate().toISOString(),
        snippet: article.snippet,
        imageUrl: article.imageUrl || null,
      },
    };
  });

  return {
    found: true,
    date: dateKey,
    brief: {
      ...brief,
      createdAt: brief.createdAt.toDate().toISOString(),
    },
    topStoriesWithArticles,
  };
});

// ============================================================================
// Embeddings Functions
// ============================================================================

interface BackfillEmbeddingsData {
  limitPerRun?: number;
  daysBack?: number;
}

/**
 * Admin callable to backfill embeddings for articles.
 * Only processes isRelevant articles within the last N days.
 * Uses pagination to avoid timeouts.
 *
 * @param limitPerRun - Max articles to process per run (default: 100)
 * @param daysBack - How many days back to look (default: 30)
 */
export const backfillEmbeddingsLast30Days = onCall<BackfillEmbeddingsData>(
  {
    secrets: [openaiApiKey],
    memory: "512MiB",
    timeoutSeconds: 540, // 9 minutes
  },
  async (request) => {
    // Require authentication
    if (!request.auth) {
      throw new HttpsError("unauthenticated", "Must be authenticated");
    }

    // Require admin
    const userEmail = request.auth.token.email;
    if (!isAdminEmail(userEmail)) {
      throw new HttpsError("permission-denied", "Admin access required");
    }

    const limitPerRun = request.data?.limitPerRun ?? 100;
    const daysBack = request.data?.daysBack ?? 30;

    console.log("[backfillEmbeddings] Starting backfill", {
      limitPerRun,
      daysBack,
      model: EMBEDDING_MODEL,
      dims: DEFAULT_EMBEDDING_DIMS,
    });

    // Calculate cutoff date
    const cutoffDate = new Date();
    cutoffDate.setDate(cutoffDate.getDate() - daysBack);
    const cutoffTimestamp = Timestamp.fromDate(cutoffDate);

    // Query articles that are relevant and published within the time range
    // and are missing embeddings
    const articlesQuery = db
      .collection("articles")
      .where("isRelevant", "==", true)
      .where("publishedAt", ">=", cutoffTimestamp)
      .orderBy("publishedAt", "desc")
      .limit(limitPerRun * 2); // Fetch more to account for already-embedded articles

    const snapshot = await articlesQuery.get();
    console.log("[backfillEmbeddings] Found articles to check", {
      count: snapshot.size,
    });

    let processed = 0;
    let embeddingsCreated = 0;
    let searchTokensCreated = 0;
    let skipped = 0;
    let alreadyHasEmbedding = 0;

    for (const doc of snapshot.docs) {
      if (processed >= limitPerRun) break;

      const article = doc.data() as Article;

      // Skip if already has embedding
      if (article.embedding) {
        alreadyHasEmbedding++;
        continue;
      }

      try {
        const result = await ensureArticleVector(doc.id);

        if (result.skipped) {
          skipped++;
        } else {
          if (result.embeddingComputed) embeddingsCreated++;
          if (result.searchTokensComputed) searchTokensCreated++;
        }

        processed++;

        // Log progress every 10 articles
        if (processed % 10 === 0) {
          console.log("[backfillEmbeddings] Progress", {
            processed,
            embeddingsCreated,
            searchTokensCreated,
          });
        }
      } catch (error) {
        console.error("[backfillEmbeddings] Error processing article", {
          articleId: doc.id,
          error: error instanceof Error ? error.message : "Unknown error",
        });
        skipped++;
      }
    }

    console.log("[backfillEmbeddings] Completed", {
      processed,
      embeddingsCreated,
      searchTokensCreated,
      skipped,
      alreadyHasEmbedding,
    });

    return {
      success: true,
      processed,
      embeddingsCreated,
      searchTokensCreated,
      skipped,
      alreadyHasEmbedding,
      model: EMBEDDING_MODEL,
      dims: DEFAULT_EMBEDDING_DIMS,
    };
  }
);

/**
 * Scheduled function to continuously backfill embeddings.
 * Runs every 6 hours and processes up to 50 articles per run.
 */
export const runEmbeddingsBackfill = onSchedule(
  {
    schedule: "every 6 hours",
    timeZone: "America/New_York",
    memory: "512MiB",
    timeoutSeconds: 540,
    secrets: [openaiApiKey],
  },
  async () => {
    const limitPerRun = 50;
    const daysBack = 30;

    console.log("[runEmbeddingsBackfill] Starting scheduled backfill");

    const cutoffDate = new Date();
    cutoffDate.setDate(cutoffDate.getDate() - daysBack);
    const cutoffTimestamp = Timestamp.fromDate(cutoffDate);

    // Query articles missing embeddings
    const articlesQuery = db
      .collection("articles")
      .where("isRelevant", "==", true)
      .where("publishedAt", ">=", cutoffTimestamp)
      .orderBy("publishedAt", "desc")
      .limit(limitPerRun * 2);

    const snapshot = await articlesQuery.get();

    let processed = 0;
    let embeddingsCreated = 0;
    let searchTokensCreated = 0;

    for (const doc of snapshot.docs) {
      if (processed >= limitPerRun) break;

      const article = doc.data() as Article;
      if (article.embedding) continue;

      try {
        const result = await ensureArticleVector(doc.id);
        if (!result.skipped) {
          if (result.embeddingComputed) embeddingsCreated++;
          if (result.searchTokensComputed) searchTokensCreated++;
          processed++;
        }
      } catch (error) {
        console.error("[runEmbeddingsBackfill] Error", {
          articleId: doc.id,
          error: error instanceof Error ? error.message : "Unknown error",
        });
      }
    }

    console.log("[runEmbeddingsBackfill] Completed", {
      processed,
      embeddingsCreated,
      searchTokensCreated,
    });
  }
);

// ============================================================================
// RAG Chat Functions
// ============================================================================

interface AnswerQuestionRagData {
  question: string;
  scope: "today" | "7d" | "30d";
  category: string;
  sourceIds: string[] | null;
  history: Array<{ role: "user" | "assistant"; content: string }>;
}

/**
 * Answer a question using RAG (Retrieval-Augmented Generation).
 *
 * Retrieves relevant articles based on scope/category/sources,
 * reranks by semantic similarity, and generates a grounded answer
 * with citations.
 *
 * Requires authentication. Rate limited per user.
 *
 * @param question - The user's question
 * @param scope - Time window: "today" (36h), "7d", or "30d"
 * @param category - Category filter: "all" or specific category
 * @param sourceIds - Optional array of source IDs to filter by
 * @param history - Chat history (last N messages, N<=8)
 * @returns Grounded answer with citations and follow-ups
 */
export const answerQuestionRag = onCall<AnswerQuestionRagData>(
  {
    secrets: [openaiApiKey],
    memory: "512MiB",
    timeoutSeconds: 120,
  },
  async (request) => {
    // Require authentication
    if (!request.auth) {
      throw new HttpsError(
        "unauthenticated",
        "You must be logged in to use this feature."
      );
    }

    const uid = request.auth.uid;
    const { question, scope, category, sourceIds, history } = request.data;

    // Validate input
    if (typeof question !== "string" || question.trim() === "") {
      throw new HttpsError(
        "invalid-argument",
        "question must be a non-empty string."
      );
    }

    if (!["today", "7d", "30d"].includes(scope)) {
      throw new HttpsError(
        "invalid-argument",
        "scope must be 'today', '7d', or '30d'."
      );
    }

    // Check rate limit
    const rateLimit = await checkRateLimit(uid, "answerRag");
    if (!rateLimit.isAllowed) {
      throw new HttpsError(
        "resource-exhausted",
        `Daily limit reached. Try again tomorrow. (${rateLimit.limit} requests/day)`
      );
    }

    console.log("[answerQuestionRag] Processing", {
      uid,
      questionLength: question.length,
      scope,
      category,
      sourceCount: sourceIds?.length ?? "all",
      historyLength: history?.length ?? 0,
    });

    try {
      // Build scope object
      const ragScope: RagScope = {
        timeWindow: scope,
        category: category || "all",
        sourceIds: sourceIds || null,
      };

      // Sanitize history
      const chatHistory: ChatMessage[] = (history || [])
        .slice(-8)
        .filter(
          (msg): msg is ChatMessage =>
            msg &&
            typeof msg.role === "string" &&
            (msg.role === "user" || msg.role === "assistant") &&
            typeof msg.content === "string"
        );

      // Generate answer
      const answer = await answerQuestion(question, ragScope, chatHistory);

      console.log("[answerQuestionRag] Success", {
        answerLength: answer.answerMarkdown.length,
        citationCount: answer.citations.length,
        takeawayCount: answer.takeaways.length,
      });

      return {
        ...answer,
        remaining: rateLimit.remaining,
      };
    } catch (error) {
      console.error("[answerQuestionRag] Error", {
        error: error instanceof Error ? error.message : "Unknown error",
        stack: error instanceof Error ? error.stack : undefined,
      });
      throw new HttpsError(
        "internal",
        "Failed to generate answer. Please try again."
      );
    }
  }
);

// ============================================================================
// Streaming RAG Chat Function
// ============================================================================

/**
 * Streaming version of answerQuestionRag using Server-Sent Events (SSE).
 *
 * This endpoint:
 * 1. Verifies Firebase Auth token from Authorization header
 * 2. Performs retrieval (same as answerQuestionRag)
 * 3. Streams OpenAI response tokens as SSE events
 * 4. Sends a final "done" event with citations, takeaways, and followUps
 *
 * Client sends POST with JSON body:
 * {
 *   question: string,
 *   scope: "today" | "7d" | "30d",
 *   category: string,
 *   sourceIds: string[] | null,
 *   history: Array<{ role: "user" | "assistant"; content: string }>
 * }
 *
 * SSE events:
 * - data: {"text": "chunk"} - streamed text chunks
 * - event: done, data: {"citations": [...], "takeaways": [...], "followUps": [...], "answerMarkdown": "..."}
 */
export const answerQuestionRagStream = onRequest(
  {
    secrets: [openaiApiKey],
    memory: "512MiB",
    timeoutSeconds: 120,
    cors: true, // Enable CORS with default settings
  },
  async (req, res) => {
    // Handle CORS preflight
    if (req.method === "OPTIONS") {
      res.status(204).send("");
      return;
    }

    // Only allow POST
    if (req.method !== "POST") {
      res.status(405).json({ error: "Method not allowed" });
      return;
    }

    // Verify Firebase Auth token
    const authHeader = req.headers.authorization;
    if (!authHeader?.startsWith("Bearer ")) {
      res.status(401).json({ error: "Missing or invalid Authorization header" });
      return;
    }

    const token = authHeader.substring(7);
    let uid: string;

    try {
      const decodedToken = await getAuth().verifyIdToken(token);
      uid = decodedToken.uid;
    } catch (error) {
      console.error("[answerQuestionRagStream] Token verification failed:", error);
      res.status(401).json({ error: "Invalid authentication token" });
      return;
    }

    // Parse request body
    const { question, scope, category, sourceIds, history } = req.body || {};

    // Validate input
    if (typeof question !== "string" || question.trim() === "") {
      res.status(400).json({ error: "question must be a non-empty string" });
      return;
    }

    if (!["today", "7d", "30d"].includes(scope)) {
      res.status(400).json({ error: "scope must be 'today', '7d', or '30d'" });
      return;
    }

    // Check rate limit
    const rateLimit = await checkRateLimit(uid, "answerRag");
    if (!rateLimit.isAllowed) {
      res.status(429).json({
        error: `Daily limit reached. Try again tomorrow. (${rateLimit.limit} requests/day)`,
      });
      return;
    }

    console.log("[answerQuestionRagStream] Processing", {
      uid,
      questionLength: question.length,
      scope,
      category,
      sourceCount: sourceIds?.length ?? "all",
      historyLength: history?.length ?? 0,
    });

    try {
      // Build scope object
      const ragScope: RagScope = {
        timeWindow: scope,
        category: category || "all",
        sourceIds: sourceIds || null,
      };

      // Sanitize history
      const chatHistory: ChatMessage[] = (history || [])
        .slice(-8)
        .filter(
          (msg: unknown): msg is ChatMessage =>
            msg !== null &&
            typeof msg === "object" &&
            "role" in msg &&
            "content" in msg &&
            typeof (msg as ChatMessage).role === "string" &&
            ((msg as ChatMessage).role === "user" || (msg as ChatMessage).role === "assistant") &&
            typeof (msg as ChatMessage).content === "string"
        );

      // Perform retrieval
      const retrieval = await performRetrieval(question, ragScope, chatHistory);

      // Set SSE headers
      res.setHeader("Content-Type", "text/event-stream");
      res.setHeader("Cache-Control", "no-cache, no-transform");
      res.setHeader("Connection", "keep-alive");
      res.setHeader("X-Accel-Buffering", "no"); // Disable nginx buffering

      // If no results, send the fallback response as a done event
      if (retrieval.noResults && retrieval.noResultsResponse) {
        const response = retrieval.noResultsResponse;
        // Send the answer as text first
        res.write(`data: ${JSON.stringify({ text: response.answerMarkdown })}\n\n`);
        // Send done event
        res.write(`event: done\ndata: ${JSON.stringify({
          citations: response.citations,
          takeaways: response.takeaways,
          followUps: response.followUps,
          answerMarkdown: response.answerMarkdown,
        })}\n\n`);
        res.end();
        return;
      }

      // Stream the answer
      await streamRagAnswer(res, question, retrieval.context, chatHistory);

      console.log("[answerQuestionRagStream] Success");
      res.end();
    } catch (error) {
      console.error("[answerQuestionRagStream] Error", {
        error: error instanceof Error ? error.message : "Unknown error",
        stack: error instanceof Error ? error.stack : undefined,
      });

      // If headers haven't been sent yet, send error as JSON
      if (!res.headersSent) {
        res.status(500).json({ error: "Failed to generate answer. Please try again." });
      } else {
        // If streaming already started, send error as SSE event
        res.write(`event: error\ndata: ${JSON.stringify({ error: "Stream interrupted" })}\n\n`);
        res.end();
      }
    }
  }
);


=================================================================================
FILE: functions/src/lib/ai/article-selection.ts
=================================================================================

/**
 * Article Selection for Daily Brief Generation
 *
 * Implements a "relevance gate" that prioritizes articles by:
 * 1. Relevance score (higher = more relevant to P&C)
 * 2. Category diversity (ensure coverage across P&C topics, avoid market over-weighting)
 * 3. Source diversity (avoid over-representation from one source)
 *
 * Also provides logging/metrics for debugging relevance drift.
 */

import type { Article, SourceCategory } from "../../types/firestore.js";

// Minimum relevance score for inclusion in daily brief
// Raised from 0.4 to 0.5 to tighten the relevance gate
const MIN_BRIEF_RELEVANCE_SCORE = 0.5;

// Maximum articles from a single source (prevents source over-representation)
const MAX_PER_SOURCE = 6;

// Maximum total articles to send to AI
const MAX_TOTAL_ARTICLES = 35;

// Maximum articles per category to ensure diversity
// Categories that tend to be over-represented get lower caps
const MAX_PER_CATEGORY: Record<string, number> = {
  market: 6,         // M&A/earnings often flood the feed
  insurtech: 5,      // Tech news can dominate
  regulation: 8,     // Allow more regulatory coverage
  claims: 8,         // Claims/litigation important for brief
  property: 10,      // Core P&C content
  casualty: 10,      // Core P&C content
  reinsurance: 8,    // Core P&C content
  litigation: 6,     // Subset of claims-adjacent
};

// Default cap for unlisted categories
const DEFAULT_CATEGORY_CAP = 8;

/**
 * Article with selection metadata
 */
interface ArticleWithMeta {
  id: string;
  title: string;
  sourceName: string;
  sourceId: string;
  snippet: string;
  relevanceScore: number;
  categories: SourceCategory[];
}

/**
 * Selection metrics for logging
 */
export interface SelectionMetrics {
  totalCandidates: number;
  filteredByScore: number;
  filteredByCategory: number;
  filteredBySource: number;
  selectedCount: number;
  categoryDistribution: Record<string, number>;
  sourceDistribution: Record<string, number>;
  avgRelevanceScore: number;
  minRelevanceScore: number;
  maxRelevanceScore: number;
  configUsed: {
    minScore: number;
    maxPerSource: number;
    maxTotal: number;
  };
}

/**
 * Get the primary category for an article (first category or 'uncategorized')
 */
function getPrimaryCategory(categories: SourceCategory[]): string {
  return categories.length > 0 ? categories[0] : "uncategorized";
}

/**
 * Check if adding an article would exceed category cap
 */
function wouldExceedCategoryCap(
  categories: SourceCategory[],
  categoryCount: Record<string, number>
): boolean {
  const primary = getPrimaryCategory(categories);
  const cap = MAX_PER_CATEGORY[primary] ?? DEFAULT_CATEGORY_CAP;
  const current = categoryCount[primary] || 0;
  return current >= cap;
}

/**
 * Select and prioritize articles for daily brief generation.
 *
 * Applies relevance gate and ensures diversity across categories and sources.
 *
 * @param rawArticles - Articles fetched from Firestore
 * @returns Selected articles for brief generation and metrics for logging
 */
export function selectArticlesForBrief(
  rawArticles: Article[]
): { articles: ArticleWithMeta[]; metrics: SelectionMetrics } {
  // Convert to selection format
  const candidates: ArticleWithMeta[] = rawArticles.map((a) => ({
    id: a.id,
    title: a.title,
    sourceName: a.sourceName,
    sourceId: a.sourceId,
    snippet: a.snippet,
    relevanceScore: a.relevanceScore,
    categories: a.categories,
  }));

  const totalCandidates = candidates.length;

  // Step 1: Filter by minimum relevance score (relevance gate)
  const highRelevance = candidates.filter(
    (a) => a.relevanceScore >= MIN_BRIEF_RELEVANCE_SCORE
  );
  const filteredByScore = totalCandidates - highRelevance.length;

  // Step 2: Sort by relevance score (descending)
  highRelevance.sort((a, b) => b.relevanceScore - a.relevanceScore);

  // Step 3: Apply diversity constraints (source + category caps)
  const selected: ArticleWithMeta[] = [];
  const categoryCount: Record<string, number> = {};
  const sourceCount: Record<string, number> = {};
  let filteredByCategory = 0;
  let filteredBySource = 0;

  for (const article of highRelevance) {
    if (selected.length >= MAX_TOTAL_ARTICLES) break;

    // Check source limit
    const srcCount = sourceCount[article.sourceId] || 0;
    if (srcCount >= MAX_PER_SOURCE) {
      filteredBySource++;
      continue;
    }

    // Check category limit (prevents market/insurtech from dominating)
    if (wouldExceedCategoryCap(article.categories, categoryCount)) {
      filteredByCategory++;
      continue;
    }

    // Add article
    selected.push(article);
    sourceCount[article.sourceId] = srcCount + 1;

    // Track category distribution (primary category only for caps)
    const primary = getPrimaryCategory(article.categories);
    categoryCount[primary] = (categoryCount[primary] || 0) + 1;
  }

  // Step 4: Compute metrics
  const relevanceScores = selected.map((a) => a.relevanceScore);
  const avgScore = relevanceScores.length > 0
    ? relevanceScores.reduce((sum, s) => sum + s, 0) / relevanceScores.length
    : 0;

  const metrics: SelectionMetrics = {
    totalCandidates,
    filteredByScore,
    filteredByCategory,
    filteredBySource,
    selectedCount: selected.length,
    categoryDistribution: categoryCount,
    sourceDistribution: sourceCount,
    avgRelevanceScore: Math.round(avgScore * 100) / 100,
    minRelevanceScore: relevanceScores.length > 0 ? Math.min(...relevanceScores) : 0,
    maxRelevanceScore: relevanceScores.length > 0 ? Math.max(...relevanceScores) : 0,
    configUsed: {
      minScore: MIN_BRIEF_RELEVANCE_SCORE,
      maxPerSource: MAX_PER_SOURCE,
      maxTotal: MAX_TOTAL_ARTICLES,
    },
  };

  return { articles: selected, metrics };
}

/**
 * Log selection metrics for debugging relevance drift
 */
export function logSelectionMetrics(prefix: string, metrics: SelectionMetrics): void {
  console.log(`[${prefix}] Article selection metrics:`);
  console.log(`  Config: minScore=${metrics.configUsed.minScore}, maxPerSource=${metrics.configUsed.maxPerSource}, maxTotal=${metrics.configUsed.maxTotal}`);
  console.log(`  Pipeline: ${metrics.totalCandidates} candidates → ${metrics.filteredByScore} filtered (score) → ${metrics.filteredByCategory} filtered (category cap) → ${metrics.filteredBySource} filtered (source cap) → ${metrics.selectedCount} selected`);
  console.log(`  Relevance: avg=${metrics.avgRelevanceScore}, min=${metrics.minRelevanceScore}, max=${metrics.maxRelevanceScore}`);
  console.log(`  Categories: ${JSON.stringify(metrics.categoryDistribution)}`);
  console.log(`  Sources: ${JSON.stringify(metrics.sourceDistribution)}`);
}



=================================================================================
FILE: functions/src/lib/ai/index.ts
=================================================================================

/**
 * AI Module Exports
 */

export {
  getOpenAIClient,
  openaiApiKey,
  AI_MODEL,
  AI_MODEL_PREMIUM,
  ARTICLE_AI_SCHEMA,
  DAILY_BRIEF_SCHEMA,
  RAG_ANSWER_SCHEMA,
  type ArticleAIResponse,
  type DailyBriefResponse,
  type RagAnswerResponse,
  type RagCitation,
} from "./openai-client.js";

export {
  ARTICLE_SUMMARIZE_SYSTEM,
  DAILY_BRIEF_SYSTEM,
  buildArticleSummarizePrompt,
  buildDailyBriefPrompt,
} from "./prompts.js";

export {
  RATE_LIMITS,
  checkRateLimit,
  getRateLimitStatus,
} from "./rate-limit.js";

export {
  selectArticlesForBrief,
  logSelectionMetrics,
  type SelectionMetrics,
} from "./article-selection.js";


=================================================================================
FILE: functions/src/lib/ai/openai-client.ts
=================================================================================

/**
 * OpenAI Client Wrapper
 *
 * Uses the official OpenAI SDK with Responses API for:
 * - Article summarization and classification
 * - Grounded Q&A using daily brief context
 */

import OpenAI from "openai";
import { defineSecret } from "firebase-functions/params";

// Define the secret (accessed at runtime)
export const openaiApiKey = defineSecret("OPENAI_API_KEY");

// Lazy-initialized client
let _client: OpenAI | null = null;

/**
 * Get the OpenAI client instance.
 * Must be called within a function that has access to the secret.
 */
export function getOpenAIClient(): OpenAI {
  if (!_client) {
    const apiKey = openaiApiKey.value();
    if (!apiKey) {
      throw new Error("OPENAI_API_KEY secret is not configured");
    }
    _client = new OpenAI({ apiKey });
  }
  return _client;
}

/**
 * Model configuration for AI operations.
 * - gpt-4o: Higher quality for critical content (daily briefs)
 * - gpt-4o-mini: Cost-efficient for high-volume operations (article summaries)
 */
export const AI_MODEL = "gpt-4o-mini";
export const AI_MODEL_PREMIUM = "gpt-4o";

/**
 * Article AI response structure
 */
export interface ArticleAIResponse {
  tldr: string;
  whyItMatters: string;
  topics: string[];
  category: string;
}

/**
 * JSON schema for article AI structured output
 */
export const ARTICLE_AI_SCHEMA = {
  type: "object" as const,
  properties: {
    tldr: {
      type: "string",
      description: "2-3 sentence executive summary of the article",
    },
    whyItMatters: {
      type: "string",
      description: "1-2 sentences on why this matters for P&C insurance professionals",
    },
    topics: {
      type: "array",
      items: { type: "string" },
      description: "2-4 relevant topics (e.g., 'auto insurance', 'catastrophe losses', 'rate increases')",
    },
    category: {
      type: "string",
      enum: ["property", "casualty", "reinsurance", "regulation", "claims", "insurtech", "market", "litigation"],
      description: "Primary category for the article",
    },
  },
  required: ["tldr", "whyItMatters", "topics", "category"],
  additionalProperties: false,
};

/**
 * Daily brief response structure
 */
export interface DailyBriefResponse {
  executiveSummary: string[];
  topStories: Array<{
    articleId: string;
    headline: string;
    whyItMatters: string;
  }>;
  sections: {
    propertyCat: { bullets: string[]; articleIds: string[] };
    casualtyLiability: { bullets: string[]; articleIds: string[] };
    regulation: { bullets: string[]; articleIds: string[] };
    claims: { bullets: string[]; articleIds: string[] };
    reinsurance: { bullets: string[]; articleIds: string[] };
    insurtech: { bullets: string[]; articleIds: string[] };
    market: { bullets: string[]; articleIds: string[] };
  };
  topics: string[];
}

const SECTION_SCHEMA = {
  type: "object" as const,
  properties: {
    bullets: {
      type: "array",
      items: { type: "string" },
      description: "2-4 bullet points for this section",
    },
    articleIds: {
      type: "array",
      items: { type: "string" },
      description: "Article IDs related to this section",
    },
  },
  required: ["bullets", "articleIds"],
  additionalProperties: false,
};

/**
 * JSON schema for daily brief structured output
 */
export const DAILY_BRIEF_SCHEMA = {
  type: "object" as const,
  properties: {
    executiveSummary: {
      type: "array",
      items: { type: "string" },
      description: "3-5 bullet points summarizing the most important developments",
    },
    topStories: {
      type: "array",
      items: {
        type: "object",
        properties: {
          articleId: { type: "string", description: "The article ID" },
          headline: { type: "string", description: "Synthesized headline (not copied)" },
          whyItMatters: { type: "string", description: "1-2 sentences on implications" },
        },
        required: ["articleId", "headline", "whyItMatters"],
        additionalProperties: false,
      },
      description: "3-5 top stories",
    },
    sections: {
      type: "object",
      properties: {
        propertyCat: SECTION_SCHEMA,
        casualtyLiability: SECTION_SCHEMA,
        regulation: SECTION_SCHEMA,
        claims: SECTION_SCHEMA,
        reinsurance: SECTION_SCHEMA,
        insurtech: SECTION_SCHEMA,
        market: SECTION_SCHEMA,
      },
      required: ["propertyCat", "casualtyLiability", "regulation", "claims", "reinsurance", "insurtech", "market"],
      additionalProperties: false,
    },
    topics: {
      type: "array",
      items: { type: "string" },
      description: "5-10 key topics covered",
    },
  },
  required: ["executiveSummary", "topStories", "sections", "topics"],
  additionalProperties: false,
};

// ============================================================================
// RAG Answer Types and Schema
// ============================================================================

/**
 * RAG answer citation
 */
export interface RagCitation {
  articleId: string;
  title: string;
  sourceName: string;
  url: string;
  publishedAt: string;
}

/**
 * RAG answer response structure
 */
export interface RagAnswerResponse {
  answerMarkdown: string;
  takeaways: string[];
  citations: RagCitation[];
  followUps: string[];
}

/**
 * JSON schema for RAG answer structured output
 */
export const RAG_ANSWER_SCHEMA = {
  type: "object" as const,
  properties: {
    answerMarkdown: {
      type: "string",
      description: "The answer in markdown format with inline citations [1], [2], etc.",
    },
    takeaways: {
      type: "array",
      items: { type: "string" },
      description: "3-6 key takeaway bullet points",
    },
    citations: {
      type: "array",
      items: {
        type: "object",
        properties: {
          articleId: { type: "string", description: "The article ID" },
          title: { type: "string", description: "Article title" },
          sourceName: { type: "string", description: "Source name" },
          url: { type: "string", description: "Article URL" },
          publishedAt: { type: "string", description: "Publication date" },
        },
        required: ["articleId", "title", "sourceName", "url", "publishedAt"],
        additionalProperties: false,
      },
      description: "List of cited articles",
    },
    followUps: {
      type: "array",
      items: { type: "string" },
      description: "3 suggested follow-up questions",
    },
  },
  required: ["answerMarkdown", "takeaways", "citations", "followUps"],
  additionalProperties: false,
};



=================================================================================
FILE: functions/src/lib/ai/prompts.ts
=================================================================================

/**
 * Prompt Templates for AI Operations
 *
 * Executive brief style: concise, deterministic, P&C-focused.
 * Optimized for P&C insurance professionals including underwriters,
 * claims managers, actuaries, and C-suite executives.
 */

/**
 * System prompt for article summarization
 */
export const ARTICLE_SUMMARIZE_SYSTEM = `You are an expert P&C (Property & Casualty) insurance analyst providing executive-level intelligence to industry professionals.

Your audience includes:
- Chief Underwriting Officers and underwriters evaluating risk appetite
- Claims executives monitoring litigation trends and loss developments
- Actuaries tracking loss cost trends and reserve adequacy
- C-suite executives making strategic portfolio decisions
- Reinsurance professionals assessing capacity and pricing

CRITICAL REQUIREMENTS:

1. P&C Insurance Angle (MANDATORY):
   Every summary MUST explicitly connect to one or more P&C disciplines:
   - UNDERWRITING: Risk selection, pricing, appetite, portfolio management, loss trends by line
   - CLAIMS: Litigation exposure, settlement trends, reserve implications, social inflation, nuclear verdicts
   - REINSURANCE: Capacity, treaty pricing, retrocession, cat bond implications, 1/1 renewals
   - REGULATION: Compliance requirements, rate filing impacts, market access, NAIC actions
   - DISTRIBUTION: Broker/MGA dynamics, channel strategy, commission structures, E&S growth

2. Relevance Assessment (STRICT):
   - DIRECTLY relevant (core P&C topic): Provide full analysis with specific line-of-business impact
   - INDIRECTLY relevant (tangential but material): State "Indirect P&C relevance: [explain specific connection to underwriting, claims, or reinsurance]"
   - WEAK/PERIPHERAL relevance: whyItMatters MUST begin with "Peripheral relevance to P&C. Monitor if [specific quantifiable trigger]." Examples:
     * "Peripheral relevance to P&C. Monitor if proposed legislation advances to committee vote, potentially affecting D&O exposures."
     * "Peripheral relevance to P&C. Monitor if supply chain disruptions increase auto parts costs by >5%, impacting claims severity."
     * "Peripheral relevance to P&C. General tech news with no direct carrier impact unless platform reaches >10% market adoption."

3. Quality Standards:
   - Be concise, precise, and actionable. Every sentence must add value.
   - Use P&C terminology correctly: combined ratio, loss ratio, rate adequacy, social inflation, nuclear verdicts, cat losses, treaty renewals, etc.
   - Quantify impacts when possible (rate changes, loss amounts, market share).
   - Identify implications for underwriting strategy, claims management, or capital allocation.
   - Note regulatory, legal, or market signals that could affect future performance.
   - Maintain professional, objective tone - no speculation without basis.

4. Hard Exclusions (DO NOT analyze these unless explicit insurance angle):
   - Generic political news, election coverage, or partisan commentary
   - General technology trends without specific carrier/MGA adoption news
   - Macroeconomic commentary without explicit loss cost or investment income linkage
   - Corporate news about non-insurance companies without liability/coverage implications
   - Cryptocurrency, AI hype, or tech industry drama unrelated to insurtech adoption`;

/**
 * Build user prompt for article summarization
 */
export function buildArticleSummarizePrompt(article: {
  title: string;
  snippet: string;
  sourceName: string;
  publishedAt: string;
  url: string;
}): string {
  return `Analyze this P&C insurance news article for executive consumption:

ARTICLE:
Title: ${article.title}
Source: ${article.sourceName}
Published: ${article.publishedAt}
URL: ${article.url}

Content:
${article.snippet}

REQUIRED OUTPUT:

1. tldr: Executive summary (2-3 sentences). Lead with the key fact or development. Include specific numbers, names, or dates when available. End with the strategic implication for P&C insurers.

2. whyItMatters: Business impact statement (1-2 sentences). MUST explicitly address P&C impact:
   - STRONG relevance: Explain specific impact on underwriting, claims, reinsurance, regulation, or distribution. Name the affected line(s) of business.
   - PERIPHERAL relevance: MUST begin with "Peripheral relevance to P&C. Monitor if [specific trigger condition]." Be explicit about what would make this story material.

   Examples of peripheral relevance:
   - "Peripheral relevance to P&C. Monitor if tariff legislation passes, potentially increasing commercial auto claims severity via parts costs."
   - "Peripheral relevance to P&C. General AI news with no direct carrier impact; relevant only if >3 top-20 carriers announce platform adoption."
   - "Peripheral relevance to P&C. Monitor if storm intensifies to Cat 3+, triggering property cat exposure in Gulf states."

3. topics: 2-4 P&C-native topic tags. Use ONLY industry-standard terminology:

   PREFERRED (use these):
   - Lines of business: "commercial auto", "personal auto", "homeowners", "commercial property", "general liability", "D&O", "E&O", "cyber liability", "workers compensation", "umbrella/excess", "marine", "aviation"
   - Perils/loss drivers: "hurricane", "wildfire", "convective storm", "flood", "social inflation", "nuclear verdicts", "attorney involvement", "litigation funding"
   - Market dynamics: "rate hardening", "rate adequacy", "capacity constraints", "E&S growth", "carrier M&A", "MGA consolidation", "1/1 renewals", "treaty pricing"
   - Regulatory: "NAIC", "state DOI", "rate filing", "climate disclosure", "admitted market", "surplus lines"
   - Reinsurance: "property cat", "casualty treaty", "ILS", "cat bonds", "retrocession", "aggregate covers"

   AVOID (too generic):
   - "insurance" (too broad), "technology" (use "insurtech" or specific tech), "economy" (use specific impact), "politics" (unless specific legislation)

4. category: Primary category - choose the single best fit:
   - property: Property insurance, catastrophe, nat cat, homeowners, commercial property
   - casualty: Liability, auto, workers comp, professional liability, umbrella
   - reinsurance: Treaty, facultative, ILS, retrocession, cat bonds
   - regulation: Regulatory actions, compliance, legislation, rate filings
   - claims: Litigation, settlements, loss trends, reserves, social inflation
   - insurtech: Technology adoption by carriers/MGAs, digital transformation, AI/ML in underwriting
   - market: M&A, financials, earnings, market share, competitive dynamics
   - litigation: Court decisions, class actions, coverage disputes, bad faith`;
}

/**
 * Format brief for context
 */
export function formatBriefContext(brief: {
  executiveSummary: string[];
  topStories: Array<{ headline: string; whyItMatters: string }>;
}): string {
  const summary = brief.executiveSummary.map((s, i) => `${i + 1}. ${s}`).join("\n");
  const stories = brief.topStories
    .map((s) => `- ${s.headline}: ${s.whyItMatters}`)
    .join("\n");

  return `Executive Summary:
${summary}

Top Stories:
${stories}`;
}

/**
 * Format articles for context
 */
export function formatArticlesContext(
  articles: Array<{
    id: string;
    title: string;
    sourceName: string;
    snippet: string;
    ai?: { tldr?: string } | null;
  }>
): string {
  return articles
    .map((a) => {
      const summary = a.ai?.tldr || a.snippet;
      return `[${a.id}] ${a.title} (${a.sourceName})
${summary}`;
    })
    .join("\n\n");
}

// ============================================================================
// Daily Brief Generation
// ============================================================================

/**
 * System prompt for daily brief generation
 */
export const DAILY_BRIEF_SYSTEM = `You are a senior P&C insurance industry analyst creating the definitive daily executive brief for insurance professionals.

Your audience includes CUOs, claims executives, actuaries, reinsurance professionals, and C-suite leaders who need to stay informed on industry developments that affect their business decisions.

CRITICAL GUIDELINES:

=== P&C RELEVANCE GATE (MANDATORY - STRICT ENFORCEMENT) ===

INCLUDE ONLY if the story has EXPLICIT impact on one or more of:
1. UNDERWRITING: Risk selection, pricing, appetite changes, loss trend data, portfolio actions, rate filings
2. CLAIMS: Litigation outcomes, settlement trends, reserve developments, social inflation data, nuclear verdicts
3. REINSURANCE: Treaty pricing, capacity changes, cat losses, ILS issuance, retrocession market, 1/1 renewals
4. REGULATION: DOI actions, NAIC developments, legislation with insurance provisions, compliance requirements
5. DISTRIBUTION: Broker/MGA M&A, commission changes, channel dynamics, E&S market shifts

EXCLUDE (even if article mentions insurance tangentially):
- Generic political news without specific insurance legislation or regulatory action
- Technology trends without confirmed carrier/MGA adoption or investment
- Economic commentary without quantified impact on loss costs, investment income, or reserve adequacy
- Corporate news about non-insurance companies unless there is explicit liability, D&O, or coverage angle
- Weather updates without insured loss estimates or cat exposure data
- Startup funding rounds without clear product-market fit with carriers

TEST: Before including any story, ask: "Can I name the specific P&C line of business, carrier function, or financial metric affected?" If no → OMIT.

=== INSURANCE ANGLE FRAMING ===

- Frame every development through P&C lens: "What does this mean for carriers/MGAs/brokers/reinsurers?"
- Name the affected lines of business explicitly (commercial auto, D&O, homeowners, workers comp, etc.)
- Note implications for specific functions: underwriting appetite, claims reserves, treaty pricing, rate adequacy
- Quantify when possible: loss amounts, rate changes, market share impacts

=== CONTENT QUALITY ===

- Synthesize and analyze - NEVER copy article text verbatim
- Lead with impact: What happened? Why does it matter? What should leaders consider?
- Include specific numbers, percentages, dollar amounts, and names when available
- Connect dots between related developments across articles
- Identify emerging patterns and trends

=== INDUSTRY EXPERTISE ===

- Use correct P&C terminology: combined ratio, loss ratio, rate adequacy, social inflation, nuclear verdicts, cat losses, treaty renewals, capacity, attachment points, etc.
- Understand the difference between admitted/E&S markets, primary/excess layers, treaty/facultative reinsurance
- Recognize implications for different stakeholders (carriers, MGAs, brokers, reinsurers)

=== PRIORITIZATION ===

Tier 1 (Lead stories):
- Major cat events with insured loss estimates
- Significant carrier earnings/reserve actions
- Precedent-setting litigation outcomes
- Major M&A in carrier/reinsurer/MGA space
- Material regulatory changes (rate actions, market access)

Tier 2 (Supporting coverage):
- Line-of-business rate trend data
- Treaty renewal pricing signals
- Claims severity/frequency developments
- Technology adoption by top-20 carriers

Tier 3 (Omit unless exceptional):
- General tech announcements
- Political news without insurance legislation
- Macroeconomic commentary without explicit P&C linkage

=== TONE ===

- Executive-level professionalism
- Objective and factual - no speculation without basis
- Actionable insights over passive reporting
- On thin-news days, quality over quantity - a shorter brief is better than a padded one`;

/**
 * Build user prompt for daily brief generation
 */
export function buildDailyBriefPrompt(
  date: string,
  articles: Array<{
    id: string;
    title: string;
    sourceName: string;
    snippet: string;
  }>
): string {
  const articlesText = articles
    .map((a) => `[${a.id}] ${a.title} (${a.sourceName})\n${a.snippet}`)
    .join("\n\n");

  return `Create the daily P&C insurance executive brief for ${date}.

=== REMINDER: STRICT P&C RELEVANCE ===
Before including ANY content, verify it passes the P&C test:
- Does it explicitly affect underwriting, claims, reinsurance, regulation, or distribution?
- Can you name the specific line of business or carrier function impacted?
- If the answer to either is "no" → OMIT the article from the brief.

On thin-news days: A shorter, focused brief is better than padding with peripheral content.

=== SOURCE ARTICLES ===
${articlesText}

=== BRIEF STRUCTURE ===

1. executiveSummary (3-5 bullets, fewer on light days):
   - Lead with the single most important P&C development
   - Each bullet MUST reference a specific carrier action, market metric, or regulatory change
   - Include specifics: company names, dollar amounts, percentages, lines of business
   - Diversify across property, casualty, reinsurance (don't cluster on market/M&A)
   - Format: "[Key development] — [Specific implication for underwriting/claims/capital]"

2. topStories (3-5 stories, only those passing P&C relevance test):
   - articleId: The source article ID (from brackets above)
   - headline: Synthesized headline emphasizing the P&C angle (NOT copied from article)
   - whyItMatters: 1-2 sentences stating WHO is affected (carriers, MGAs, reinsurers, specific LOBs) and HOW (pricing, reserves, capacity, compliance)

3. sections (2-4 bullets each, with articleIds - LEAVE EMPTY if no qualifying articles):
   - propertyCat: Cat events with loss estimates, homeowners market actions, commercial property rate trends
   - casualtyLiability: Auto severity, GL/umbrella capacity, professional liability, workers comp
   - regulation: DOI orders, NAIC actions, rate filings, compliance deadlines
   - claims: Verdicts, settlements, reserve strengthening, social inflation data
   - reinsurance: Treaty pricing, capacity signals, ILS issuance, retro market
   - insurtech: Carrier technology investments, MGA platform adoptions (NOT general tech)
   - market: Carrier M&A, earnings with combined ratio data, meaningful market share shifts

4. topics (5-10 P&C-native tags):
   - Use industry-standard terms: line names, perils, market dynamics
   - Include carrier names for major stories
   - Include geography for regional events
   - Good: "Florida homeowners", "commercial auto severity", "D&O capacity", "1/1 renewals", "nuclear verdicts"
   - Avoid: "technology", "economy", "politics" (too generic)

CRITICAL: If a section has no articles that pass the P&C relevance test, return an empty bullets array. Quality over quantity.`;
}



=================================================================================
FILE: functions/src/lib/ai/rate-limit.ts
=================================================================================

/**
 * Rate Limiting Utility
 *
 * Per-UID daily rate limiting using Firestore counters.
 * Relatively loose limits for MVP.
 */

import { getFirestore, FieldValue, Timestamp } from "firebase-admin/firestore";

/**
 * Rate limit configuration
 */
export const RATE_LIMITS = {
  /** Max article AI requests per user per day */
  articleAI: 50,
  /** Max askToday requests per user per day */
  askToday: 30,
  /** Max RAG chat requests per user per day */
  answerRag: 30,
} as const;

type RateLimitType = keyof typeof RATE_LIMITS;

/**
 * Get the current date key in yyyy-mm-dd format
 */
function getDateKey(): string {
  return new Date().toISOString().split("T")[0];
}

/**
 * Check and increment rate limit for a user.
 *
 * @param uid - User ID
 * @param type - Rate limit type
 * @returns Object with isAllowed and remaining count
 */
export async function checkRateLimit(
  uid: string,
  type: RateLimitType
): Promise<{ isAllowed: boolean; remaining: number; limit: number }> {
  const db = getFirestore();
  const dateKey = getDateKey();
  const limit = RATE_LIMITS[type];

  // Rate limit doc: users/{uid}/rateLimits/{date}
  const rateLimitRef = db
    .collection("users")
    .doc(uid)
    .collection("rateLimits")
    .doc(dateKey);

  // Use transaction to atomically check and increment
  const result = await db.runTransaction(async (transaction) => {
    const doc = await transaction.get(rateLimitRef);

    let counts: Record<string, number> = {};

    if (doc.exists) {
      counts = doc.data() as Record<string, number>;
    }

    const currentCount = counts[type] || 0;

    if (currentCount >= limit) {
      return {
        isAllowed: false,
        remaining: 0,
        limit,
      };
    }

    // Increment the counter
    transaction.set(
      rateLimitRef,
      {
        [type]: FieldValue.increment(1),
        updatedAt: Timestamp.now(),
      },
      { merge: true }
    );

    return {
      isAllowed: true,
      remaining: limit - currentCount - 1,
      limit,
    };
  });

  return result;
}

/**
 * Get current rate limit status without incrementing.
 *
 * @param uid - User ID
 * @param type - Rate limit type
 * @returns Object with current count and limit
 */
export async function getRateLimitStatus(
  uid: string,
  type: RateLimitType
): Promise<{ current: number; limit: number; remaining: number }> {
  const db = getFirestore();
  const dateKey = getDateKey();
  const limit = RATE_LIMITS[type];

  const rateLimitRef = db
    .collection("users")
    .doc(uid)
    .collection("rateLimits")
    .doc(dateKey);

  const doc = await rateLimitRef.get();

  if (!doc.exists) {
    return { current: 0, limit, remaining: limit };
  }

  const counts = doc.data() as Record<string, number>;
  const current = counts[type] || 0;

  return {
    current,
    limit,
    remaining: Math.max(0, limit - current),
  };
}



=================================================================================
FILE: functions/src/lib/embeddings/index.ts
=================================================================================

/**
 * Embeddings Module
 *
 * Provides vector embeddings for articles using OpenAI's text-embedding-3-small model.
 * Uses reduced dimensions (256) to keep Firestore document sizes small.
 */

import { getFirestore, Timestamp } from "firebase-admin/firestore";
import * as logger from "firebase-functions/logger";
import { getOpenAIClient } from "../ai/openai-client.js";
import type { Article, ArticleEmbedding } from "../../types/firestore.js";

// ============================================================================
// Constants
// ============================================================================

/** Default embedding model */
export const EMBEDDING_MODEL = "text-embedding-3-small";

/** Default embedding dimensions (reduced from 1536 default to save storage) */
export const DEFAULT_EMBEDDING_DIMS = 256;

/** Stopwords to filter from search tokens */
const STOPWORDS = new Set([
  "a", "an", "and", "are", "as", "at", "be", "by", "for", "from",
  "has", "have", "he", "in", "is", "it", "its", "of", "on", "or",
  "that", "the", "to", "was", "were", "will", "with", "this", "their",
  "they", "but", "not", "what", "who", "which", "when", "where", "how",
  "all", "been", "being", "had", "her", "him", "his", "more", "new",
  "one", "our", "out", "said", "she", "some", "than", "them", "then",
  "there", "these", "we", "you", "your", "can", "could", "into", "may",
  "no", "so", "up", "very", "would", "about", "after", "also", "any",
  "back", "because", "do", "first", "get", "go", "just", "know", "like",
  "make", "most", "now", "only", "other", "over", "see", "such", "take",
  "through", "two", "way", "well", "work", "year", "years",
]);

// ============================================================================
// Embedding Functions
// ============================================================================

/**
 * Generate an embedding for the given text using OpenAI's embedding API.
 *
 * @param text - The text to embed
 * @param dims - Number of dimensions for the embedding (default: 256)
 * @returns The embedding vector
 */
export async function embedText(
  text: string,
  dims: number = DEFAULT_EMBEDDING_DIMS
): Promise<number[]> {
  const openai = getOpenAIClient();

  const response = await openai.embeddings.create({
    model: EMBEDDING_MODEL,
    input: text,
    dimensions: dims,
  });

  return response.data[0].embedding;
}

/**
 * Generate search tokens from article content.
 * Used for lexical narrowing before semantic search.
 *
 * @param article - The article to generate tokens from
 * @returns Array of lowercase tokens
 */
export function generateSearchTokens(article: {
  title: string;
  snippet: string;
  ai?: { topics?: string[] } | null;
}): string[] {
  const text = [
    article.title,
    article.snippet,
    ...(article.ai?.topics || []),
  ].join(" ");

  // Tokenize: lowercase, split on non-word characters, filter
  const tokens = text
    .toLowerCase()
    .split(/[^a-z0-9]+/)
    .filter((token) => {
      // Must be at least 2 characters
      if (token.length < 2) return false;
      // Must not be a stopword
      if (STOPWORDS.has(token)) return false;
      // Must not be purely numeric
      if (/^\d+$/.test(token)) return false;
      return true;
    });

  // Deduplicate and limit
  const uniqueTokens = [...new Set(tokens)];
  return uniqueTokens.slice(0, 50); // Limit to 50 tokens
}

/**
 * Ensure an article has both embedding and searchTokens.
 * Computes and stores them if missing.
 *
 * @param articleId - The article document ID
 * @returns Object indicating what was computed
 */
export async function ensureArticleVector(articleId: string): Promise<{
  embeddingComputed: boolean;
  searchTokensComputed: boolean;
  skipped: boolean;
  reason?: string;
}> {
  const db = getFirestore();
  const articleRef = db.collection("articles").doc(articleId);
  const articleDoc = await articleRef.get();

  if (!articleDoc.exists) {
    return { embeddingComputed: false, searchTokensComputed: false, skipped: true, reason: "not_found" };
  }

  const article = articleDoc.data() as Article;

  // Skip if not relevant
  if (!article.isRelevant) {
    return { embeddingComputed: false, searchTokensComputed: false, skipped: true, reason: "not_relevant" };
  }

  const updates: Record<string, unknown> = {};
  let embeddingComputed = false;
  let searchTokensComputed = false;

  // Compute searchTokens if missing
  if (!article.searchTokens || article.searchTokens.length === 0) {
    const tokens = generateSearchTokens(article);
    updates.searchTokens = tokens;
    searchTokensComputed = true;
    logger.debug("Generated searchTokens", { articleId, tokenCount: tokens.length });
  }

  // Compute embedding if missing
  if (!article.embedding) {
    const textToEmbed = `${article.title}\n${article.snippet}`;
    const vector = await embedText(textToEmbed, DEFAULT_EMBEDDING_DIMS);

    const embedding: ArticleEmbedding = {
      dims: DEFAULT_EMBEDDING_DIMS,
      vector,
      model: EMBEDDING_MODEL,
      updatedAt: Timestamp.now(),
    };

    updates.embedding = embedding;
    embeddingComputed = true;
    logger.debug("Generated embedding", { articleId, dims: DEFAULT_EMBEDDING_DIMS });
  }

  // Apply updates if any
  if (Object.keys(updates).length > 0) {
    await articleRef.update(updates);
  }

  return { embeddingComputed, searchTokensComputed, skipped: false };
}



=================================================================================
FILE: functions/src/lib/ingestion/index.ts
=================================================================================

/**
 * RSS Ingestion Module Exports
 */

export {
  ingestAllEnabledSources,
  ingestSource,
  type IngestionResult,
  type IngestionSummary,
} from "./ingest.js";

export { calculateRelevance, classifyCategories } from "./relevance.js";

export { fetchRssFeed, extractImageUrl, fetchOgImage, type RssItem } from "./rss-fetcher.js";

export {
  normalizeUrl,
  sha256Hash,
  generateArticleId,
  truncateText,
  stripHtml,
} from "./url-utils.js";



=================================================================================
FILE: functions/src/lib/ingestion/ingest.ts
=================================================================================

/**
 * RSS Feed Ingestion Engine
 *
 * Main ingestion logic for processing RSS feeds and storing articles.
 */

import { getFirestore, Timestamp, FieldValue } from "firebase-admin/firestore";
import * as logger from "firebase-functions/logger";
import type { Source, Article, SourceFetchState } from "../../types/firestore.js";
import { fetchRssFeed, extractImageUrl, fetchOgImage, type RssItem } from "./rss-fetcher.js";
import {
  normalizeUrl,
  generateArticleId,
  truncateText,
  stripHtml,
} from "./url-utils.js";
import { calculateRelevance, classifyCategories } from "./relevance.js";
import { generateSearchTokens } from "../embeddings/index.js";

// ============================================================================
// Types
// ============================================================================

export interface IngestionResult {
  sourceId: string;
  sourceName: string;
  success: boolean;
  notModified: boolean;
  itemsFetched: number;
  itemsIngested: number;
  itemsSkipped: number;
  itemsDuplicate: number;
  /** Duration in milliseconds for this source */
  durationMs?: number;
  /** Number of feeds processed (for multi-feed sources) */
  feedsProcessed?: number;
  /** Whether results came from cache */
  cached?: boolean;
  error?: string;
}

export interface IngestionSummary {
  startedAt: Date;
  completedAt: Date;
  durationMs: number;
  sourcesProcessed: number;
  totalItemsFetched: number;
  totalItemsIngested: number;
  results: IngestionResult[];
}

// ============================================================================
// Constants
// ============================================================================

const SNIPPET_MAX_LENGTH = 200;
const MAX_ARTICLE_AGE_DAYS = 30; // Don't ingest articles older than 30 days

// ============================================================================
// Main Ingestion Function
// ============================================================================

/**
 * Ingest articles from all enabled sources.
 *
 * @param options - Ingestion options
 * @returns Summary of ingestion results
 */
export async function ingestAllEnabledSources(options?: {
  maxAgeDays?: number;
  forceRefresh?: boolean;
}): Promise<IngestionSummary> {
  const startedAt = new Date();
  const db = getFirestore();
  const maxAgeDays = options?.maxAgeDays ?? MAX_ARTICLE_AGE_DAYS;

  // Fetch all enabled sources
  const sourcesSnap = await db
    .collection("sources")
    .where("enabled", "==", true)
    .get();

  const sources = sourcesSnap.docs.map(
    (doc) => ({ id: doc.id, ...doc.data() }) as Source
  );

  logger.info("Starting RSS ingestion", {
    sourcesCount: sources.length,
    maxAgeDays,
    forceRefresh: options?.forceRefresh ?? false,
  });

  const results: IngestionResult[] = [];

  for (const source of sources) {
    const sourceStartTime = Date.now();
    const result = await ingestSource(source, { maxAgeDays });
    result.durationMs = Date.now() - sourceStartTime;
    results.push(result);

    // Log progress with structured data
    if (result.success) {
      if (result.notModified) {
        logger.debug("Source not modified", {
          sourceId: source.id,
          sourceName: source.name,
        });
      } else {
        logger.info("Source ingested", {
          sourceId: source.id,
          sourceName: source.name,
          itemsFetched: result.itemsFetched,
          itemsIngested: result.itemsIngested,
          itemsSkipped: result.itemsSkipped,
          itemsDuplicate: result.itemsDuplicate,
          feedsProcessed: result.feedsProcessed,
          cached: result.cached,
          durationMs: result.durationMs,
        });
      }
    } else {
      logger.error("Source ingestion failed", {
        sourceId: source.id,
        sourceName: source.name,
        error: result.error,
      });
    }
  }

  const completedAt = new Date();
  const totalDurationMs = completedAt.getTime() - startedAt.getTime();

  // Log final summary
  const summary: IngestionSummary = {
    startedAt,
    completedAt,
    durationMs: totalDurationMs,
    sourcesProcessed: sources.length,
    totalItemsFetched: results.reduce((sum, r) => sum + r.itemsFetched, 0),
    totalItemsIngested: results.reduce((sum, r) => sum + r.itemsIngested, 0),
    results,
  };

  logger.info("Ingestion completed", {
    durationMs: totalDurationMs,
    sourcesProcessed: sources.length,
    totalItemsFetched: summary.totalItemsFetched,
    totalItemsIngested: summary.totalItemsIngested,
    successCount: results.filter((r) => r.success).length,
    failureCount: results.filter((r) => !r.success).length,
  });

  return summary;
}

/**
 * Ingest articles from a single source.
 * Supports multiple RSS URLs per source.
 */
export async function ingestSource(
  source: Source,
  options?: { maxAgeDays?: number }
): Promise<IngestionResult> {
  const maxAgeDays = options?.maxAgeDays ?? MAX_ARTICLE_AGE_DAYS;
  const cutoffDate = new Date();
  cutoffDate.setDate(cutoffDate.getDate() - maxAgeDays);

  const result: IngestionResult = {
    sourceId: source.id,
    sourceName: source.name,
    success: false,
    notModified: false,
    itemsFetched: 0,
    itemsIngested: 0,
    itemsSkipped: 0,
    itemsDuplicate: 0,
    feedsProcessed: 0,
    cached: false,
  };

  // Get all RSS URLs for this source (support both single and multiple)
  const rssUrls = source.rssUrls?.length ? source.rssUrls : [source.rssUrl];
  const isMultiFeed = rssUrls.length > 1;

  let allNotModified = true;
  let anySuccess = false;
  let anyCached = false;
  const feedErrors: string[] = [];

  try {
    for (const rssUrl of rssUrls) {
      // Get the fetch state for this specific URL
      // Note: For multi-feed sources, fetchStates is keyed by urlToSafeKey(rssUrl), not the raw URL
      const safeKey = urlToSafeKey(rssUrl);
      const fetchState = isMultiFeed
        ? source.fetchStates?.[safeKey] ?? getDefaultFetchState()
        : source.fetchState;

      // Fetch the RSS feed
      const fetchResult = await fetchRssFeed(rssUrl, fetchState);

      if (!fetchResult.success) {
        feedErrors.push(`${rssUrl}: ${fetchResult.error}`);
        // Update fetch state for this URL
        if (isMultiFeed) {
          await updateSourceFetchStateForUrl(source.id, rssUrl, fetchResult.newFetchState);
        } else {
          await updateSourceFetchState(source.id, fetchResult.newFetchState);
        }
        continue;
      }

      // Track metadata
      result.feedsProcessed = (result.feedsProcessed ?? 0) + 1;
      if (fetchResult.cached) {
        anyCached = true;
      }

      // Track if any feed was not "not modified"
      if (!fetchResult.notModified) {
        allNotModified = false;
      }

      anySuccess = true;
      result.itemsFetched += fetchResult.items.length;

      // Process each item
      for (const item of fetchResult.items) {
        const itemResult = await processRssItem(item, source, cutoffDate);

        if (itemResult === "ingested") result.itemsIngested++;
        else if (itemResult === "skipped") result.itemsSkipped++;
        else if (itemResult === "duplicate") result.itemsDuplicate++;
      }

      // Update fetch state for this URL (skip for cached results)
      if (!fetchResult.cached) {
        if (isMultiFeed) {
          await updateSourceFetchStateForUrl(source.id, rssUrl, fetchResult.newFetchState);
        } else {
          await updateSourceFetchState(source.id, fetchResult.newFetchState);
        }
      }
    }

    // Determine overall result
    result.success = anySuccess;
    result.notModified = allNotModified && anySuccess;
    result.cached = anyCached;

    if (feedErrors.length > 0 && feedErrors.length < rssUrls.length) {
      // Partial failure
      result.error = `Partial failure: ${feedErrors.join("; ")}`;
    } else if (feedErrors.length === rssUrls.length) {
      // Complete failure
      result.success = false;
      result.error = feedErrors.join("; ");
    }

    return result;
  } catch (error) {
    result.error = error instanceof Error ? error.message : "Unknown error";
    return result;
  }
}

/**
 * Get default fetch state for new feeds
 */
function getDefaultFetchState(): SourceFetchState {
  return {
    etag: null,
    lastModified: null,
    lastFetchedAt: null,
    lastError: null,
  };
}

// ============================================================================
// Helper Functions
// ============================================================================

type ProcessResult = "ingested" | "skipped" | "duplicate";

/**
 * Process a single RSS item and store if relevant.
 */
async function processRssItem(
  item: RssItem,
  source: Source,
  cutoffDate: Date
): Promise<ProcessResult> {
  const db = getFirestore();

  // Skip items without required fields
  if (!item.link || !item.title) {
    return "skipped";
  }

  // Parse publication date
  const pubDateStr = item.isoDate || item.pubDate;
  if (!pubDateStr) {
    return "skipped";
  }

  const pubDate = new Date(pubDateStr);
  if (isNaN(pubDate.getTime())) {
    return "skipped";
  }

  // Skip articles older than cutoff
  if (pubDate < cutoffDate) {
    return "skipped";
  }

  // Generate article ID from canonical URL
  const canonicalUrl = normalizeUrl(item.link);
  const articleId = generateArticleId(item.link);

  // Check if article already exists
  const existingDoc = await db.collection("articles").doc(articleId).get();
  if (existingDoc.exists) {
    return "duplicate";
  }

  // Extract and clean snippet
  const rawSnippet =
    item.contentSnippet || item.summary || item.description || item.content || "";
  const snippet = truncateText(stripHtml(rawSnippet), SNIPPET_MAX_LENGTH);

  // Calculate relevance
  const relevance = calculateRelevance(item.title, snippet, source.tags);

  // Classify into categories (uses keyword matching, falls back to source tags)
  const categories = classifyCategories(item.title, snippet, source.tags);

  // Extract image URL from RSS feed first
  let imageUrl = extractImageUrl(item);

  // If no image in RSS, try to fetch og:image from the article page
  if (!imageUrl) {
    imageUrl = await fetchOgImage(item.link);
  }

  // Build article document
  const article: Omit<Article, "id"> = {
    sourceId: source.id,
    sourceName: source.name,
    title: item.title.trim(),
    snippet,
    url: item.link,
    canonicalUrl,
    guid: item.guid || null,
    imageUrl,
    categories,
    publishedAt: Timestamp.fromDate(pubDate),
    ingestedAt: Timestamp.now(),
    relevanceScore: relevance.score,
    isRelevant: relevance.isRelevant,
    ai: null,
  };

  // Generate searchTokens for relevant articles (no OpenAI call needed)
  const searchTokens = relevance.isRelevant
    ? generateSearchTokens({ title: item.title.trim(), snippet })
    : [];

  // Store in Firestore
  await db.collection("articles").doc(articleId).set({
    id: articleId,
    ...article,
    searchTokens,
  });

  return "ingested";
}

/**
 * Update source fetch state in Firestore (single feed).
 */
async function updateSourceFetchState(
  sourceId: string,
  newFetchState: Record<string, unknown>
): Promise<void> {
  const db = getFirestore();

  // Replace null lastFetchedAt with server timestamp
  const updates: Record<string, unknown> = {
    "fetchState.lastError": newFetchState.lastError ?? null,
    "fetchState.lastFetchedAt": FieldValue.serverTimestamp(),
    updatedAt: FieldValue.serverTimestamp(),
  };

  if (newFetchState.etag !== undefined) {
    updates["fetchState.etag"] = newFetchState.etag;
  }
  if (newFetchState.lastModified !== undefined) {
    updates["fetchState.lastModified"] = newFetchState.lastModified;
  }

  await db.collection("sources").doc(sourceId).update(updates);
}

/**
 * Create a safe key for a URL to use in Firestore field paths.
 * Uses a simple hash to avoid special characters.
 */
function urlToSafeKey(url: string): string {
  // Create a simple hash from the URL
  let hash = 0;
  for (let i = 0; i < url.length; i++) {
    const char = url.charCodeAt(i);
    hash = ((hash << 5) - hash) + char;
    hash = hash & hash; // Convert to 32bit integer
  }
  // Return a safe alphanumeric key
  return `feed_${Math.abs(hash).toString(36)}`;
}

/**
 * Update fetch state for a specific RSS URL in a multi-feed source.
 * Uses a hash of the URL as the key to avoid Firestore field path issues.
 */
async function updateSourceFetchStateForUrl(
  sourceId: string,
  rssUrl: string,
  newFetchState: Record<string, unknown>
): Promise<void> {
  const db = getFirestore();

  // Use a safe key derived from the URL
  const safeKey = urlToSafeKey(rssUrl);

  const updates: Record<string, unknown> = {
    [`fetchStates.${safeKey}.url`]: rssUrl,
    [`fetchStates.${safeKey}.lastError`]: newFetchState.lastError ?? null,
    [`fetchStates.${safeKey}.lastFetchedAt`]: FieldValue.serverTimestamp(),
    [`fetchStates.${safeKey}.etag`]: newFetchState.etag ?? null,
    [`fetchStates.${safeKey}.lastModified`]: newFetchState.lastModified ?? null,
    updatedAt: FieldValue.serverTimestamp(),
  };

  await db.collection("sources").doc(sourceId).update(updates);
}



=================================================================================
FILE: functions/src/lib/ingestion/relevance.ts
=================================================================================

/**
 * P&C Insurance Relevance Filtering & Category Classification
 *
 * Keyword-based heuristic filter and classifier.
 * Excludes life/health insurance content.
 * Maps articles to P&C categories: Property, Casualty, Regulation, Claims, Reinsurance, Technology
 */

import type { SourceCategory } from "../../types/firestore.js";

// ============================================================================
// Category-Specific Keywords (for classification)
// ============================================================================

const CATEGORY_KEYWORDS: Record<SourceCategory, string[]> = {
  property_cat: [
    "property insurance", "homeowners", "commercial property", "fire insurance",
    "flood insurance", "hurricane", "catastrophe", "cat loss", "nat cat",
    "wildfire", "earthquake", "windstorm", "hail damage", "property damage",
    "builders risk", "inland marine", "ocean marine", "cargo insurance",
    "boiler and machinery", "equipment breakdown", "habitational", "dwelling",
    "commercial real estate", "building coverage", "business interruption",
    "parametric", "named storm", "wind damage", "water damage", "fire loss",
  ],
  casualty_liability: [
    "casualty", "liability", "general liability", "professional liability",
    "errors and omissions", "e&o", "d&o", "directors and officers",
    "workers compensation", "workers comp", "auto insurance", "commercial auto",
    "motor insurance", "product liability", "umbrella", "excess liability",
    "cyber insurance", "cyber liability", "data breach", "ransomware",
    "epli", "employment practices", "fiduciary liability", "crime insurance",
    "fidelity bond", "kidnap and ransom", "personal injury", "bodily injury",
    "third party", "vicarious liability", "negligence", "tort",
  ],
  regulation: [
    "regulation", "regulatory", "naic", "state insurance", "insurance regulation",
    "insurance commissioner", "surplus lines", "admitted", "non-admitted",
    "rate adequacy", "rate filing", "residual market", "fair plan",
    "citizens property", "legislation", "compliance", "mandate", "statute",
    "regulatory approval", "department of insurance", "insurance department",
    "market conduct", "consumer protection", "licensing", "solvency regulation",
  ],
  claims: [
    "claims", "claim management", "loss adjustment", "adjuster", "subrogation",
    "settlement", "reserve", "loss ratio", "loss development",
    "incurred but not reported", "ibnr", "case reserves", "adverse development",
    "reserve strengthening", "claims handling", "litigation", "lawsuit",
    "verdict", "claimant", "first notice of loss", "fnol",
  ],
  reinsurance: [
    "reinsurance", "retrocession", "treaty", "facultative", "cat bond",
    "catastrophe bond", "ils", "insurance-linked securities", "sidecar",
    "collateralized reinsurance", "quota share", "excess of loss",
    "aggregate cover", "1/1 renewals", "monte carlo", "risk transfer",
    "ceding", "ceded", "assumed", "retro", "reinstatement",
  ],
  insurtech: [
    "insurtech", "technology", "artificial intelligence", "ai", "machine learning",
    "automation", "digital transformation", "telematics", "iot", "blockchain",
    "smart contract", "digital claims", "api", "platform", "startup",
    "innovation", "tech", "software", "saas", "data analytics",
    "predictive analytics", "modeling", "parametric", "embedded insurance",
  ],
};

// ============================================================================
// P&C Positive Keywords (boost relevance) - Combined from all categories
// ============================================================================

const PC_KEYWORDS = [
  // Property
  "property insurance",
  "homeowners",
  "commercial property",
  "fire insurance",
  "flood insurance",
  "hurricane",
  "catastrophe",
  "cat loss",
  "nat cat",
  "wildfire",
  "earthquake",
  "windstorm",
  "hail damage",
  "property damage",
  "builders risk",
  "inland marine",
  "ocean marine",
  "cargo insurance",
  "boiler and machinery",
  "equipment breakdown",

  // Casualty / Liability
  "casualty",
  "liability",
  "general liability",
  "professional liability",
  "errors and omissions",
  "e&o",
  "d&o",
  "directors and officers",
  "workers compensation",
  "workers comp",
  "auto insurance",
  "commercial auto",
  "motor insurance",
  "product liability",
  "umbrella",
  "excess liability",
  "cyber insurance",
  "cyber liability",
  "data breach",
  "ransomware",
  "epli",
  "employment practices",
  "fiduciary liability",
  "crime insurance",
  "fidelity bond",
  "kidnap and ransom",

  // Social Inflation / Litigation Trends
  "social inflation",
  "nuclear verdict",
  "litigation funding",
  "third-party litigation",
  "class action",
  "mass tort",
  "mdl",
  "reptile theory",
  "punitive damages",
  "jury verdict",
  "bellwether trial",

  // Climate / ESG
  "climate risk",
  "climate change",
  "transition risk",
  "physical risk",
  "esg",
  "sustainability",
  "carbon footprint",
  "greenwashing",
  "climate disclosure",
  "adaptation",
  "resilience",

  // Reinsurance
  "reinsurance",
  "retrocession",
  "treaty",
  "facultative",
  "cat bond",
  "catastrophe bond",
  "ils",
  "insurance-linked securities",
  "sidecar",
  "collateralized reinsurance",
  "quota share",
  "excess of loss",
  "aggregate cover",
  "1/1 renewals",
  "monte carlo",
  "risk transfer",

  // Claims
  "claims",
  "loss adjustment",
  "subrogation",
  "litigation",
  "settlement",
  "reserve",
  "loss ratio",
  "combined ratio",
  "loss development",
  "incurred but not reported",
  "ibnr",
  "case reserves",
  "adverse development",
  "reserve strengthening",

  // Market / Regulation
  "underwriting",
  "premium",
  "rate increase",
  "hard market",
  "soft market",
  "capacity",
  "naic",
  "state insurance",
  "insurance regulation",
  "insurance commissioner",
  "surplus lines",
  "admitted",
  "non-admitted",
  "mga",
  "managing general agent",
  "rate adequacy",
  "loss cost",
  "rate filing",
  "residual market",
  "fair plan",
  "citizens property",

  // Industry / Market
  "p&c",
  "property and casualty",
  "commercial lines",
  "personal lines",
  "insurance carrier",
  "insurer",
  "policyholder",
  "m&a",
  "merger",
  "acquisition",
  "ipo",
  "earnings",
  "combined ratio",
  "return on equity",
  "book value",
  "statutory surplus",
  "am best",
  "s&p rating",
  "moody's rating",
  "fitch rating",
  "solvency",
  "rbc",
  "risk-based capital",

  // Major Carriers (high signal)
  "state farm",
  "allstate",
  "liberty mutual",
  "travelers",
  "chubb",
  "aig",
  "hartford",
  "progressive",
  "geico",
  "nationwide",
  "farmers",
  "usaa",
  "erie insurance",
  "cincinnati financial",
  "hanover",
  "cna",
  "zurich",
  "axa xl",
  "swiss re",
  "munich re",
  "berkshire hathaway",
  "markel",
  "w. r. berkley",
  "arch capital",
  "renaissancere",
  "everest re",
  "lloyd's",
];

// ============================================================================
// Exclusion Keywords (reduce relevance - life/health focus)
// ============================================================================

const EXCLUSION_KEYWORDS = [
  "life insurance",
  "term life",
  "whole life",
  "universal life",
  "health insurance",
  "health plan",
  "medicare",
  "medicaid",
  "obamacare",
  "aca",
  "affordable care act",
  "dental insurance",
  "vision insurance",
  "disability insurance",
  "long-term care",
  "annuity",
  "annuities",
  "retirement plan",
  "401k",
  "pension",
];

// ============================================================================
// Relevance Scoring
// ============================================================================

interface RelevanceResult {
  score: number;
  isRelevant: boolean;
  matchedKeywords: string[];
  excludedKeywords: string[];
}

/**
 * Calculate P&C relevance score for an article.
 *
 * @param title - Article title
 * @param snippet - Article snippet/description
 * @param sourceCategories - Categories from the source
 * @returns Relevance result with score (0-1) and isRelevant flag
 */
export function calculateRelevance(
  title: string,
  snippet: string,
  sourceCategories: SourceCategory[] = []
): RelevanceResult {
  const text = `${title} ${snippet}`.toLowerCase();

  // Check for exclusion keywords
  const excludedKeywords = EXCLUSION_KEYWORDS.filter((kw) =>
    text.includes(kw.toLowerCase())
  );

  // Check for P&C keywords
  const matchedKeywords = PC_KEYWORDS.filter((kw) =>
    text.includes(kw.toLowerCase())
  );

  // Calculate base score
  let score = 0;

  // Start with source category boost (reputable P&C sources)
  if (sourceCategories.length > 0) {
    score += 0.3;
  }

  // Add points for matched P&C keywords (diminishing returns)
  const keywordBoost = Math.min(matchedKeywords.length * 0.15, 0.6);
  score += keywordBoost;

  // Penalty for exclusion keywords
  const exclusionPenalty = Math.min(excludedKeywords.length * 0.3, 0.8);
  score -= exclusionPenalty;

  // Clamp score between 0 and 1
  score = Math.max(0, Math.min(1, score));

  // Threshold for relevance
  const isRelevant = score >= 0.25 && excludedKeywords.length === 0;

  return {
    score: Math.round(score * 100) / 100,
    isRelevant,
    matchedKeywords,
    excludedKeywords,
  };
}

// ============================================================================
// Category Classification
// ============================================================================

interface CategoryScore {
  category: SourceCategory;
  score: number;
  matchedKeywords: string[];
}

/**
 * Classify article into P&C categories based on keyword matching.
 * Returns categories sorted by relevance score.
 *
 * @param title - Article title
 * @param snippet - Article snippet/description
 * @param sourceCategories - Categories from the source (used as fallback)
 * @returns Array of matched categories sorted by score
 */
export function classifyCategories(
  title: string,
  snippet: string,
  sourceCategories: SourceCategory[] = []
): SourceCategory[] {
  const text = `${title} ${snippet}`.toLowerCase();
  const scores: CategoryScore[] = [];

  // Score each category
  for (const [category, keywords] of Object.entries(CATEGORY_KEYWORDS)) {
    const matched = keywords.filter((kw) => text.includes(kw.toLowerCase()));
    if (matched.length > 0) {
      scores.push({
        category: category as SourceCategory,
        score: matched.length,
        matchedKeywords: matched,
      });
    }
  }

  // Sort by score descending
  scores.sort((a, b) => b.score - a.score);

  // Get top categories (at least 1 match)
  const inferredCategories = scores.map((s) => s.category);

  // If no categories matched, fall back to source categories
  if (inferredCategories.length === 0) {
    return sourceCategories;
  }

  // Merge with source categories, prioritizing inferred
  const mergedCategories = [...new Set([...inferredCategories, ...sourceCategories])];

  // Limit to top 3 categories
  return mergedCategories.slice(0, 3);
}



=================================================================================
FILE: functions/src/lib/ingestion/rss-fetcher.ts
=================================================================================

/**
 * RSS Feed Fetcher with Conditional GET Support and Caching
 *
 * Uses ETag/Last-Modified headers to minimize bandwidth.
 * Implements in-memory caching to avoid redundant fetches.
 */

import Parser from "rss-parser";
import type { SourceFetchState } from "../../types/firestore.js";

// ============================================================================
// Types
// ============================================================================

export interface RssItem {
  title: string;
  link: string;
  guid?: string;
  pubDate?: string;
  isoDate?: string;
  contentSnippet?: string;
  content?: string;
  summary?: string;
  description?: string;
  creator?: string;
  categories?: string[];
  enclosure?: {
    url?: string;
    type?: string;
  };
  "media:content"?: {
    $?: { url?: string };
  };
  "media:thumbnail"?: {
    $?: { url?: string };
  };
}

export interface FetchResult {
  success: boolean;
  notModified: boolean;
  items: RssItem[];
  newFetchState: Partial<SourceFetchState>;
  error?: string;
  cached?: boolean;
}

// ============================================================================
// Feed Cache (in-memory, per-function-invocation)
// ============================================================================

interface CachedFeed {
  items: RssItem[];
  fetchState: Partial<SourceFetchState>;
  cachedAt: number;
}

// Cache TTL: 15 minutes (reduces redundant fetches within same ingestion run)
const CACHE_TTL_MS = 15 * 60 * 1000;
const feedCache = new Map<string, CachedFeed>();

/**
 * Clear expired entries from the cache
 */
function cleanExpiredCache(): void {
  const now = Date.now();
  for (const [url, cached] of feedCache.entries()) {
    if (now - cached.cachedAt > CACHE_TTL_MS) {
      feedCache.delete(url);
    }
  }
}

/**
 * Get cached feed if available and not expired
 */
function getCachedFeed(url: string): CachedFeed | null {
  const cached = feedCache.get(url);
  if (!cached) return null;

  const age = Date.now() - cached.cachedAt;
  if (age > CACHE_TTL_MS) {
    feedCache.delete(url);
    return null;
  }

  return cached;
}

/**
 * Store feed in cache
 */
function setCachedFeed(url: string, items: RssItem[], fetchState: Partial<SourceFetchState>): void {
  // Clean up old entries periodically
  if (feedCache.size > 50) {
    cleanExpiredCache();
  }

  feedCache.set(url, {
    items,
    fetchState,
    cachedAt: Date.now(),
  });
}

// ============================================================================
// RSS Parser Instance
// ============================================================================

const parser = new Parser({
  timeout: 30000, // 30 second timeout
  headers: {
    "User-Agent": "InsuranceNewsAI/1.0 (+https://insurance-news-ai.web.app)",
    Accept: "application/rss+xml, application/xml, text/xml",
  },
  customFields: {
    item: [
      ["media:content", "media:content"],
      ["media:thumbnail", "media:thumbnail"],
    ],
  },
});

// ============================================================================
// Fetch Functions
// ============================================================================

/**
 * Fetch RSS feed with conditional GET support and caching.
 *
 * @param feedUrl - The RSS feed URL
 * @param fetchState - Previous fetch state with ETag/Last-Modified
 * @param options - Fetch options
 * @returns FetchResult with items and new fetch state
 */
export async function fetchRssFeed(
  feedUrl: string,
  fetchState: SourceFetchState,
  options?: { skipCache?: boolean }
): Promise<FetchResult> {
  try {
    // Check cache first (unless explicitly skipped)
    if (!options?.skipCache) {
      const cached = getCachedFeed(feedUrl);
      if (cached) {
        return {
          success: true,
          notModified: false,
          items: cached.items,
          newFetchState: cached.fetchState,
          cached: true,
        };
      }
    }

    // Build conditional request headers
    const headers: Record<string, string> = {
      "User-Agent": "InsuranceNewsAI/1.0 (+https://insurance-news-ai.web.app)",
      Accept: "application/rss+xml, application/xml, text/xml",
    };

    if (fetchState.etag) {
      headers["If-None-Match"] = fetchState.etag;
    }
    if (fetchState.lastModified) {
      headers["If-Modified-Since"] = fetchState.lastModified;
    }

    // Fetch the feed
    const response = await fetch(feedUrl, {
      method: "GET",
      headers,
    });

    // Handle 304 Not Modified
    if (response.status === 304) {
      return {
        success: true,
        notModified: true,
        items: [],
        newFetchState: {
          lastFetchedAt: null, // Will be set to serverTimestamp by caller
          lastError: null,
        },
      };
    }

    // Handle non-success status
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    }

    // Parse the feed
    const feedText = await response.text();
    const feed = await parser.parseString(feedText);

    // Extract new fetch state from headers
    const newEtag = response.headers.get("etag");
    const newLastModified = response.headers.get("last-modified");

    const newFetchState = {
      etag: newEtag || fetchState.etag,
      lastModified: newLastModified || fetchState.lastModified,
      lastFetchedAt: null, // Will be set to serverTimestamp by caller
      lastError: null,
    };

    const items = feed.items as RssItem[];

    // Cache the result
    setCachedFeed(feedUrl, items, newFetchState);

    return {
      success: true,
      notModified: false,
      items,
      newFetchState,
    };
  } catch (error) {
    const errorMessage =
      error instanceof Error ? error.message : "Unknown error";

    return {
      success: false,
      notModified: false,
      items: [],
      newFetchState: {
        lastFetchedAt: null,
        lastError: errorMessage,
      },
      error: errorMessage,
    };
  }
}

/**
 * Extract image URL from RSS item.
 * Checks multiple possible locations for image.
 */
export function extractImageUrl(item: RssItem): string | null {
  // Check enclosure (common for images)
  if (item.enclosure?.url && item.enclosure.type?.startsWith("image/")) {
    return item.enclosure.url;
  }

  // Check media:content
  if (item["media:content"]?.$?.url) {
    return item["media:content"].$.url;
  }

  // Check media:thumbnail
  if (item["media:thumbnail"]?.$?.url) {
    return item["media:thumbnail"].$.url;
  }

  return null;
}

// ============================================================================
// Open Graph Image Extraction
// ============================================================================

/** Timeout for og:image fetch requests (ms) */
const OG_IMAGE_FETCH_TIMEOUT_MS = 5000;

/** Maximum HTML bytes to read when looking for og:image (64KB should be enough for <head>) */
const OG_IMAGE_MAX_BYTES = 65536;

/**
 * Fetch og:image from an article page.
 *
 * This function fetches the article URL and extracts the og:image meta tag.
 * It's designed to be fast and robust:
 * - Uses a short timeout to avoid blocking ingestion
 * - Only reads the first 64KB of the page (enough for <head>)
 * - Handles various og:image meta tag formats
 * - Returns null on any error (never throws)
 *
 * @param articleUrl - The article URL to fetch
 * @returns The og:image URL or null if not found/error
 */
export async function fetchOgImage(articleUrl: string): Promise<string | null> {
  try {
    // Create abort controller for timeout
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), OG_IMAGE_FETCH_TIMEOUT_MS);

    const response = await fetch(articleUrl, {
      method: "GET",
      headers: {
        "User-Agent": "InsuranceNewsAI/1.0 (+https://insurance-news-ai.web.app)",
        "Accept": "text/html",
      },
      signal: controller.signal,
    });

    clearTimeout(timeoutId);

    if (!response.ok) {
      return null;
    }

    // Read only the first chunk of the response (enough for <head>)
    const reader = response.body?.getReader();
    if (!reader) {
      return null;
    }

    let html = "";
    let bytesRead = 0;

    while (bytesRead < OG_IMAGE_MAX_BYTES) {
      const { done, value } = await reader.read();
      if (done) break;

      html += new TextDecoder().decode(value);
      bytesRead += value.length;

      // Early exit if we've passed </head> - no need to read more
      if (html.includes("</head>")) {
        break;
      }
    }

    // Cancel the rest of the response to free resources
    reader.cancel().catch(() => {});

    // Extract og:image using regex patterns (also try twitter:image as fallback)
    // Pattern 1: <meta property="og:image" content="...">
    // Pattern 2: <meta content="..." property="og:image">
    // Pattern 3: <meta name="og:image" content="...">
    // Pattern 4-6: Same patterns for twitter:image
    const imagePatterns = [
      // og:image patterns (preferred)
      /<meta[^>]+property=["']og:image["'][^>]+content=["']([^"']+)["']/i,
      /<meta[^>]+content=["']([^"']+)["'][^>]+property=["']og:image["']/i,
      /<meta[^>]+name=["']og:image["'][^>]+content=["']([^"']+)["']/i,
      /<meta[^>]+content=["']([^"']+)["'][^>]+name=["']og:image["']/i,
      // twitter:image patterns (fallback)
      /<meta[^>]+property=["']twitter:image["'][^>]+content=["']([^"']+)["']/i,
      /<meta[^>]+content=["']([^"']+)["'][^>]+property=["']twitter:image["']/i,
      /<meta[^>]+name=["']twitter:image["'][^>]+content=["']([^"']+)["']/i,
      /<meta[^>]+content=["']([^"']+)["'][^>]+name=["']twitter:image["']/i,
    ];

    for (const pattern of imagePatterns) {
      const match = html.match(pattern);
      if (match && match[1]) {
        const imageUrl = match[1].trim();
        // Skip placeholder/undefined values
        if (imageUrl === "undefined" || imageUrl === "null" || imageUrl === "") {
          continue;
        }
        // Validate it looks like a URL
        if (imageUrl.startsWith("http://") || imageUrl.startsWith("https://")) {
          return imageUrl;
        }
        // Handle protocol-relative URLs
        if (imageUrl.startsWith("//")) {
          return "https:" + imageUrl;
        }
      }
    }

    return null;
  } catch {
    // Silently fail - og:image is optional enhancement
    return null;
  }
}



=================================================================================
FILE: functions/src/lib/ingestion/url-utils.ts
=================================================================================

/**
 * URL Normalization and Hashing Utilities
 *
 * Used for article deduplication via canonical URL hashing.
 */

import { createHash } from "crypto";

/**
 * Normalize a URL for deduplication.
 * - Lowercase hostname
 * - Remove tracking parameters (utm_*, fbclid, etc.)
 * - Remove trailing slashes
 * - Sort query parameters
 * - Remove fragments
 */
export function normalizeUrl(url: string): string {
  try {
    const parsed = new URL(url);

    // Lowercase hostname
    parsed.hostname = parsed.hostname.toLowerCase();

    // Remove common tracking parameters
    const trackingParams = [
      "utm_source",
      "utm_medium",
      "utm_campaign",
      "utm_term",
      "utm_content",
      "fbclid",
      "gclid",
      "ref",
      "source",
    ];

    trackingParams.forEach((param) => {
      parsed.searchParams.delete(param);
    });

    // Sort query params for consistency
    parsed.searchParams.sort();

    // Remove fragment
    parsed.hash = "";

    // Build normalized URL
    let normalized = `${parsed.protocol}//${parsed.hostname}`;

    // Add port if non-standard
    if (
      parsed.port &&
      !(parsed.protocol === "https:" && parsed.port === "443") &&
      !(parsed.protocol === "http:" && parsed.port === "80")
    ) {
      normalized += `:${parsed.port}`;
    }

    // Add path (remove trailing slash unless root)
    let path = parsed.pathname;
    if (path.length > 1 && path.endsWith("/")) {
      path = path.slice(0, -1);
    }
    normalized += path;

    // Add query string if present
    const queryString = parsed.searchParams.toString();
    if (queryString) {
      normalized += `?${queryString}`;
    }

    return normalized;
  } catch {
    // If URL parsing fails, return original trimmed
    return url.trim().toLowerCase();
  }
}

/**
 * Generate SHA256 hash of a string.
 * Returns first 16 characters for compact storage.
 */
export function sha256Hash(input: string): string {
  return createHash("sha256").update(input).digest("hex").substring(0, 16);
}

/**
 * Generate article ID from URL.
 * Uses SHA256 hash of normalized URL for deduplication.
 */
export function generateArticleId(url: string): string {
  const normalizedUrl = normalizeUrl(url);
  return sha256Hash(normalizedUrl);
}

/**
 * Generate fallback article ID from GUID.
 */
export function generateArticleIdFromGuid(guid: string): string {
  return sha256Hash(guid);
}

/**
 * Truncate text to a maximum length, respecting word boundaries.
 */
export function truncateText(
  text: string,
  maxLength: number,
  suffix = "..."
): string {
  if (!text) return "";

  const trimmed = text.trim();
  if (trimmed.length <= maxLength) return trimmed;

  // Find last space before maxLength
  const truncated = trimmed.substring(0, maxLength - suffix.length);
  const lastSpace = truncated.lastIndexOf(" ");

  if (lastSpace > maxLength * 0.6) {
    return truncated.substring(0, lastSpace) + suffix;
  }

  return truncated + suffix;
}

/**
 * Extract clean text from potentially HTML content.
 * Removes HTML tags and decodes entities.
 */
export function stripHtml(html: string): string {
  if (!html) return "";

  return html
    .replace(/<[^>]*>/g, "") // Remove HTML tags
    .replace(/&nbsp;/gi, " ")
    .replace(/&amp;/gi, "&")
    .replace(/&lt;/gi, "<")
    .replace(/&gt;/gi, ">")
    .replace(/&quot;/gi, "\"")
    .replace(/&#39;/gi, "'")
    .replace(/\s+/g, " ") // Normalize whitespace
    .trim();
}



=================================================================================
FILE: functions/src/lib/notifications/index.ts
=================================================================================

/**
 * Push Notifications Service
 *
 * Handles sending FCM notifications to users with registered push tokens.
 * Batches notifications for efficiency and handles token cleanup.
 */

import { getMessaging, type Messaging } from "firebase-admin/messaging";
import { getFirestore, type Firestore } from "firebase-admin/firestore";

// Lazy initialization to avoid calling before Firebase is initialized
let _db: Firestore | null = null;
let _messaging: Messaging | null = null;

function getDb(): Firestore {
  if (!_db) {
    _db = getFirestore();
  }
  return _db;
}

function getMessagingInstance(): Messaging {
  if (!_messaging) {
    _messaging = getMessaging();
  }
  return _messaging;
}

// Maximum tokens per multicast message (FCM limit is 500)
const BATCH_SIZE = 500;

interface PushToken {
  token: string;
  platform: "ios" | "web";
}

interface NotificationPayload {
  title: string;
  body: string;
  data?: Record<string, string>;
}

/**
 * Get all push tokens for users who have daily brief notifications enabled
 */
async function getOptedInTokens(): Promise<{ uid: string; tokens: PushToken[] }[]> {
  const usersWithTokens: { uid: string; tokens: PushToken[] }[] = [];

  // Get all users who have dailyBrief notifications enabled
  const usersSnap = await getDb().collectionGroup("prefs").get();

  for (const prefDoc of usersSnap.docs) {
    const prefs = prefDoc.data();

    // Check if daily brief notifications are enabled (default is true)
    const dailyBriefEnabled = prefs.notifications?.dailyBrief !== false;

    if (!dailyBriefEnabled) {
      continue;
    }

    // Get the user ID from the path: users/{uid}/prefs/main
    const uid = prefDoc.ref.parent.parent?.id;
    if (!uid) continue;

    // Get all push tokens for this user
    const tokensSnap = await getDb().collection(`users/${uid}/pushTokens`).get();

    if (!tokensSnap.empty) {
      const tokens = tokensSnap.docs.map((doc) => ({
        token: doc.data().token as string,
        platform: doc.data().platform as "ios" | "web",
      }));
      usersWithTokens.push({ uid, tokens });
    }
  }

  return usersWithTokens;
}

/**
 * Send a notification to all opted-in users
 * Batches tokens for efficient sending and cleans up invalid tokens
 */
export async function sendNotificationToOptedInUsers(
  payload: NotificationPayload
): Promise<{ sent: number; failed: number; cleaned: number }> {
  console.log("[notifications] Starting notification send...");

  const usersWithTokens = await getOptedInTokens();
  const allTokens: { token: string; uid: string }[] = [];

  // Flatten all tokens with their user IDs
  for (const user of usersWithTokens) {
    for (const t of user.tokens) {
      allTokens.push({ token: t.token, uid: user.uid });
    }
  }

  console.log(`[notifications] Found ${allTokens.length} tokens from ${usersWithTokens.length} users`);

  if (allTokens.length === 0) {
    return { sent: 0, failed: 0, cleaned: 0 };
  }

  let sent = 0;
  let failed = 0;
  let cleaned = 0;

  // Process in batches
  for (let i = 0; i < allTokens.length; i += BATCH_SIZE) {
    const batch = allTokens.slice(i, i + BATCH_SIZE);
    const tokens = batch.map((t) => t.token);

    try {
      const response = await getMessagingInstance().sendEachForMulticast({
        tokens,
        notification: {
          title: payload.title,
          body: payload.body,
        },
        data: payload.data,
        apns: {
          payload: {
            aps: {
              sound: "default",
              badge: 1,
            },
          },
        },
        webpush: {
          notification: {
            icon: "/pwa-192x192.png",
          },
        },
      });

      sent += response.successCount;
      failed += response.failureCount;

      // Clean up invalid tokens
      for (let j = 0; j < response.responses.length; j++) {
        if (!response.responses[j].success) {
          const error = response.responses[j].error;
          // Remove invalid tokens (unregistered, invalid, etc.)
          if (
            error?.code === "messaging/invalid-registration-token" ||
            error?.code === "messaging/registration-token-not-registered"
          ) {
            const { token, uid } = batch[j];
            await getDb().doc(`users/${uid}/pushTokens/${token}`).delete();
            cleaned++;
            console.log(`[notifications] Cleaned invalid token for user ${uid}`);
          }
        }
      }
    } catch (error) {
      console.error("[notifications] Batch send error:", error);
      failed += batch.length;
    }
  }

  console.log(`[notifications] Complete: ${sent} sent, ${failed} failed, ${cleaned} cleaned`);
  return { sent, failed, cleaned };
}

/**
 * Format date for notification body (e.g., "February 8")
 */
export function formatDateForNotification(dateKey: string): string {
  const [year, month, day] = dateKey.split("-").map(Number);
  const date = new Date(year, month - 1, day);
  return date.toLocaleDateString("en-US", { month: "long", day: "numeric" });
}



=================================================================================
FILE: functions/src/lib/rag/index.ts
=================================================================================

/**
 * RAG (Retrieval-Augmented Generation) Module
 *
 * Provides semantic search and grounded answer generation for chat.
 * Uses cosine similarity reranking with source diversity.
 */

import { getFirestore, Timestamp } from "firebase-admin/firestore";
import * as logger from "firebase-functions/logger";
import { getOpenAIClient, AI_MODEL, RAG_ANSWER_SCHEMA, type RagAnswerResponse, type RagCitation } from "../ai/openai-client.js";
import { embedText, DEFAULT_EMBEDDING_DIMS, ensureArticleVector } from "../embeddings/index.js";
import type { Article } from "../../types/firestore.js";
import type { Response } from "express";

// ============================================================================
// Types
// ============================================================================

export interface RagScope {
  timeWindow: "today" | "7d" | "30d";
  category: string;
  sourceIds: string[] | null;
}

export interface ChatMessage {
  role: "user" | "assistant";
  content: string;
}

export interface ArticleContext {
  id: string;
  title: string;
  sourceName: string;
  url: string;
  publishedAt: string;
  snippet: string;
  tldr: string | null;
}

// ============================================================================
// Constants
// ============================================================================

const STOPWORDS = new Set([
  "a", "an", "and", "are", "as", "at", "be", "by", "for", "from",
  "has", "have", "he", "in", "is", "it", "its", "of", "on", "or",
  "that", "the", "to", "was", "were", "will", "with", "this", "their",
  "they", "but", "not", "what", "who", "which", "when", "where", "how",
  "all", "been", "had", "her", "him", "his", "more", "new", "about",
]);

const MAX_CANDIDATES = 200;
const MAX_QUERY_TOKENS = 10;
const TOP_K_RESULTS = 10;
const MAX_LAZY_EMBEDDINGS = 5;

// ============================================================================
// Query Token Extraction
// ============================================================================

/**
 * Extract search tokens from a question for lexical narrowing
 */
export function extractQueryTokens(question: string): string[] {
  const tokens = question
    .toLowerCase()
    .split(/[^a-z0-9]+/)
    .filter((t) => t.length >= 2 && !STOPWORDS.has(t) && !/^\d+$/.test(t));

  return [...new Set(tokens)].slice(0, MAX_QUERY_TOKENS);
}

// ============================================================================
// Time Window Calculation
// ============================================================================

/**
 * Get the cutoff timestamp for a time window
 */
export function getTimeWindowCutoff(scope: "today" | "7d" | "30d"): Timestamp {
  const now = new Date();
  let hoursBack: number;

  switch (scope) {
    case "today":
      hoursBack = 36; // 36 hours to catch late evening articles
      break;
    case "7d":
      hoursBack = 7 * 24;
      break;
    case "30d":
      hoursBack = 30 * 24;
      break;
  }

  const cutoff = new Date(now.getTime() - hoursBack * 60 * 60 * 1000);
  return Timestamp.fromDate(cutoff);
}

// ============================================================================
// Cosine Similarity
// ============================================================================

/**
 * Compute cosine similarity between two vectors
 */
export function cosineSimilarity(a: number[], b: number[]): number {
  if (a.length !== b.length) return 0;

  let dotProduct = 0;
  let normA = 0;
  let normB = 0;

  for (let i = 0; i < a.length; i++) {
    dotProduct += a[i] * b[i];
    normA += a[i] * a[i];
    normB += b[i] * b[i];
  }

  const denominator = Math.sqrt(normA) * Math.sqrt(normB);
  return denominator === 0 ? 0 : dotProduct / denominator;
}

// ============================================================================
// Candidate Fetching
// ============================================================================

/**
 * Fetch candidate articles from Firestore
 *
 * Note: We use a simple query without searchTokens filter to avoid
 * complex composite index requirements. Semantic reranking handles relevance.
 */
export async function fetchCandidateArticles(
  scope: RagScope,
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _queryTokens: string[]
): Promise<Article[]> {
  const db = getFirestore();
  const cutoff = getTimeWindowCutoff(scope.timeWindow);

  // Base query: relevant articles within time window
  let query = db
    .collection("articles")
    .where("isRelevant", "==", true)
    .where("publishedAt", ">=", cutoff)
    .orderBy("publishedAt", "desc");

  // Add source filter if provided (uses existing index)
  if (scope.sourceIds && scope.sourceIds.length > 0) {
    query = query.where("sourceId", "in", scope.sourceIds.slice(0, 10));
  }

  // Note: We skip category and searchTokens filters to avoid complex indexes
  // Semantic reranking will handle relevance filtering

  const snapshot = await query.limit(MAX_CANDIDATES).get();

  // If category filter requested, apply in-memory
  let articles = snapshot.docs.map((doc) => ({ id: doc.id, ...doc.data() } as Article));

  if (scope.category && scope.category !== "all") {
    articles = articles.filter((a) =>
      a.categories?.includes(scope.category as Article["categories"][number])
    );
  }

  logger.info("Fetched candidate articles", {
    count: articles.length,
    scope: scope.timeWindow,
    category: scope.category,
    sourceFilter: scope.sourceIds?.length ?? 0,
  });

  return articles;
}

// ============================================================================
// Reranking with Source Diversity
// ============================================================================

interface RankedArticle {
  article: Article;
  score: number;
}

/**
 * Rerank candidates by semantic similarity with source diversity
 */
export async function rerankBySimilarity(
  candidates: Article[],
  questionEmbedding: number[]
): Promise<Article[]> {
  // Ensure embeddings exist for candidates (lazy compute top few)
  let lazyComputed = 0;
  for (const article of candidates) {
    if (!article.embedding && lazyComputed < MAX_LAZY_EMBEDDINGS) {
      try {
        await ensureArticleVector(article.id);
        lazyComputed++;
      } catch (err) {
        logger.warn("Failed to compute embedding", { articleId: article.id, error: err });
      }
    }
  }

  // Re-fetch articles if we computed embeddings
  if (lazyComputed > 0) {
    const db = getFirestore();
    const articleIds = candidates.map((a) => a.id);
    const freshDocs = await Promise.all(
      articleIds.map((id) => db.collection("articles").doc(id).get())
    );
    candidates = freshDocs
      .filter((doc) => doc.exists)
      .map((doc) => ({ id: doc.id, ...doc.data() } as Article));
  }

  // Score by cosine similarity
  const ranked: RankedArticle[] = candidates
    .filter((a) => a.embedding?.vector)
    .map((article) => ({
      article,
      score: cosineSimilarity(questionEmbedding, article.embedding!.vector),
    }))
    .sort((a, b) => b.score - a.score);

  // Select top K with source diversity (max 3 per source)
  const selected: Article[] = [];
  const sourceCounts: Record<string, number> = {};

  for (const { article } of ranked) {
    if (selected.length >= TOP_K_RESULTS) break;

    const sourceCount = sourceCounts[article.sourceId] || 0;
    if (sourceCount < 3) {
      selected.push(article);
      sourceCounts[article.sourceId] = sourceCount + 1;
    }
  }

  logger.info("Reranked articles", {
    candidatesWithEmbeddings: ranked.length,
    selected: selected.length,
    lazyComputed,
  });

  return selected;
}

// ============================================================================
// Context Building
// ============================================================================

/**
 * Build compact context pack for RAG prompt
 */
export function buildContextPack(articles: Article[]): ArticleContext[] {
  return articles.map((article) => ({
    id: article.id,
    title: article.title,
    sourceName: article.sourceName,
    url: article.url,
    publishedAt: article.publishedAt.toDate().toISOString().split("T")[0],
    snippet: article.snippet.slice(0, 300),
    tldr: article.ai?.tldr || null,
  }));
}

/**
 * Format context for prompt
 */
export function formatContextForPrompt(context: ArticleContext[]): string {
  return context
    .map((c, i) => {
      const summary = c.tldr || c.snippet;
      return `[${i + 1}] ID:${c.id}
Title: ${c.title}
Source: ${c.sourceName} | ${c.publishedAt}
Summary: ${summary}
URL: ${c.url}`;
    })
    .join("\n\n");
}

// ============================================================================
// Answer Generation
// ============================================================================

const RAG_SYSTEM_PROMPT = `You are a P&C (Property & Casualty) insurance expert assistant. Your role is to answer questions using ONLY the provided article context.

CRITICAL RULES:
1. Answer ONLY using information from the provided articles. Do not use outside knowledge.
2. If the articles don't contain sufficient information to answer, say so clearly.
3. Cite your sources using article IDs (e.g., [1], [2]) inline in your answer.
4. Every fact MUST have a citation. Do not make claims without citing the source article.
5. Be concise and executive-focused. P&C professionals value brevity and actionability.
6. Use industry terminology correctly: combined ratio, loss ratio, rate adequacy, social inflation, nuclear verdicts, etc.
7. Focus on underwriting, claims, reinsurance, and regulatory implications.

OUTPUT FORMAT:
- answerMarkdown: Your answer in markdown format with inline citations [1], [2], etc.
- takeaways: 3-6 key bullet points summarizing the most important insights
- citations: List of articles you actually cited (only include those you referenced)
- followUps: 3 suggested follow-up questions the user might want to ask`;

/**
 * Generate RAG answer using OpenAI
 */
export async function generateRagAnswer(
  question: string,
  context: ArticleContext[],
  history: ChatMessage[]
): Promise<RagAnswerResponse> {
  const openai = getOpenAIClient();

  // Build conversation messages
  const messages: Array<{ role: "system" | "user" | "assistant"; content: string }> = [
    { role: "system", content: RAG_SYSTEM_PROMPT },
  ];

  // Add history (limited)
  const recentHistory = history.slice(-8);
  for (const msg of recentHistory) {
    messages.push({ role: msg.role, content: msg.content });
  }

  // Build the user message with context
  const contextText = formatContextForPrompt(context);
  const userMessage = `ARTICLES FOR CONTEXT:
${contextText}

USER QUESTION:
${question}

Remember: Only use information from the articles above. Cite sources with [1], [2], etc. If insufficient context, acknowledge it.`;

  messages.push({ role: "user", content: userMessage });

  logger.info("Generating RAG answer", {
    questionLength: question.length,
    contextArticles: context.length,
    historyLength: recentHistory.length,
  });

  const response = await openai.chat.completions.create({
    model: AI_MODEL,
    messages,
    response_format: {
      type: "json_schema",
      json_schema: {
        name: "rag_answer",
        strict: true,
        schema: RAG_ANSWER_SCHEMA,
      },
    },
    temperature: 0.3,
    max_tokens: 2000,
  });

  const content = response.choices[0]?.message?.content;
  if (!content) {
    throw new Error("No response content from OpenAI");
  }

  const parsed = JSON.parse(content) as RagAnswerResponse;

  // Map citation indices to actual article data
  const citationsWithData = parsed.citations.map((citation) => {
    const article = context.find((c) => c.id === citation.articleId);
    return {
      articleId: citation.articleId,
      title: article?.title || citation.title,
      sourceName: article?.sourceName || citation.sourceName,
      url: article?.url || citation.url,
      publishedAt: article?.publishedAt || citation.publishedAt,
    };
  });

  return {
    ...parsed,
    citations: citationsWithData,
  };
}

// ============================================================================
// Main RAG Function
// ============================================================================

/**
 * Main entry point for RAG answer generation
 */
export async function answerQuestion(
  question: string,
  scope: RagScope,
  history: ChatMessage[]
): Promise<RagAnswerResponse> {
  // 1. Extract query tokens for lexical narrowing
  const queryTokens = extractQueryTokens(question);
  logger.info("Extracted query tokens", { tokens: queryTokens });

  // 2. Fetch candidate articles
  const candidates = await fetchCandidateArticles(scope, queryTokens);

  if (candidates.length === 0) {
    return {
      answerMarkdown: "I couldn't find any relevant articles in the selected time period and sources. Try expanding your search scope or adjusting the filters.",
      takeaways: ["No matching articles found for this query"],
      citations: [],
      followUps: [
        "Try searching in a broader time range (7d or 30d)",
        "Remove category or source filters",
        "Rephrase your question with different keywords",
      ],
    };
  }

  // 3. Embed the question
  const questionEmbedding = await embedText(question, DEFAULT_EMBEDDING_DIMS);

  // 4. Rerank by similarity with source diversity
  const topArticles = await rerankBySimilarity(candidates, questionEmbedding);

  if (topArticles.length === 0) {
    return {
      answerMarkdown: "I found some articles but none had embeddings for semantic search. This may be a temporary issue.",
      takeaways: ["Search index may need updating"],
      citations: [],
      followUps: ["Try again in a few minutes", "Contact support if the issue persists"],
    };
  }

  // 5. Build context pack
  const context = buildContextPack(topArticles);

  // 6. Generate answer
  const answer = await generateRagAnswer(question, context, history);

  return answer;
}

// ============================================================================
// Streaming RAG Generation
// ============================================================================

/**
 * Streaming system prompt - similar to RAG but optimized for streaming
 * We cannot use structured JSON output with streaming, so we use a different approach:
 * Stream the answer text first, then collect metadata at the end
 */
const RAG_STREAMING_SYSTEM_PROMPT = `You are a P&C (Property & Casualty) insurance expert assistant. Your role is to answer questions using ONLY the provided article context.

CRITICAL RULES:
1. Answer ONLY using information from the provided articles. Do not use outside knowledge.
2. If the articles don't contain sufficient information to answer, say so clearly.
3. Cite your sources using article IDs (e.g., [1], [2]) inline in your answer.
4. Every fact MUST have a citation. Do not make claims without citing the source article.
5. Be concise and executive-focused. P&C professionals value brevity and actionability.
6. Use industry terminology correctly: combined ratio, loss ratio, rate adequacy, social inflation, nuclear verdicts, etc.
7. Focus on underwriting, claims, reinsurance, and regulatory implications.

Write your answer directly in markdown format. Include inline citations like [1], [2], etc.`;

/**
 * Perform retrieval for streaming - returns context and metadata needed for streaming
 */
export async function performRetrieval(
  question: string,
  scope: RagScope,
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _history: ChatMessage[]
): Promise<{
  context: ArticleContext[];
  noResults: boolean;
  noResultsResponse?: RagAnswerResponse;
}> {
  // 1. Extract query tokens for lexical narrowing
  const queryTokens = extractQueryTokens(question);
  logger.info("Extracted query tokens", { tokens: queryTokens });

  // 2. Fetch candidate articles
  const candidates = await fetchCandidateArticles(scope, queryTokens);

  if (candidates.length === 0) {
    return {
      context: [],
      noResults: true,
      noResultsResponse: {
        answerMarkdown: "I couldn't find any relevant articles in the selected time period and sources. Try expanding your search scope or adjusting the filters.",
        takeaways: ["No matching articles found for this query"],
        citations: [],
        followUps: [
          "Try searching in a broader time range (7d or 30d)",
          "Remove category or source filters",
          "Rephrase your question with different keywords",
        ],
      },
    };
  }

  // 3. Embed the question
  const questionEmbedding = await embedText(question, DEFAULT_EMBEDDING_DIMS);

  // 4. Rerank by similarity with source diversity
  const topArticles = await rerankBySimilarity(candidates, questionEmbedding);

  if (topArticles.length === 0) {
    return {
      context: [],
      noResults: true,
      noResultsResponse: {
        answerMarkdown: "I found some articles but none had embeddings for semantic search. This may be a temporary issue.",
        takeaways: ["Search index may need updating"],
        citations: [],
        followUps: ["Try again in a few minutes", "Contact support if the issue persists"],
      },
    };
  }

  // 5. Build context pack
  const context = buildContextPack(topArticles);

  return { context, noResults: false };
}

/**
 * Stream RAG answer using OpenAI streaming API
 * Writes SSE events directly to the response
 */
export async function streamRagAnswer(
  res: Response,
  question: string,
  context: ArticleContext[],
  history: ChatMessage[]
): Promise<void> {
  const openai = getOpenAIClient();

  // Build conversation messages
  const messages: Array<{ role: "system" | "user" | "assistant"; content: string }> = [
    { role: "system", content: RAG_STREAMING_SYSTEM_PROMPT },
  ];

  // Add history (limited)
  const recentHistory = history.slice(-8);
  for (const msg of recentHistory) {
    messages.push({ role: msg.role, content: msg.content });
  }

  // Build the user message with context
  const contextText = formatContextForPrompt(context);
  const userMessage = `ARTICLES FOR CONTEXT:
${contextText}

USER QUESTION:
${question}

Remember: Only use information from the articles above. Cite sources with [1], [2], etc. If insufficient context, acknowledge it.`;

  messages.push({ role: "user", content: userMessage });

  logger.info("Starting streaming RAG answer", {
    questionLength: question.length,
    contextArticles: context.length,
    historyLength: recentHistory.length,
  });

  let fullContent = "";

  // Stream from OpenAI
  const stream = await openai.chat.completions.create({
    model: AI_MODEL,
    messages,
    stream: true,
    temperature: 0.3,
    max_tokens: 2000,
  });

  for await (const chunk of stream) {
    const content = chunk.choices[0]?.delta?.content || "";
    if (content) {
      fullContent += content;
      // Send SSE data event
      res.write(`data: ${JSON.stringify({ text: content })}\n\n`);
    }
  }

  // Extract citations from context based on what was referenced
  const citedIndices = new Set<number>();
  const citationRegex = /\[(\d+)\]/g;
  let match;
  while ((match = citationRegex.exec(fullContent)) !== null) {
    const idx = parseInt(match[1], 10);
    if (idx >= 1 && idx <= context.length) {
      citedIndices.add(idx);
    }
  }

  const citations: RagCitation[] = Array.from(citedIndices)
    .sort((a, b) => a - b)
    .map((idx) => {
      const article = context[idx - 1];
      return {
        articleId: article.id,
        title: article.title,
        sourceName: article.sourceName,
        url: article.url,
        publishedAt: article.publishedAt,
      };
    });

  // Generate takeaways and follow-ups (quick non-streaming call)
  const metadataResponse = await openai.chat.completions.create({
    model: AI_MODEL,
    messages: [
      {
        role: "system",
        content: "You extract key takeaways and suggest follow-up questions from an AI-generated answer about P&C insurance news. Output valid JSON only.",
      },
      {
        role: "user",
        content: `Based on this answer about "${question}":

${fullContent}

Provide exactly:
- 3-5 key takeaways as bullet points
- 3 follow-up questions the user might want to ask

Return JSON: {"takeaways": ["..."], "followUps": ["..."]}`,
      },
    ],
    response_format: { type: "json_object" },
    temperature: 0.3,
    max_tokens: 500,
  });

  let takeaways: string[] = [];
  let followUps: string[] = [];

  try {
    const metaContent = metadataResponse.choices[0]?.message?.content || "{}";
    const parsed = JSON.parse(metaContent);
    takeaways = parsed.takeaways || [];
    followUps = parsed.followUps || [];
  } catch {
    logger.warn("Failed to parse metadata response");
    takeaways = ["See the answer above for key insights"];
    followUps = ["What else would you like to know?"];
  }

  // Send done event with metadata
  const donePayload = {
    citations,
    takeaways,
    followUps,
    answerMarkdown: fullContent,
  };

  res.write(`event: done\ndata: ${JSON.stringify(donePayload)}\n\n`);

  logger.info("Streaming RAG answer complete", {
    answerLength: fullContent.length,
    citationCount: citations.length,
  });
}


=================================================================================
FILE: functions/src/scripts/backfill-and-brief.ts
=================================================================================

/**
 * Backfill and Generate Brief Script
 *
 * One-time admin command to:
 * 1. Backfill articles from the last 7 days
 * 2. Generate today's daily brief
 *
 * Run with:
 *   cd functions
 *   npm run build
 *   GOOGLE_APPLICATION_CREDENTIALS=/path/to/service-account.json node lib/scripts/backfill-and-brief.js
 *
 * Or with default credentials (if running on GCP or with gcloud auth):
 *   node lib/scripts/backfill-and-brief.js
 *
 * Safety:
 * - Articles are deduplicated by canonical URL hash (safe to re-run)
 * - Brief generation skips if brief already exists for today
 */

import { initializeApp, getApps } from "firebase-admin/app";
import { getFirestore, Timestamp } from "firebase-admin/firestore";
import OpenAI from "openai";
import { ingestAllEnabledSources } from "../lib/ingestion/index.js";
import {
  AI_MODEL,
  DAILY_BRIEF_SCHEMA,
  DAILY_BRIEF_SYSTEM,
  buildDailyBriefPrompt,
  type DailyBriefResponse,
} from "../lib/ai/index.js";
import type { Article, Brief } from "../types/firestore.js";

// Initialize Firebase Admin if not already initialized
if (getApps().length === 0) {
  initializeApp();
}

const db = getFirestore();

// ============================================================================
// Helper Functions
// ============================================================================

function getTodayDateET(): string {
  const now = new Date();
  const formatter = new Intl.DateTimeFormat("en-CA", {
    timeZone: "America/New_York",
    year: "numeric",
    month: "2-digit",
    day: "2-digit",
  });
  return formatter.format(now);
}

// ============================================================================
// Main Script
// ============================================================================

async function main(): Promise<void> {
  console.log("🚀 Starting backfill and brief generation...\n");

  // Step 1: Backfill last 7 days
  console.log("📥 Step 1: Backfilling articles from last 7 days...\n");

  const ingestionSummary = await ingestAllEnabledSources({
    maxAgeDays: 7,
    forceRefresh: true,
  });

  console.log("\n=== Ingestion Summary ===");
  console.log(`Duration: ${ingestionSummary.durationMs}ms`);
  console.log(`Sources processed: ${ingestionSummary.sourcesProcessed}`);
  console.log(`Total items fetched: ${ingestionSummary.totalItemsFetched}`);
  console.log(`Total items ingested: ${ingestionSummary.totalItemsIngested}`);

  for (const r of ingestionSummary.results) {
    const status = r.success ? "✅" : "❌";
    console.log(
      `  ${status} ${r.sourceName}: ${r.itemsIngested} new, ${r.itemsDuplicate} duplicates`
    );
    if (r.error) console.log(`     Error: ${r.error}`);
  }

  // Step 2: Generate today's brief
  console.log("\n📝 Step 2: Generating today's brief...\n");

  const dateKey = getTodayDateET();
  const briefRef = db.collection("briefs").doc(dateKey);
  const existingBrief = await briefRef.get();

  if (existingBrief.exists) {
    console.log(`⏭️  Brief already exists for ${dateKey}, skipping generation.`);
    console.log("\n✅ Backfill complete! Brief was already generated.");
    return;
  }

  // Check for OpenAI API key
  const openaiApiKey = process.env.OPENAI_API_KEY;
  if (!openaiApiKey) {
    console.log("⚠️  OPENAI_API_KEY not set. Skipping brief generation.");
    console.log("   Set it with: export OPENAI_API_KEY=your-key");
    console.log("\n✅ Backfill complete! Run brief generation separately.");
    return;
  }

  // Fetch articles from last 36 hours
  const cutoffTime = new Date(Date.now() - 36 * 60 * 60 * 1000);
  const articlesSnap = await db
    .collection("articles")
    .where("isRelevant", "==", true)
    .where("publishedAt", ">=", Timestamp.fromDate(cutoffTime))
    .orderBy("publishedAt", "desc")
    .limit(60)
    .get();

  if (articlesSnap.empty) {
    console.log(`⚠️  No relevant articles found for ${dateKey}`);
    console.log("\n✅ Backfill complete! No articles to generate brief from.");
    return;
  }

  console.log(`Found ${articlesSnap.size} articles for brief generation`);

  // Prepare article data
  const articles = articlesSnap.docs.map((doc) => {
    const data = doc.data() as Article;
    return {
      id: doc.id,
      title: data.title,
      sourceName: data.sourceName,
      sourceId: data.sourceId,
      snippet: data.snippet,
    };
  });

  // Build sources map
  const sourceMap = new Map<string, string>();
  articles.forEach((a) => {
    if (!sourceMap.has(a.sourceId)) {
      sourceMap.set(a.sourceId, a.sourceName);
    }
  });

  // Generate brief using OpenAI
  console.log("Calling OpenAI to generate brief...");

  const openai = new OpenAI({ apiKey: openaiApiKey });
  const prompt = buildDailyBriefPrompt(dateKey, articles);

  const response = await openai.responses.create({
    model: AI_MODEL,
    input: [
      { role: "system", content: DAILY_BRIEF_SYSTEM },
      { role: "user", content: prompt },
    ],
    text: {
      format: {
        type: "json_schema",
        name: "daily_brief",
        schema: DAILY_BRIEF_SCHEMA,
        strict: true,
      },
    },
  });

  const briefData = JSON.parse(response.output_text) as DailyBriefResponse;

  // Build the brief document
  const brief: Brief = {
    date: dateKey,
    createdAt: Timestamp.now(),
    executiveSummary: briefData.executiveSummary,
    topStories: briefData.topStories,
    sections: briefData.sections,
    topics: briefData.topics,
    sourcesUsed: Array.from(sourceMap.entries()).map(([sourceId, name]) => ({
      sourceId,
      name,
    })),
    sourceArticleIds: articles.map((a) => a.id),
    model: AI_MODEL,
  };

  // Save to Firestore
  await briefRef.set(brief);

  console.log(`\n✅ Brief created for ${dateKey}!`);
  console.log(`   - ${brief.executiveSummary.length} summary items`);
  console.log(`   - ${brief.topStories.length} top stories`);
  console.log(`   - ${brief.topics.length} topics`);
  console.log(`   - ${brief.sourceArticleIds.length} source articles`);

  console.log("\n🎉 Backfill and brief generation complete!");
}

// ============================================================================
// Run
// ============================================================================

main()
  .then(() => {
    process.exit(0);
  })
  .catch((error) => {
    console.error("\n❌ Error:", error);
    process.exit(1);
  });



=================================================================================
FILE: functions/src/scripts/backfill-embeddings.ts
=================================================================================

#!/usr/bin/env node
/**
 * Backfill Embeddings Script
 *
 * Standalone script to backfill embeddings for articles.
 * Run with: npm run backfill-embeddings
 *
 * Usage:
 *   npm run backfill-embeddings              # Default: 50 articles, 30 days
 *   npm run backfill-embeddings -- --limit=100 --days=7
 */

import { initializeApp, getApps } from "firebase-admin/app";
import { getFirestore, Timestamp } from "firebase-admin/firestore";
import OpenAI from "openai";
import type { Article } from "../types/firestore.js";

// Initialize Firebase Admin if not already initialized
if (getApps().length === 0) {
  initializeApp();
}

const db = getFirestore();

// ============================================================================
// Constants
// ============================================================================

const EMBEDDING_MODEL = "text-embedding-3-small";
const DEFAULT_DIMS = 256;

const STOPWORDS = new Set([
  "a", "an", "and", "are", "as", "at", "be", "by", "for", "from",
  "has", "have", "he", "in", "is", "it", "its", "of", "on", "or",
  "that", "the", "to", "was", "were", "will", "with", "this", "their",
  "they", "but", "not", "what", "who", "which", "when", "where", "how",
  "all", "been", "being", "had", "her", "him", "his", "more", "new",
  "one", "our", "out", "said", "she", "some", "than", "them", "then",
  "there", "these", "we", "you", "your", "can", "could", "into", "may",
  "no", "so", "up", "very", "would", "about", "after", "also", "any",
]);

// ============================================================================
// Helper Functions
// ============================================================================

function generateSearchTokens(article: { title: string; snippet: string }): string[] {
  const text = `${article.title} ${article.snippet}`;
  const tokens = text
    .toLowerCase()
    .split(/[^a-z0-9]+/)
    .filter((t) => t.length >= 2 && !STOPWORDS.has(t) && !/^\d+$/.test(t));
  return [...new Set(tokens)].slice(0, 50);
}

async function embedText(openai: OpenAI, text: string, dims = DEFAULT_DIMS): Promise<number[]> {
  const response = await openai.embeddings.create({
    model: EMBEDDING_MODEL,
    input: text,
    dimensions: dims,
  });
  return response.data[0].embedding;
}

// ============================================================================
// Main Script
// ============================================================================

async function main() {
  // Parse args
  const args = process.argv.slice(2);
  let limit = 50;
  let daysBack = 30;

  for (const arg of args) {
    if (arg.startsWith("--limit=")) {
      limit = parseInt(arg.replace("--limit=", ""), 10);
    } else if (arg.startsWith("--days=")) {
      daysBack = parseInt(arg.replace("--days=", ""), 10);
    }
  }

  console.log("\n🔢 Backfill Embeddings");
  console.log(`   Limit: ${limit} articles`);
  console.log(`   Days back: ${daysBack}`);
  console.log(`   Model: ${EMBEDDING_MODEL}`);
  console.log(`   Dimensions: ${DEFAULT_DIMS}\n`);

  // Check for OpenAI API key
  const apiKey = process.env.OPENAI_API_KEY;
  if (!apiKey) {
    console.error("❌ OPENAI_API_KEY environment variable not set");
    process.exit(1);
  }

  const openai = new OpenAI({ apiKey });

  // Calculate cutoff
  const cutoffDate = new Date();
  cutoffDate.setDate(cutoffDate.getDate() - daysBack);
  const cutoffTimestamp = Timestamp.fromDate(cutoffDate);

  // Query articles
  console.log("📋 Querying articles...");
  const snapshot = await db
    .collection("articles")
    .where("isRelevant", "==", true)
    .where("publishedAt", ">=", cutoffTimestamp)
    .orderBy("publishedAt", "desc")
    .limit(limit * 2)
    .get();

  console.log(`   Found ${snapshot.size} relevant articles to check\n`);

  let processed = 0;
  let embeddingsCreated = 0;
  let searchTokensCreated = 0;
  let skipped = 0;

  for (const doc of snapshot.docs) {
    if (processed >= limit) break;

    const article = doc.data() as Article;

    // Skip if already has embedding
    if (article.embedding) {
      skipped++;
      continue;
    }

    try {
      const updates: Record<string, unknown> = {};

      // Generate searchTokens if missing
      if (!article.searchTokens || article.searchTokens.length === 0) {
        updates.searchTokens = generateSearchTokens(article);
        searchTokensCreated++;
      }

      // Generate embedding
      const textToEmbed = `${article.title}\n${article.snippet}`;
      const vector = await embedText(openai, textToEmbed);

      updates.embedding = {
        dims: DEFAULT_DIMS,
        vector,
        model: EMBEDDING_MODEL,
        updatedAt: Timestamp.now(),
      };
      embeddingsCreated++;

      await doc.ref.update(updates);
      processed++;

      if (processed % 10 === 0) {
        console.log(`   Progress: ${processed}/${limit} (${embeddingsCreated} embeddings)`);
      }
    } catch (error) {
      console.error(`   ❌ Error processing ${doc.id}:`, error);
    }
  }

  console.log("\n✅ Completed!");
  console.log(`   Processed: ${processed}`);
  console.log(`   Embeddings created: ${embeddingsCreated}`);
  console.log(`   SearchTokens created: ${searchTokensCreated}`);
  console.log(`   Already had embedding: ${skipped}\n`);
}

main().catch(console.error);



=================================================================================
FILE: functions/src/scripts/check-data.ts
=================================================================================

/**
 * Check Data Script
 * Verifies the production data is ready
 */

import { initializeApp, getApps } from "firebase-admin/app";
import { getFirestore } from "firebase-admin/firestore";

if (getApps().length === 0) {
  initializeApp();
}

const db = getFirestore();

async function main(): Promise<void> {
  console.log("🔍 Checking production data...\n");

  // Check sources
  const sources = await db.collection("sources").get();
  console.log("=== SOURCES ===");
  let enabledCount = 0;
  sources.forEach((doc) => {
    const d = doc.data();
    if (d.enabled) enabledCount++;
    const lastFetched = d.lastFetchedAt?.toDate?.()?.toISOString() || "never";
    console.log(`  ${d.enabled ? "✅" : "⏸️ "} ${d.name} (lastFetched: ${lastFetched})`);
  });
  console.log(`  Total: ${sources.size} sources (${enabledCount} enabled)\n`);

  // Check articles count
  const articlesCount = await db.collection("articles").count().get();
  console.log(`=== ARTICLES: ${articlesCount.data().count} total ===`);

  // Check recent articles
  const recentArticles = await db
    .collection("articles")
    .orderBy("publishedAt", "desc")
    .limit(5)
    .get();
  console.log("Recent articles:");
  recentArticles.forEach((doc) => {
    const d = doc.data();
    const title = d.title?.substring(0, 55) || "No title";
    const date = d.publishedAt?.toDate?.()?.toISOString()?.split("T")[0] || "unknown";
    console.log(`  - ${title}... (${date})`);
  });

  // Check briefs
  const briefs = await db.collection("briefs").orderBy("date", "desc").limit(5).get();
  console.log(`\n=== BRIEFS: ${briefs.size} found ===`);
  briefs.forEach((doc) => {
    const d = doc.data();
    console.log(
      `  - ${doc.id}: ${d.topStories?.length || 0} top stories, ${d.executiveSummary?.length || 0} summary items`
    );
  });

  // Summary
  console.log("\n=== PRODUCTION READINESS ===");
  const issues: string[] = [];

  if (sources.size === 0) issues.push("❌ No sources configured");
  else if (enabledCount === 0) issues.push("❌ No sources enabled");

  if (articlesCount.data().count === 0) issues.push("❌ No articles ingested");
  else if (articlesCount.data().count < 10) issues.push("⚠️  Only " + articlesCount.data().count + " articles");

  if (briefs.size === 0) issues.push("❌ No briefs generated");

  if (issues.length === 0) {
    console.log("✅ All systems ready for production!");
  } else {
    issues.forEach((i) => console.log(i));
  }
}

main()
  .then(() => process.exit(0))
  .catch((e) => {
    console.error("Error:", e);
    process.exit(1);
  });



=================================================================================
FILE: functions/src/scripts/regenerate-brief.ts
=================================================================================

/**
 * Regenerate Brief Script
 * Deletes existing brief and regenerates with current articles
 */

import { initializeApp, getApps } from "firebase-admin/app";
import { getFirestore, Timestamp } from "firebase-admin/firestore";
import OpenAI from "openai";
import {
  AI_MODEL,
  DAILY_BRIEF_SCHEMA,
  DAILY_BRIEF_SYSTEM,
  buildDailyBriefPrompt,
  type DailyBriefResponse,
} from "../lib/ai/index.js";
import type { Article, Brief } from "../types/firestore.js";

if (getApps().length === 0) {
  initializeApp();
}

const db = getFirestore();

function getTodayDateET(): string {
  const now = new Date();
  const formatter = new Intl.DateTimeFormat("en-CA", {
    timeZone: "America/New_York",
    year: "numeric",
    month: "2-digit",
    day: "2-digit",
  });
  return formatter.format(now);
}

async function main(): Promise<void> {
  const dateKey = process.argv[2] || getTodayDateET();
  console.log(`🔄 Regenerating brief for ${dateKey}...\n`);

  const openaiApiKey = process.env.OPENAI_API_KEY;
  if (!openaiApiKey) {
    console.error("❌ OPENAI_API_KEY not set");
    process.exit(1);
  }

  // Delete existing brief
  const briefRef = db.collection("briefs").doc(dateKey);
  const existing = await briefRef.get();
  if (existing.exists) {
    console.log("🗑️  Deleting existing brief...");
    await briefRef.delete();
  }

  // Fetch articles from last 7 days (more generous window)
  const cutoffTime = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000);
  
  // First try with isRelevant filter
  let articlesSnap = await db
    .collection("articles")
    .where("isRelevant", "==", true)
    .where("publishedAt", ">=", Timestamp.fromDate(cutoffTime))
    .orderBy("publishedAt", "desc")
    .limit(60)
    .get();

  // If not enough relevant articles, get all articles
  if (articlesSnap.size < 10) {
    console.log(`⚠️  Only ${articlesSnap.size} relevant articles, fetching all articles...`);
    articlesSnap = await db
      .collection("articles")
      .where("publishedAt", ">=", Timestamp.fromDate(cutoffTime))
      .orderBy("publishedAt", "desc")
      .limit(60)
      .get();
  }

  console.log(`📰 Found ${articlesSnap.size} articles for brief generation`);

  if (articlesSnap.empty) {
    console.log("❌ No articles found");
    return;
  }

  // Prepare article data
  const articles = articlesSnap.docs.map((doc) => {
    const data = doc.data() as Article;
    return {
      id: doc.id,
      title: data.title,
      sourceName: data.sourceName,
      sourceId: data.sourceId,
      snippet: data.snippet,
    };
  });

  // Build sources map
  const sourceMap = new Map<string, string>();
  articles.forEach((a) => {
    if (!sourceMap.has(a.sourceId)) {
      sourceMap.set(a.sourceId, a.sourceName);
    }
  });

  // Generate brief using OpenAI
  console.log("🤖 Calling OpenAI to generate brief...");

  const openai = new OpenAI({ apiKey: openaiApiKey });
  const prompt = buildDailyBriefPrompt(dateKey, articles);

  const response = await openai.responses.create({
    model: AI_MODEL,
    input: [
      { role: "system", content: DAILY_BRIEF_SYSTEM },
      { role: "user", content: prompt },
    ],
    text: {
      format: {
        type: "json_schema",
        name: "daily_brief",
        schema: DAILY_BRIEF_SCHEMA,
        strict: true,
      },
    },
  });

  const briefData = JSON.parse(response.output_text) as DailyBriefResponse;

  // Build the brief document
  const brief: Brief = {
    date: dateKey,
    createdAt: Timestamp.now(),
    executiveSummary: briefData.executiveSummary,
    topStories: briefData.topStories,
    sections: briefData.sections,
    topics: briefData.topics,
    sourcesUsed: Array.from(sourceMap.entries()).map(([sourceId, name]) => ({
      sourceId,
      name,
    })),
    sourceArticleIds: articles.map((a) => a.id),
    model: AI_MODEL,
  };

  // Save to Firestore
  await briefRef.set(brief);

  console.log(`\n✅ Brief regenerated for ${dateKey}!`);
  console.log(`   - ${brief.executiveSummary.length} summary items`);
  console.log(`   - ${brief.topStories.length} top stories`);
  console.log(`   - ${brief.topics.length} topics`);
  console.log(`   - ${brief.sourceArticleIds.length} source articles`);
}

main()
  .then(() => process.exit(0))
  .catch((e) => {
    console.error("Error:", e);
    process.exit(1);
  });



=================================================================================
FILE: functions/src/scripts/seed-sources.ts
=================================================================================

/**
 * Seed Initial Sources Script
 *
 * Run with: npx ts-node src/scripts/seed-sources.ts
 * Or after build: node lib/scripts/seed-sources.js
 *
 * This script upserts the initial reputable sources into Firestore.
 * It uses the Firebase Admin SDK and requires GOOGLE_APPLICATION_CREDENTIALS
 * or running in a Firebase environment.
 */

import { initializeApp, getApps } from "firebase-admin/app";
import { getFirestore, Timestamp } from "firebase-admin/firestore";
import type { SourceCategory } from "../types/firestore.js";

// Initialize Firebase Admin if not already initialized
if (getApps().length === 0) {
  // In production, uses GOOGLE_APPLICATION_CREDENTIALS or default credentials
  // For local dev, you can set GOOGLE_APPLICATION_CREDENTIALS to a service account key
  initializeApp();
}

const db = getFirestore();

// ============================================================================
// Source Definitions
// ============================================================================

interface SourceSeed {
  id: string;
  name: string;
  siteUrl: string;
  rssUrl: string;
  rssUrls?: string[];
  enabled: boolean;
  enabledByDefault: boolean;
  tags: SourceCategory[];
  region?: string;
}

const REPUTABLE_SOURCES: SourceSeed[] = [
  // === ORIGINAL SOURCES ===
  {
    id: "insurance-journal",
    name: "Insurance Journal",
    siteUrl: "https://www.insurancejournal.com",
    rssUrl: "https://www.insurancejournal.com/rss/news/",
    enabled: true,
    enabledByDefault: true,
    tags: ["property_cat", "casualty_liability", "regulation", "claims"],
  },
  {
    id: "claims-journal",
    name: "Claims Journal",
    siteUrl: "https://www.claimsjournal.com",
    rssUrl: "https://www.claimsjournal.com/rss/news/",
    enabled: true,
    enabledByDefault: true,
    tags: ["claims", "casualty_liability"],
  },
  {
    id: "artemis",
    name: "Artemis",
    siteUrl: "https://www.artemis.bm",
    rssUrl: "https://www.artemis.bm/feed/",
    enabled: true,
    enabledByDefault: true,
    tags: ["reinsurance", "property_cat"],
  },
  // === NEW SOURCES ===
  {
    id: "carrier-management",
    name: "Carrier Management",
    siteUrl: "https://www.carriermanagement.com",
    rssUrl: "https://www.carriermanagement.com/feed",
    enabled: true,
    enabledByDefault: true,
    tags: ["property_cat", "claims", "insurtech", "reinsurance"],
  },
  {
    id: "business-insurance",
    name: "Business Insurance",
    siteUrl: "https://www.businessinsurance.com",
    rssUrl: "https://www.businessinsurance.com/section/rss?feed=NEWS",
    rssUrls: [
      "https://www.businessinsurance.com/section/rss?feed=NEWS",
      "https://www.businessinsurance.com/section/rss?feed=NEWS06",
      "https://www.businessinsurance.com/section/rss?feed=NEWS08",
      "https://www.businessinsurance.com/section/rss?feed=GLOBAL",
    ],
    enabled: false, // Disabled: RSS feeds return 403 Forbidden
    enabledByDefault: false,
    tags: ["property_cat", "casualty_liability", "regulation"],
  },
  {
    id: "insurance-business-us",
    name: "Insurance Business (US)",
    siteUrl: "https://www.insurancebusinessmag.com/us/",
    rssUrl: "https://www.insurancebusinessmag.com/us/rss",
    enabled: true,
    enabledByDefault: true,
    tags: ["property_cat", "casualty_liability", "regulation"],
  },
  {
    id: "risk-and-insurance",
    name: "Risk & Insurance",
    siteUrl: "https://riskandinsurance.com",
    rssUrl: "https://riskandinsurance.com/feed",
    enabled: true,
    enabledByDefault: true,
    tags: ["claims", "insurtech"],
  },
];

// Optional sources - disabled by default
const OPTIONAL_SOURCES: SourceSeed[] = [
  {
    id: "canadian-underwriter",
    name: "Canadian Underwriter",
    siteUrl: "https://www.canadianunderwriter.ca",
    rssUrl: "https://www.canadianunderwriter.ca/news/feed",
    rssUrls: [
      "https://www.canadianunderwriter.ca/news/feed",
      "https://www.canadianunderwriter.ca/global-category/property/feed",
    ],
    enabled: false,
    enabledByDefault: false,
    tags: ["property_cat", "claims"],
    region: "Canada",
  },
  {
    id: "leaders-edge",
    name: "Leader's Edge",
    siteUrl: "https://www.leadersedge.com",
    rssUrl: "https://www.leadersedge.com/category/p-c/feed",
    enabled: false,
    enabledByDefault: false,
    tags: ["property_cat", "casualty_liability"],
  },
];

// ============================================================================
// Seed Function
// ============================================================================

async function seedSources(): Promise<void> {
  console.log("🌱 Starting source seeding...\n");

  const now = Timestamp.now();
  const allSources = [...REPUTABLE_SOURCES, ...OPTIONAL_SOURCES];

  const defaultFetchState = {
    etag: null,
    lastModified: null,
    lastFetchedAt: null,
    lastError: null,
  };

  for (const seed of allSources) {
    const docRef = db.collection("sources").doc(seed.id);
    const existing = await docRef.get();
    const existingData = existing.exists ? existing.data() : null;

    // Build fetchStates for multi-feed sources
    const rssUrlsToUse = seed.rssUrls ?? [seed.rssUrl];
    let fetchStates: Record<string, typeof defaultFetchState> | undefined;
    if (rssUrlsToUse.length > 1) {
      fetchStates = (existingData?.fetchStates as Record<string, typeof defaultFetchState>) ?? {};
      for (const url of rssUrlsToUse) {
        if (!fetchStates![url]) {
          fetchStates![url] = { ...defaultFetchState };
        }
      }
    }

    // Build source data, omitting undefined fields
    const sourceData: Record<string, unknown> = {
      name: seed.name,
      siteUrl: seed.siteUrl,
      rssUrl: seed.rssUrl,
      enabled: seed.enabled,
      enabledByDefault: seed.enabledByDefault,
      tier: "reputable",
      tags: seed.tags,
      createdAt: existingData?.createdAt ?? now,
      updatedAt: now,
      fetchState: existingData?.fetchState ?? defaultFetchState,
    };

    // Only add optional fields if they have values
    if (seed.rssUrls) {
      sourceData.rssUrls = seed.rssUrls;
    }
    if (seed.region) {
      sourceData.region = seed.region;
    }
    if (fetchStates) {
      sourceData.fetchStates = fetchStates;
    }

    await docRef.set({ id: seed.id, ...sourceData }, { merge: true });

    const status = existing.exists ? "updated" : "created";
    const enabledStatus = seed.enabled ? "✅ enabled" : "⏸️  disabled";
    const feedCount = rssUrlsToUse.length > 1 ? ` (${rssUrlsToUse.length} feeds)` : "";
    console.log(`  ${enabledStatus} ${seed.name}${feedCount} (${status})`);
  }

  console.log(`\n✨ Seeded ${allSources.length} sources successfully!`);
}

// ============================================================================
// Main
// ============================================================================

seedSources()
  .then(() => {
    console.log("\n🎉 Done!");
    process.exit(0);
  })
  .catch((error) => {
    console.error("\n❌ Error seeding sources:", error);
    process.exit(1);
  });



=================================================================================
FILE: functions/src/scripts/show-brief.ts
=================================================================================

/**
 * Show Brief Script
 * Displays the current brief content
 */

import { initializeApp, getApps } from "firebase-admin/app";
import { getFirestore } from "firebase-admin/firestore";

if (getApps().length === 0) {
  initializeApp();
}

const db = getFirestore();

function getTodayDateET(): string {
  const now = new Date();
  const formatter = new Intl.DateTimeFormat("en-CA", {
    timeZone: "America/New_York",
    year: "numeric",
    month: "2-digit",
    day: "2-digit",
  });
  return formatter.format(now);
}

async function main(): Promise<void> {
  const dateKey = process.argv[2] || getTodayDateET();
  console.log(`📋 Brief for ${dateKey}\n`);

  const briefDoc = await db.collection("briefs").doc(dateKey).get();

  if (!briefDoc.exists) {
    console.log("❌ No brief found for this date");
    return;
  }

  const brief = briefDoc.data()!;

  console.log("=== EXECUTIVE SUMMARY ===");
  brief.executiveSummary?.forEach((item: string, i: number) => {
    console.log(`  ${i + 1}. ${item}`);
  });

  console.log("\n=== TOP STORIES ===");
  brief.topStories?.forEach((story: { headline: string; whyItMatters: string }, i: number) => {
    console.log(`  ${i + 1}. ${story.headline}`);
    console.log(`     → ${story.whyItMatters}`);
  });

  console.log("\n=== SECTIONS ===");
  const sections = brief.sections || {};
  for (const [key, section] of Object.entries(sections)) {
    const s = section as { bullets: string[]; articleIds: string[] };
    if (s.bullets?.length > 0) {
      console.log(`  ${key}: ${s.bullets.length} bullets, ${s.articleIds?.length || 0} articles`);
    }
  }

  console.log("\n=== TOPICS ===");
  console.log(`  ${brief.topics?.join(", ") || "None"}`);

  console.log("\n=== METADATA ===");
  console.log(`  Model: ${brief.model}`);
  console.log(`  Sources used: ${brief.sourcesUsed?.length || 0}`);
  console.log(`  Source articles: ${brief.sourceArticleIds?.length || 0}`);
}

main()
  .then(() => process.exit(0))
  .catch((e) => {
    console.error("Error:", e);
    process.exit(1);
  });



=================================================================================
FILE: functions/src/scripts/test-ingestion.ts
=================================================================================

/**
 * Test Ingestion Script
 *
 * Run with: npx ts-node src/scripts/test-ingestion.ts
 * Or after build: node lib/scripts/test-ingestion.js
 */

import { initializeApp, getApps } from "firebase-admin/app";
import { ingestAllEnabledSources } from "../lib/ingestion/index.js";

// Initialize Firebase Admin if not already initialized
if (getApps().length === 0) {
  initializeApp();
}

async function testIngestion(): Promise<void> {
  console.log("🚀 Testing ingestion with 7-day lookback...\n");

  const summary = await ingestAllEnabledSources({ maxAgeDays: 7 });

  console.log("\n=== Ingestion Summary ===");
  console.log("Duration:", summary.durationMs, "ms");
  console.log("Sources processed:", summary.sourcesProcessed);
  console.log("Total items fetched:", summary.totalItemsFetched);
  console.log("Total items ingested:", summary.totalItemsIngested);

  console.log("\n=== Per-Source Results ===");
  for (const r of summary.results) {
    console.log(`\n${r.sourceName}:`);
    console.log("  Success:", r.success);
    if (r.notModified) {
      console.log("  Status: Not Modified (304)");
    } else {
      console.log("  Items fetched:", r.itemsFetched);
      console.log("  Items ingested:", r.itemsIngested);
      console.log("  Items skipped:", r.itemsSkipped);
      console.log("  Duplicates:", r.itemsDuplicate);
    }
    if (r.error) console.log("  Error:", r.error);
  }

  console.log("\n✅ Ingestion test complete!");
}

testIngestion()
  .then(() => process.exit(0))
  .catch((e) => {
    console.error("❌ Error:", e);
    process.exit(1);
  });



=================================================================================
FILE: functions/src/types/firestore.ts
=================================================================================

/**
 * Firestore Document Types for P&C Insurance News AI (Cloud Functions)
 *
 * Collections:
 * - sources/{sourceId}
 * - articles/{articleId}
 * - briefs/{yyyy-mm-dd}
 * - users/{uid}
 *   - bookmarks/{articleId}
 *   - prefs/main
 */

import type { Timestamp } from "firebase-admin/firestore";

// ============================================================================
// Sources Collection: sources/{sourceId}
// ============================================================================

export type SourceCategory =
  | "property_cat"
  | "casualty_liability"
  | "regulation"
  | "claims"
  | "reinsurance"
  | "insurtech";

/** Source tier indicating trustworthiness/quality */
export type SourceTier = "reputable" | "community" | "user-submitted";

/** Fetch state for conditional RSS requests */
export interface SourceFetchState {
  /** ETag from last fetch (for conditional requests) */
  etag: string | null;
  /** Last-Modified header from last fetch */
  lastModified: string | null;
  /** Last successful fetch timestamp */
  lastFetchedAt: Timestamp | null;
  /** Last fetch error message (null if successful) */
  lastError: string | null;
}

export interface Source {
  /** Unique identifier (slug-style, e.g., "insurance-journal") */
  id: string;
  /** Display name */
  name: string;
  /** Publisher website URL */
  siteUrl: string;
  /** RSS feed URL (legacy single-feed) */
  rssUrl: string;
  /** RSS feed URLs (supports multiple feeds per source) */
  rssUrls?: string[];
  /** Whether this source is enabled for ingestion */
  enabled: boolean;
  /** Whether this source is enabled by default for new users */
  enabledByDefault?: boolean;
  /** Source tier indicating trustworthiness */
  tier: SourceTier;
  /** Tags for categorization and filtering */
  tags: SourceCategory[];
  /** Region/geography focus (optional) */
  region?: string;
  /** Created timestamp */
  createdAt: Timestamp;
  /** Updated timestamp */
  updatedAt: Timestamp;
  /** Fetch state for conditional requests (keyed by rssUrl for multi-feed) */
  fetchState: SourceFetchState;
  /** Fetch states per RSS URL (for multi-feed sources) */
  fetchStates?: Record<string, SourceFetchState>;
}

// ============================================================================
// Articles Collection: articles/{articleId}
// ============================================================================

export interface Article {
  /** Unique identifier (SHA256 hash of canonical URL or GUID) */
  id: string;
  /** Source ID reference */
  sourceId: string;
  /** Source display name (denormalized for display) */
  sourceName: string;
  /** Article headline/title */
  title: string;
  /** Short snippet/excerpt (≤200 chars, respecting publisher policies) */
  snippet: string;
  /** Original article URL */
  url: string;
  /** Normalized canonical URL (for deduplication) */
  canonicalUrl: string;
  /** RSS GUID if available (fallback for deduplication) */
  guid: string | null;
  /** Article image URL if present in RSS */
  imageUrl: string | null;
  /** Article categories */
  categories: SourceCategory[];
  /** Publication timestamp */
  publishedAt: Timestamp;
  /** When we ingested this article */
  ingestedAt: Timestamp;
  /** P&C relevance score (0-1) from heuristic filter */
  relevanceScore: number;
  /** Whether article passes P&C relevance filter */
  isRelevant: boolean;
  /** AI-generated content (cached, generated on first request) */
  ai: ArticleAI | null;
  /** Vector embedding for semantic search (optional, computed on-demand) */
  embedding?: ArticleEmbedding;
  /** Search tokens for lexical narrowing (optional, computed at ingest) */
  searchTokens?: string[];
}

/**
 * Vector embedding for an article
 */
export interface ArticleEmbedding {
  /** Number of dimensions in the vector */
  dims: number;
  /** The embedding vector */
  vector: number[];
  /** Model used to generate the embedding */
  model: string;
  /** When the embedding was generated */
  updatedAt: Timestamp;
}

/**
 * AI-generated article content
 */
export interface ArticleAI {
  /** 2-3 sentence executive summary */
  tldr: string;
  /** Why this matters for P&C professionals */
  whyItMatters: string;
  /** 2-4 relevant topic tags */
  topics: string[];
  /** Primary category */
  category: "property" | "casualty" | "reinsurance" | "regulation" | "claims" | "insurtech" | "market" | "litigation";
  /** When AI content was generated */
  generatedAt: Timestamp;
  /** Model used for generation */
  model: string;
}

// ============================================================================
// Briefs Collection: briefs/{yyyy-mm-dd}
// ============================================================================

export interface BriefTopStory {
  /** Article ID reference */
  articleId: string;
  /** Article headline (synthesized, not copied) */
  headline: string;
  /** Why this story matters for P&C professionals */
  whyItMatters: string;
}

export interface BriefSection {
  /** Section bullets (2-4 items) */
  bullets: string[];
  /** Related article IDs */
  articleIds: string[];
}

export interface BriefSourceUsed {
  /** Source ID */
  sourceId: string;
  /** Source display name */
  name: string;
}

export interface Brief {
  /** Date in yyyy-mm-dd format */
  date: string;
  /** When this brief was created */
  createdAt: Timestamp;
  /** Executive summary bullets (3-5 items) */
  executiveSummary: string[];
  /** Top stories with "why it matters" */
  topStories: BriefTopStory[];
  /** Category sections */
  sections: {
    propertyCat: BriefSection;
    casualtyLiability: BriefSection;
    regulation: BriefSection;
    claims: BriefSection;
    reinsurance: BriefSection;
    insurtech: BriefSection;
    market: BriefSection;
  };
  /** Key topics covered */
  topics: string[];
  /** Sources used to generate this brief */
  sourcesUsed: BriefSourceUsed[];
  /** Article IDs used to generate this brief (for grounded chat) */
  sourceArticleIds: string[];
  /** Model used for generation */
  model: string;
}

// ============================================================================
// Users Collection: users/{uid}
// ============================================================================

export interface UserProfile {
  /** User's Firebase UID */
  uid: string;
  /** Email address */
  email: string | null;
  /** Display name */
  displayName: string | null;
  /** Account created timestamp */
  createdAt: Timestamp;
  /** Last login timestamp */
  lastLoginAt: Timestamp;
}

// ============================================================================
// User Bookmarks Subcollection: users/{uid}/bookmarks/{articleId}
// ============================================================================

export interface Bookmark {
  /** Article ID (same as document ID) */
  articleId: string;
  /** Article title (denormalized for display) */
  title: string;
  /** Source name (denormalized) */
  sourceName: string;
  /** Article URL */
  url: string;
  /** When bookmarked */
  bookmarkedAt: Timestamp;
}

// ============================================================================
// User Preferences Subcollection: users/{uid}/prefs/main
// ============================================================================

export interface UserPreferences {
  /** Source IDs the user has enabled */
  enabledSourceIds: string[];
  /** Categories the user wants to see */
  enabledCategories: SourceCategory[];
  /** Notification preferences */
  notifications: {
    dailyBrief: boolean;
    breakingNews: boolean;
  };
  /** Last updated timestamp */
  updatedAt: Timestamp;
}

// ============================================================================
// Chat Threads Subcollection: users/{uid}/chatThreads/{threadId}
// ============================================================================

/** Time scope for chat queries */
export type ChatTimeScope = "today" | "7d" | "30d";

/** Source filter mode */
export type ChatSourceFilter = "all" | "selected";

/** Category filter for chat */
export type ChatCategory = "all" | "property" | "casualty" | "regulation" | "claims" | "reinsurance";

/** Citation reference in a chat message */
export interface ChatCitation {
  /** Article ID reference */
  articleId: string;
  /** Article title */
  title: string;
  /** Source name */
  sourceName: string;
  /** Article URL */
  url: string;
  /** Publication timestamp (ISO string for serialization) */
  publishedAt: string;
}

/** Chat thread document */
export interface ChatThread {
  /** Thread ID (document ID) */
  id: string;
  /** Thread title (auto-generated from first message or user-set) */
  title: string;
  /** When thread was created */
  createdAt: Timestamp;
  /** When thread was last updated */
  updatedAt: Timestamp;
  /** Time scope filter */
  scope: ChatTimeScope;
  /** Source filter mode */
  sourceFilter: ChatSourceFilter;
  /** Category filter */
  category: ChatCategory;
}

/** Chat message document */
export interface ChatMessage {
  /** Message ID (document ID) */
  id: string;
  /** Message role */
  role: "user" | "assistant";
  /** Message content */
  content: string;
  /** When message was created */
  createdAt: Timestamp;
  /** Citations (only for assistant messages) */
  citations?: ChatCitation[];
}



=================================================================================
FILE: functions/src/types/index.ts
=================================================================================

/**
 * Type exports for P&C Insurance News AI (Cloud Functions)
 */

export type {
  // Source types
  Source,
  SourceCategory,
  SourceTier,
  SourceFetchState,
  // Article types
  Article,
  ArticleAI,
  ArticleEmbedding,
  // Brief types
  Brief,
  BriefTopStory,
  BriefSection,
  BriefSourceUsed,
  // User types
  UserProfile,
  Bookmark,
  UserPreferences,
  // Chat types
  ChatTimeScope,
  ChatSourceFilter,
  ChatCategory,
  ChatCitation,
  ChatThread,
  ChatMessage,
} from "./firestore.js";


