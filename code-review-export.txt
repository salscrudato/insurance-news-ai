================================================================================
INSURANCE NEWS AI - FULL CODEBASE EXPORT FOR AI CODE REVIEW
Generated: Mon Feb  9 17:40:40 EST 2026
================================================================================


################################################################################
# CONFIGURATION FILES
################################################################################

================================================================================
FILE: package.json
================================================================================
{
  "name": "insurance-news-ai",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc -b && vite build",
    "lint": "eslint .",
    "preview": "vite preview",
    "cap:sync": "npx cap sync ios",
    "ios:open": "npx cap open ios",
    "ios:run": "npx cap run ios",
    "firebase:emulators": "firebase emulators:start",
    "firebase:emulators:functions": "firebase emulators:start --only functions,hosting",
    "firebase:deploy": "npm run build && firebase deploy",
    "firebase:deploy:hosting": "npm run build && firebase deploy --only hosting",
    "firebase:deploy:functions": "firebase deploy --only functions",
    "firebase:deploy:firestore": "firebase deploy --only firestore:rules,firestore:indexes"
  },
  "dependencies": {
    "@capacitor/core": "^8.0.2",
    "@capacitor/haptics": "^8.0.0",
    "@capacitor/ios": "^8.0.2",
    "@capacitor/push-notifications": "^8.0.0",
    "@capacitor/status-bar": "^8.0.0",
    "@radix-ui/react-dialog": "^1.1.15",
    "@radix-ui/react-dropdown-menu": "^2.1.16",
    "@radix-ui/react-separator": "^1.1.8",
    "@radix-ui/react-slot": "^1.2.4",
    "@radix-ui/react-switch": "^1.2.6",
    "@radix-ui/react-tabs": "^1.1.13",
    "@tanstack/react-query": "^5.90.20",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "firebase": "^12.9.0",
    "lucide-react": "^0.563.0",
    "react": "^19.2.0",
    "react-dom": "^19.2.0",
    "react-router-dom": "^7.13.0",
    "sonner": "^2.0.7",
    "tailwind-merge": "^3.4.0"
  },
  "devDependencies": {
    "@capacitor/cli": "^8.0.2",
    "@eslint/js": "^9.39.1",
    "@tailwindcss/vite": "^4.1.18",
    "@types/node": "^24.10.12",
    "@types/react": "^19.2.5",
    "@types/react-dom": "^19.2.3",
    "@vitejs/plugin-react": "^5.1.1",
    "eslint": "^9.39.1",
    "eslint-plugin-react-hooks": "^7.0.1",
    "eslint-plugin-react-refresh": "^0.4.24",
    "firebase-tools": "^15.5.1",
    "globals": "^16.5.0",
    "tailwindcss": "^4.1.18",
    "typescript": "~5.9.3",
    "typescript-eslint": "^8.46.4",
    "vite": "^7.2.4",
    "web-push": "^3.6.7"
  }
}


================================================================================
FILE: tsconfig.json
================================================================================
{
  "files": [],
  "references": [
    { "path": "./tsconfig.app.json" },
    { "path": "./tsconfig.node.json" }
  ]
}


================================================================================
FILE: tsconfig.app.json
================================================================================
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.app.tsbuildinfo",
    "target": "ES2022",
    "useDefineForClassFields": true,
    "lib": ["ES2022", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "types": ["vite/client"],
    "skipLibCheck": true,
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    },

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["src"]
}


================================================================================
FILE: tsconfig.node.json
================================================================================
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.node.tsbuildinfo",
    "target": "ES2023",
    "lib": ["ES2023"],
    "module": "ESNext",
    "types": ["node"],
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["vite.config.ts"]
}


================================================================================
FILE: vite.config.ts
================================================================================
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'
import tailwindcss from '@tailwindcss/vite'
import path from 'path'

// https://vite.dev/config/
export default defineConfig({
  plugins: [react(), tailwindcss()],
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src'),
    },
  },
})


================================================================================
FILE: capacitor.config.ts
================================================================================
import type { CapacitorConfig } from '@capacitor/cli';

const config: CapacitorConfig = {
  appId: 'com.insurancenewsai.app',
  appName: 'P&C Brief',
  webDir: 'dist',
  ios: {
    // Respect iOS safe areas automatically
    contentInset: 'automatic',
    scrollEnabled: true,
    // Prefer mobile content width
    preferredContentMode: 'mobile',
    // Allow the webview to extend behind status bar and home indicator
    limitsNavigationsToAppBoundDomains: false,
  },
  plugins: {
    StatusBar: {
      // Light style = dark text on light background
      style: 'LIGHT',
      backgroundColor: '#ffffff',
    },
    PushNotifications: {
      // Present push notifications when app is in foreground
      presentationOptions: ['badge', 'sound', 'alert'],
    },
  },
};

export default config;


================================================================================
FILE: eslint.config.js
================================================================================
import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import tseslint from 'typescript-eslint'
import { defineConfig, globalIgnores } from 'eslint/config'

export default defineConfig([
  globalIgnores(['dist']),
  {
    files: ['**/*.{ts,tsx}'],
    extends: [
      js.configs.recommended,
      tseslint.configs.recommended,
      reactHooks.configs.flat.recommended,
      reactRefresh.configs.vite,
    ],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
    },
  },
])


================================================================================
FILE: firebase.json
================================================================================
{
  "firestore": {
    "rules": "firestore.rules",
    "indexes": "firestore.indexes.json"
  },
  "functions": [
    {
      "source": "functions",
      "codebase": "default",
      "ignore": [
        "node_modules",
        ".git",
        "firebase-debug.log",
        "firebase-debug.*.log",
        "*.local"
      ],
      "predeploy": [
        "npm --prefix \"$RESOURCE_DIR\" run lint",
        "npm --prefix \"$RESOURCE_DIR\" run build"
      ]
    }
  ],
  "hosting": {
    "public": "dist",
    "ignore": [
      "firebase.json",
      "**/.*",
      "**/node_modules/**"
    ],
    "rewrites": [
      {
        "source": "**",
        "destination": "/index.html"
      }
    ]
  },
  "emulators": {
    "auth": {
      "port": 9099
    },
    "functions": {
      "port": 5001
    },
    "firestore": {
      "port": 8080
    },
    "hosting": {
      "port": 5002
    },
    "ui": {
      "enabled": true,
      "port": 4000
    },
    "singleProjectMode": true
  }
}



================================================================================
FILE: firestore.rules
================================================================================
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // =========================================================================
    // Helper Functions
    // =========================================================================

    // Check if the request is from an authenticated user
    function isAuthenticated() {
      return request.auth != null;
    }

    // Check if the authenticated user owns this resource
    function isOwner(uid) {
      return isAuthenticated() && request.auth.uid == uid;
    }

    // =========================================================================
    // Sources Collection: sources/{sourceId}
    // Public read, server-only write (via Admin SDK)
    // =========================================================================
    match /sources/{sourceId} {
      allow read: if true;
      allow write: if false;
    }

    // =========================================================================
    // Articles Collection: articles/{articleId}
    // Public read, server-only write (via Admin SDK)
    // =========================================================================
    match /articles/{articleId} {
      allow read: if true;
      allow write: if false;
    }

    // =========================================================================
    // Briefs Collection: briefs/{date}
    // Public read, server-only write (via Admin SDK)
    // Date format: yyyy-mm-dd
    // =========================================================================
    match /briefs/{date} {
      allow read: if true;
      allow write: if false;
    }

    // =========================================================================
    // Users Collection: users/{uid}
    // Users can read/write their own profile
    // =========================================================================
    match /users/{uid} {
      // Users can read their own profile
      allow read: if isOwner(uid);
      // Profile creation/updates handled by server, but allow client reads
      allow write: if false;

      // -----------------------------------------------------------------------
      // Bookmarks Subcollection: users/{uid}/bookmarks/{articleId}
      // Users can read/write their own bookmarks
      // -----------------------------------------------------------------------
      match /bookmarks/{articleId} {
        allow read: if isOwner(uid);
        allow create: if isOwner(uid)
          && request.resource.data.articleId is string
          && request.resource.data.title is string
          && request.resource.data.sourceName is string
          && request.resource.data.url is string
          && request.resource.data.bookmarkedAt is timestamp;
        allow update: if isOwner(uid);
        allow delete: if isOwner(uid);
      }

      // -----------------------------------------------------------------------
      // Preferences Subcollection: users/{uid}/prefs/{docId}
      // Users can read/write their own preferences
      // Only "main" document is expected
      // -----------------------------------------------------------------------
      match /prefs/{docId} {
        allow read: if isOwner(uid);
        allow create: if isOwner(uid)
          && request.resource.data.enabledSourceIds is list
          && request.resource.data.enabledCategories is list
          && request.resource.data.notifications is map
          && request.resource.data.updatedAt is timestamp;
        allow update: if isOwner(uid)
          && request.resource.data.updatedAt is timestamp;
        allow delete: if isOwner(uid);
      }

      // -----------------------------------------------------------------------
      // Push Tokens Subcollection: users/{uid}/pushTokens/{token}
      // Users can read/write their own push notification tokens
      // -----------------------------------------------------------------------
      match /pushTokens/{tokenId} {
        allow read: if isOwner(uid);
        allow create: if isOwner(uid)
          && request.resource.data.token is string
          && request.resource.data.platform is string
          && request.resource.data.createdAt is timestamp
          && request.resource.data.updatedAt is timestamp;
        allow update: if isOwner(uid)
          && request.resource.data.updatedAt is timestamp;
        allow delete: if isOwner(uid);
      }
    }

    // =========================================================================
    // Default: Deny all other access
    // =========================================================================
    match /{document=**} {
      allow read, write: if false;
    }
  }
}



================================================================================
FILE: firestore.indexes.json
================================================================================
{
  "indexes": [
    {
      "collectionGroup": "sources",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "enabled", "order": "ASCENDING" },
        { "fieldPath": "name", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "articles",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "sourceId", "order": "ASCENDING" },
        { "fieldPath": "publishedAt", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "articles",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "categories", "arrayConfig": "CONTAINS" },
        { "fieldPath": "publishedAt", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "articles",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "sourceId", "order": "ASCENDING" },
        { "fieldPath": "categories", "arrayConfig": "CONTAINS" },
        { "fieldPath": "publishedAt", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "articles",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "isRelevant", "order": "ASCENDING" },
        { "fieldPath": "publishedAt", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "articles",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "publishedAt", "order": "ASCENDING" },
        { "fieldPath": "isRelevant", "order": "ASCENDING" }
      ]
    }
  ],
  "fieldOverrides": []
}



================================================================================
FILE: index.html
================================================================================
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover, maximum-scale=1" />
    <meta name="theme-color" content="#FFFFFF" />
    <meta name="mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="default" />
    <meta name="description" content="Insurance industry news and insights powered by AI" />
    <title>P&C Brief</title>
    <!-- Favicon - Shield logo -->
    <link rel="icon" type="image/svg+xml" href="/logo.svg" />
    <link rel="icon" type="image/png" sizes="192x192" href="/icons/icon-192.png" />
    <link rel="apple-touch-icon" sizes="180x180" href="/icons/icon-192.png" />
    <!-- PWA Manifest -->
    <link rel="manifest" href="/manifest.json" />
    <meta name="apple-mobile-web-app-title" content="P&C Brief" />
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>



################################################################################
# FRONTEND SOURCE CODE (src/)
################################################################################

================================================================================
FILE: src/App.tsx
================================================================================
import { useEffect } from "react"
import { BrowserRouter, Routes, Route } from "react-router-dom"
import { QueryClientProvider } from "@tanstack/react-query"
import { Capacitor } from "@capacitor/core"
import { StatusBar, Style } from "@capacitor/status-bar"
import { queryClient } from "@/lib/query-client"
import { AuthProvider } from "@/lib/auth-context"
import { MainLayout } from "@/layouts/MainLayout"
import { Toaster } from "@/components/ui/sonner"
import {
  TodayPage,
  FeedPage,
  SourcesPage,
  BookmarksPage,
  SettingsPage,
} from "@/pages"

function App() {
  // Configure iOS status bar on app load
  useEffect(() => {
    if (Capacitor.isNativePlatform()) {
      // Set status bar to light style (dark text) for our light UI
      StatusBar.setStyle({ style: Style.Light }).catch(() => {
        // Ignore errors on unsupported platforms
      })
    }
  }, [])

  return (
    <QueryClientProvider client={queryClient}>
      <AuthProvider>
        <BrowserRouter>
          <Routes>
            <Route element={<MainLayout />}>
              <Route path="/" element={<TodayPage />} />
              <Route path="/feed" element={<FeedPage />} />
              <Route path="/sources" element={<SourcesPage />} />
              <Route path="/bookmarks" element={<BookmarksPage />} />
              <Route path="/settings" element={<SettingsPage />} />
            </Route>
          </Routes>
        </BrowserRouter>
        <Toaster />
      </AuthProvider>
    </QueryClientProvider>
  )
}

export default App


================================================================================
FILE: src/components/brief/ArticleSheet.tsx
================================================================================
/**
 * Article detail sheet/modal for Today page
 *
 * Shows headline, source, why it matters, snippet, and actions:
 * - Read on source (external link)
 * - Bookmark toggle
 */

import {
  Sheet,
  SheetContent,
  SheetHeader,
  SheetTitle,
  SheetDescription,
} from "@/components/ui/sheet"
import { Button } from "@/components/ui/button"
import { ExternalLink, Bookmark, Loader2 } from "lucide-react"
import { toast } from "sonner"
import { Timestamp } from "firebase/firestore"
import { useIsBookmarked, useToggleBookmark } from "@/lib/hooks"
import { useAuth } from "@/lib/auth-context"
import type { TopStoryWithArticle } from "@/lib/hooks/use-today-brief"
import type { Article } from "@/types/firestore"
import { hapticLight } from "@/lib/haptics"

interface ArticleSheetProps {
  story: TopStoryWithArticle | null
  open: boolean
  onOpenChange: (open: boolean) => void
}

export function ArticleSheet({ story, open, onOpenChange }: ArticleSheetProps) {
  const { isAuthenticated } = useAuth()
  const { data: isBookmarked } = useIsBookmarked(story?.article?.id)
  const toggleBookmark = useToggleBookmark()

  if (!story) return null

  const handleOpenArticle = () => {
    hapticLight()
    window.open(story.article.url, "_blank", "noopener,noreferrer")
  }

  const handleBookmark = () => {
    if (!isAuthenticated) {
      toast.error("Sign in to bookmark articles")
      return
    }
    hapticLight()

    // Create a minimal Article object for bookmarking
    // The bookmark only stores essential fields anyway
    const minimalArticle: Article = {
      id: story.article.id,
      sourceId: "",
      sourceName: story.article.sourceName,
      title: story.article.title,
      snippet: story.article.snippet,
      url: story.article.url,
      canonicalUrl: story.article.url,
      guid: null,
      imageUrl: story.article.imageUrl,
      categories: [],
      publishedAt: Timestamp.fromDate(new Date(story.article.publishedAt)),
      ingestedAt: Timestamp.now(),
      relevanceScore: 1,
      isRelevant: true,
      ai: null,
    }

    toggleBookmark.mutate(
      { article: minimalArticle, isCurrentlyBookmarked: !!isBookmarked },
      {
        onSuccess: ({ bookmarked }) => {
          toast.success(bookmarked ? "Article saved" : "Bookmark removed")
        },
        onError: () => {
          toast.error("Failed to update bookmark")
        },
      }
    )
  }

  return (
    <Sheet open={open} onOpenChange={onOpenChange}>
      <SheetContent
        side="bottom"
        hideCloseButton
        className="glass-sheet sheet-scroll h-[85vh] overflow-y-auto px-[20px] pb-[calc(56px+var(--safe-area-inset-bottom))] pt-[8px]"
      >
        {/* Drag indicator */}
        <div className="drag-indicator mb-[20px]" />

        <SheetHeader className="mb-[26px] text-left">
          <div className="mb-[12px]">
            <span className="text-[11px] font-bold uppercase tracking-[0.05em] text-[var(--color-accent)]">
              {story.article.sourceName}
            </span>
          </div>
          <SheetTitle className="text-[25px] font-bold leading-[1.18] tracking-[-0.44px] text-[var(--color-text-primary)]">
            {story.headline}
          </SheetTitle>
          <SheetDescription className="sr-only">
            Article details from {story.article.sourceName}
          </SheetDescription>
        </SheetHeader>

        {/* Image */}
        {story.article.imageUrl && (
          <div className="mb-[26px] aspect-[16/9] w-full overflow-hidden rounded-[var(--radius-2xl)] bg-[var(--color-fill-tertiary)]">
            <img
              src={story.article.imageUrl}
              alt=""
              className="h-full w-full object-cover"
            />
          </div>
        )}

        {/* Why It Matters Card */}
        <div className="mb-[26px] overflow-hidden rounded-[var(--radius-2xl)] bg-[var(--color-fill-quaternary)]">
          <div className="px-[18px] py-[16px]">
            <h4 className="mb-[10px] text-[11px] font-bold uppercase tracking-[0.06em] text-[var(--color-text-tertiary)]">
              Why It Matters
            </h4>
            <p className="text-[16px] leading-[1.55] tracking-[-0.22px] text-[var(--color-text-primary)]">
              {story.whyItMatters}
            </p>
          </div>

          {/* AI Disclaimer */}
          <div className="border-t border-[var(--color-separator)] px-[18px] py-[10px]">
            <p className="text-[11px] text-[var(--color-text-tertiary)]">
              Summary generated by AI. Read original source for full article.
            </p>
          </div>
        </div>

        {/* Snippet */}
        {story.article.snippet && (
          <div className="mb-[30px]">
            <p className="text-[16px] leading-[1.6] tracking-[-0.22px] text-[var(--color-text-secondary)]">
              {story.article.snippet}
            </p>
          </div>
        )}

        {/* Actions */}
        <div className="flex gap-[14px]">
          <Button onClick={handleOpenArticle} className="flex-1 gap-[8px]" size="lg">
            <span>Read Article</span>
            <ExternalLink className="h-[17px] w-[17px]" />
          </Button>
          <Button
            variant="outline"
            size="lg"
            onClick={handleBookmark}
            disabled={toggleBookmark.isPending}
            className="h-[52px] w-[52px] shrink-0 p-0 active:scale-[0.94]"
          >
            {toggleBookmark.isPending ? (
              <Loader2 className="h-[20px] w-[20px] animate-spin" />
            ) : (
              <Bookmark
                className="h-[20px] w-[20px]"
                fill={isBookmarked ? "currentColor" : "none"}
              />
            )}
          </Button>
        </div>
      </SheetContent>
    </Sheet>
  )
}



================================================================================
FILE: src/components/brief/BriefSections.tsx
================================================================================
/**
 * Category section blocks for the daily brief
 *
 * Premium design with:
 * - Muted, consistent icon background chips
 * - Improved bullet readability and spacing
 * - Clean section separators
 */

import {
  Building2,
  Scale,
  ClipboardList,
  FileText,
  RefreshCw,
  Lightbulb,
  TrendingUp,
  type LucideIcon,
} from "lucide-react"
import type { BriefSection } from "@/types/firestore"

// Section display configuration with muted, sophisticated colors
// Using consistent opacity/saturation for a cohesive look
const SECTION_CONFIG: Record<string, { label: string; icon: LucideIcon; color: string; bgOpacity: string }> = {
  propertyCat: { label: "Property & Cat", icon: Building2, color: "#007AFF", bgOpacity: "10%" },
  casualtyLiability: { label: "Casualty & Liability", icon: Scale, color: "#8E8E93", bgOpacity: "12%" },
  regulation: { label: "Regulation", icon: ClipboardList, color: "#5856D6", bgOpacity: "10%" },
  claims: { label: "Claims", icon: FileText, color: "#FF9500", bgOpacity: "10%" },
  reinsurance: { label: "Reinsurance", icon: RefreshCw, color: "#32ADE6", bgOpacity: "12%" },
  insurtech: { label: "InsurTech", icon: Lightbulb, color: "#34C759", bgOpacity: "10%" },
  market: { label: "Market & M&A", icon: TrendingUp, color: "#AF52DE", bgOpacity: "10%" },
}

interface SectionBlockProps {
  sectionKey: string
  section: BriefSection
  isLast: boolean
}

function SectionBlock({ sectionKey, section, isLast }: SectionBlockProps) {
  const config = SECTION_CONFIG[sectionKey]

  if (!config || section.bullets.length === 0) {
    return null
  }

  const Icon = config.icon

  return (
    <div>
      {/* Section Header */}
      <div className="flex items-center gap-[10px] px-[16px] py-[12px]">
        <div
          className="flex h-[30px] w-[30px] items-center justify-center rounded-[8px]"
          style={{ backgroundColor: `color-mix(in srgb, ${config.color} ${config.bgOpacity}, transparent)` }}
        >
          <Icon
            className="h-[16px] w-[16px]"
            strokeWidth={1.75}
            style={{ color: config.color }}
          />
        </div>
        <h3 className="text-[15px] font-semibold tracking-[-0.24px] text-[var(--color-text-primary)]">
          {config.label}
        </h3>
      </div>

      {/* Bullets */}
      <ul className="space-y-[8px] px-[16px] pb-[16px]">
        {section.bullets.map((bullet, index) => (
          <li
            key={index}
            className="flex gap-[10px] text-[14px] leading-[1.5] tracking-[-0.12px] text-[var(--color-text-secondary)]"
          >
            <span
              className="mt-[8px] h-[5px] w-[5px] shrink-0 rounded-full"
              style={{ backgroundColor: config.color, opacity: 0.6 }}
            />
            <span>{bullet}</span>
          </li>
        ))}
      </ul>

      {/* Section separator */}
      {!isLast && (
        <div className="mx-[16px] h-[0.5px] bg-[var(--color-separator)]" />
      )}
    </div>
  )
}

interface BriefSectionsProps {
  sections: {
    propertyCat: BriefSection
    casualtyLiability: BriefSection
    regulation: BriefSection
    claims: BriefSection
    reinsurance: BriefSection
    insurtech: BriefSection
    market: BriefSection
  }
}

export function BriefSections({ sections }: BriefSectionsProps) {
  // Filter to only show sections with content
  const sectionEntries = Object.entries(sections).filter(
    ([, section]) => section.bullets.length > 0
  )

  if (sectionEntries.length === 0) {
    return null
  }

  return (
    <div className="overflow-hidden rounded-[16px] bg-[var(--color-surface)] shadow-[0_1px_3px_rgba(0,0,0,0.04),0_0_0_0.5px_rgba(0,0,0,0.02)]">
      {sectionEntries.map(([key, section], index) => (
        <SectionBlock
          key={key}
          sectionKey={key}
          section={section}
          isLast={index === sectionEntries.length - 1}
        />
      ))}
    </div>
  )
}



================================================================================
FILE: src/components/brief/BriefSkeleton.tsx
================================================================================
/**
 * Skeleton loading states for the Today screen
 *
 * Matches the premium Daily Brief design
 */

import { Skeleton } from "@/components/ui/skeleton"

export function ExecutiveSummarySkeleton() {
  return (
    <div className="space-y-[12px]">
      <div className="flex gap-[12px]">
        <Skeleton className="mt-[8px] h-[6px] w-[6px] shrink-0 rounded-full" />
        <Skeleton className="h-[20px] flex-1" />
      </div>
      <div className="flex gap-[12px]">
        <Skeleton className="mt-[8px] h-[6px] w-[6px] shrink-0 rounded-full" />
        <Skeleton className="h-[20px] w-11/12" />
      </div>
      <div className="flex gap-[12px]">
        <Skeleton className="mt-[8px] h-[6px] w-[6px] shrink-0 rounded-full" />
        <Skeleton className="h-[20px] w-10/12" />
      </div>
    </div>
  )
}

export function TopStoryCardSkeleton() {
  return (
    <div className="w-[280px] shrink-0 snap-start overflow-hidden rounded-[14px] bg-[var(--color-surface)] shadow-[0_1px_3px_rgba(0,0,0,0.04),0_0_0_0.5px_rgba(0,0,0,0.02)]">
      <Skeleton className="aspect-[16/9] w-full rounded-none" />
      <div className="p-[14px]">
        <Skeleton className="mb-[5px] h-[11px] w-[64px]" />
        <Skeleton className="mb-[6px] h-[17px] w-full" />
        <Skeleton className="h-[14px] w-4/5" />
      </div>
    </div>
  )
}

export function TopStoriesCarouselSkeleton() {
  return (
    <div className="-mx-[var(--spacing-4)] flex gap-[10px] overflow-hidden px-[var(--spacing-4)]">
      <TopStoryCardSkeleton />
      <TopStoryCardSkeleton />
    </div>
  )
}

export function SectionSkeleton() {
  return (
    <div>
      <div className="flex items-center gap-[10px] px-[16px] py-[12px]">
        <Skeleton className="h-[30px] w-[30px] rounded-[8px]" />
        <Skeleton className="h-[17px] w-28" />
      </div>
      <div className="space-y-[8px] px-[16px] pb-[16px]">
        <div className="flex gap-[10px]">
          <Skeleton className="mt-[8px] h-[5px] w-[5px] shrink-0 rounded-full" />
          <Skeleton className="h-[16px] flex-1" />
        </div>
        <div className="flex gap-[10px]">
          <Skeleton className="mt-[8px] h-[5px] w-[5px] shrink-0 rounded-full" />
          <Skeleton className="h-[16px] w-11/12" />
        </div>
      </div>
    </div>
  )
}

export function TodayScreenSkeleton() {
  return (
    <div className="space-y-[28px]">
      {/* Date */}
      <header className="-mt-[4px]">
        <Skeleton className="h-[15px] w-44" />
      </header>

      {/* Executive Summary Card */}
      <section className="overflow-hidden rounded-[16px] bg-[var(--color-surface)] shadow-[0_1px_3px_rgba(0,0,0,0.04),0_0_0_0.5px_rgba(0,0,0,0.02)]">
        {/* Card header */}
        <div className="flex items-center justify-between border-b border-[var(--color-separator)] px-[18px] py-[12px]">
          <Skeleton className="h-[22px] w-[100px] rounded-full" />
          <Skeleton className="h-[11px] w-[90px]" />
        </div>
        {/* Bullets */}
        <div className="px-[18px] py-[18px]">
          <ExecutiveSummarySkeleton />
        </div>
      </section>

      {/* Top Stories */}
      <section className="space-y-[10px]">
        <Skeleton className="h-[12px] w-20" />
        <TopStoriesCarouselSkeleton />
      </section>

      {/* Sections */}
      <section className="space-y-[10px]">
        <Skeleton className="h-[12px] w-24" />
        <div className="overflow-hidden rounded-[16px] bg-[var(--color-surface)] shadow-[0_1px_3px_rgba(0,0,0,0.04),0_0_0_0.5px_rgba(0,0,0,0.02)]">
          <SectionSkeleton />
          <div className="mx-[16px] h-[0.5px] bg-[var(--color-separator)]" />
          <SectionSkeleton />
        </div>
      </section>
    </div>
  )
}



================================================================================
FILE: src/components/brief/index.ts
================================================================================
/**
 * Brief components exports
 */

export { TodayScreenSkeleton, TopStoriesCarouselSkeleton, SectionSkeleton, ExecutiveSummarySkeleton } from "./BriefSkeleton"
export { TopStoriesCarousel } from "./TopStoriesCarousel"
export { BriefSections } from "./BriefSections"
export { ArticleSheet } from "./ArticleSheet"



================================================================================
FILE: src/components/brief/TopStoriesCarousel.tsx
================================================================================
/**
 * Horizontal scrolling carousel of top stories
 *
 * Premium design with:
 * - Consistent 280px card width
 * - Gradient overlay for image text legibility
 * - P&C-focused "Why it matters" excerpt
 */

import type { TopStoryWithArticle } from "@/lib/hooks/use-today-brief"

interface TopStoryCardProps {
  story: TopStoryWithArticle
  onSelect: (story: TopStoryWithArticle) => void
}

function TopStoryCard({ story, onSelect }: TopStoryCardProps) {
  const hasImage = !!story.article.imageUrl

  return (
    <button
      onClick={() => onSelect(story)}
      className="w-[280px] shrink-0 snap-start overflow-hidden rounded-[14px] bg-[var(--color-surface)] text-left shadow-[0_1px_3px_rgba(0,0,0,0.04),0_0_0_0.5px_rgba(0,0,0,0.02)] transition-all duration-[var(--duration-fast)] ease-[var(--ease-ios)] active:scale-[0.975]"
    >
      {/* Image with gradient overlay */}
      {hasImage && (
        <div className="relative aspect-[16/9] w-full overflow-hidden bg-[var(--color-fill-tertiary)]">
          <img
            src={story.article.imageUrl!}
            alt=""
            className="h-full w-full object-cover"
            loading="lazy"
          />
          {/* Subtle gradient overlay for better text contrast below */}
          <div className="absolute inset-x-0 bottom-0 h-[40%] bg-gradient-to-t from-black/12 to-transparent" />
        </div>
      )}

      {/* Content */}
      <div className="p-[14px]">
        {/* Source label */}
        <p className="mb-[5px] text-[11px] font-semibold uppercase tracking-[0.3px] text-[var(--color-accent)]">
          {story.article.sourceName}
        </p>

        {/* Headline */}
        <h3 className="mb-[6px] line-clamp-2 text-[15px] font-semibold leading-[1.35] tracking-[-0.2px] text-[var(--color-text-primary)]">
          {story.headline}
        </h3>

        {/* Why it matters - P&C focused */}
        <p className="line-clamp-2 text-[13px] leading-[1.4] tracking-[-0.08px] text-[var(--color-text-secondary)]">
          <span className="font-medium text-[var(--color-text-tertiary)]">Why it matters: </span>
          {story.whyItMatters}
        </p>
      </div>
    </button>
  )
}

interface TopStoriesCarouselProps {
  stories: TopStoryWithArticle[]
  onSelectStory: (story: TopStoryWithArticle) => void
}

export function TopStoriesCarousel({ stories, onSelectStory }: TopStoriesCarouselProps) {
  if (stories.length === 0) {
    return null
  }

  return (
    <div className="-mx-[var(--spacing-4)] overflow-x-auto px-[var(--spacing-4)] scrollbar-none scroll-smooth">
      <div className="flex snap-x snap-mandatory gap-[10px] pb-[4px]">
        {stories.map((story) => (
          <TopStoryCard
            key={story.articleId}
            story={story}
            onSelect={onSelectStory}
          />
        ))}
        {/* End spacer for scroll padding */}
        <div className="w-[6px] shrink-0" />
      </div>
    </div>
  )
}



================================================================================
FILE: src/components/feed/ArticleCard.tsx
================================================================================
/**
 * Article Card component for the feed
 * Premium iOS news reader design - tight typography, subtle styling
 */

import { Sparkles } from "lucide-react"
import type { Article } from "@/types/firestore"
import type { Timestamp } from "firebase/firestore"

interface ArticleCardProps {
  article: Article
  onSelect: (article: Article) => void
}

function formatRelativeTime(timestamp: Timestamp): string {
  const date = timestamp.toDate()
  const now = new Date()
  const diffMs = now.getTime() - date.getTime()
  const diffMins = Math.floor(diffMs / (1000 * 60))
  const diffHours = Math.floor(diffMs / (1000 * 60 * 60))
  const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24))

  if (diffMins < 60) {
    return `${diffMins}m`
  } else if (diffHours < 24) {
    return `${diffHours}h`
  } else if (diffDays < 7) {
    return `${diffDays}d`
  } else {
    return date.toLocaleDateString("en-US", { month: "short", day: "numeric" })
  }
}

export function ArticleCard({ article, onSelect }: ArticleCardProps) {
  const handleClick = () => {
    onSelect(article)
  }

  const hasAI = Boolean(article.ai?.tldr)

  return (
    <article
      role="button"
      tabIndex={0}
      onClick={handleClick}
      onKeyDown={(e) => {
        if (e.key === "Enter" || e.key === " ") {
          e.preventDefault()
          handleClick()
        }
      }}
      className="content-visibility-auto group cursor-pointer overflow-hidden rounded-[var(--radius-lg)] bg-[var(--color-surface)] border border-[var(--color-separator)] transition-all duration-[var(--duration-fast)] ease-[var(--ease-ios)] active:scale-[0.985] active:bg-[var(--color-fill-quaternary)] focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-[var(--color-accent)] focus-visible:ring-offset-2"
    >
      {/* Image - consistent 2:1 aspect ratio */}
      {article.imageUrl && (
        <div className="aspect-[2/1] w-full overflow-hidden bg-[var(--color-fill-quaternary)]">
          <img
            src={article.imageUrl}
            alt=""
            className="h-full w-full object-cover"
            loading="lazy"
          />
        </div>
      )}

      {/* Content */}
      <div className="px-[14px] py-[12px]">
        {/* Meta row: Source · Time · AI indicator */}
        <div className="mb-[6px] flex items-center gap-[6px]">
          <span className="text-[12px] font-semibold tracking-[-0.1px] text-[var(--color-text-secondary)]">
            {article.sourceName}
          </span>
          <span className="text-[12px] text-[var(--color-text-quaternary)]">·</span>
          <span className="text-[12px] text-[var(--color-text-tertiary)]">
            {formatRelativeTime(article.publishedAt)}
          </span>
          {hasAI && (
            <>
              <span className="text-[12px] text-[var(--color-text-quaternary)]">·</span>
              <Sparkles className="h-[12px] w-[12px] text-[var(--color-accent)]" strokeWidth={2} />
            </>
          )}
        </div>

        {/* Headline */}
        <h3 className="line-clamp-2 text-[15px] font-semibold leading-[1.33] tracking-[-0.2px] text-[var(--color-text-primary)]">
          {article.title}
        </h3>

        {/* Snippet - always show, keep it tight */}
        <p className="mt-[6px] line-clamp-2 text-[13px] leading-[1.38] tracking-[-0.08px] text-[var(--color-text-tertiary)]">
          {article.ai?.tldr ?? article.snippet}
        </p>
      </div>
    </article>
  )
}

export function ArticleCardSkeleton() {
  return (
    <div className="overflow-hidden rounded-[var(--radius-lg)] bg-[var(--color-surface)] border border-[var(--color-separator)]">
      {/* Image skeleton */}
      <div className="aspect-[2/1] w-full skeleton-shimmer" />

      {/* Content skeleton */}
      <div className="px-[14px] py-[12px]">
        {/* Meta row */}
        <div className="mb-[6px] flex items-center gap-[6px]">
          <div className="h-[11px] w-[60px] rounded-[3px] skeleton-shimmer" />
          <div className="h-[11px] w-[24px] rounded-[3px] skeleton-shimmer" />
        </div>

        {/* Headline */}
        <div className="space-y-[5px]">
          <div className="h-[14px] w-full rounded-[3px] skeleton-shimmer" />
          <div className="h-[14px] w-[85%] rounded-[3px] skeleton-shimmer" />
        </div>

        {/* Snippet */}
        <div className="mt-[6px] space-y-[4px]">
          <div className="h-[12px] w-full rounded-[3px] skeleton-shimmer" />
          <div className="h-[12px] w-[70%] rounded-[3px] skeleton-shimmer" />
        </div>
      </div>
    </div>
  )
}



================================================================================
FILE: src/components/feed/ArticleDetailSheet.tsx
================================================================================
/**
 * Article detail sheet for the feed
 *
 * Shows headline, source, publish time, snippet, and actions:
 * - Read on source (external link)
 * - Generate TL;DR (calls getOrCreateArticleAI)
 * - Bookmark toggle
 */

import { useState, useEffect } from "react"
import {
  Sheet,
  SheetContent,
  SheetHeader,
  SheetTitle,
  SheetDescription,
} from "@/components/ui/sheet"
import { Button } from "@/components/ui/button"
import { Skeleton } from "@/components/ui/skeleton"
import { ExternalLink, Bookmark, Sparkles, Loader2 } from "lucide-react"
import { toast } from "sonner"
import { useIsBookmarked, useToggleBookmark, useArticleAI } from "@/lib/hooks"
import { useAuth } from "@/lib/auth-context"
import type { Article, ArticleAI } from "@/types/firestore"
import type { Timestamp } from "firebase/firestore"
import { hapticLight } from "@/lib/haptics"

interface ArticleDetailSheetProps {
  article: Article | null
  open: boolean
  onOpenChange: (open: boolean) => void
}

function formatDate(timestamp: Timestamp): string {
  return timestamp.toDate().toLocaleDateString("en-US", {
    weekday: "short",
    month: "short",
    day: "numeric",
    hour: "numeric",
    minute: "2-digit",
  })
}

export function ArticleDetailSheet({
  article,
  open,
  onOpenChange,
}: ArticleDetailSheetProps) {
  const { isAuthenticated } = useAuth()
  const { data: isBookmarked } = useIsBookmarked(article?.id)
  const toggleBookmark = useToggleBookmark()
  const generateAI = useArticleAI()

  // Local state for AI content (combines cached article.ai with generated)
  const [aiContent, setAiContent] = useState<ArticleAI | null>(null)

  // Reset AI content when article changes
  useEffect(() => {
    if (article?.ai) {
      setAiContent(article.ai)
    } else {
      setAiContent(null)
    }
  }, [article?.id, article?.ai])

  if (!article) return null

  const handleOpenArticle = () => {
    hapticLight()
    window.open(article.url, "_blank", "noopener,noreferrer")
  }

  const handleBookmark = () => {
    if (!isAuthenticated) {
      toast.error("Sign in to bookmark articles")
      return
    }
    hapticLight()

    toggleBookmark.mutate(
      { article, isCurrentlyBookmarked: !!isBookmarked },
      {
        onSuccess: ({ bookmarked }) => {
          toast.success(bookmarked ? "Article saved" : "Bookmark removed")
        },
        onError: () => {
          toast.error("Failed to update bookmark")
        },
      }
    )
  }

  const handleGenerateAI = () => {
    if (!isAuthenticated) {
      toast.error("Sign in to generate summaries")
      return
    }
    hapticLight()

    generateAI.mutate(article.id, {
      onSuccess: (data) => {
        // Convert generatedAt string to Timestamp-like object for display
        setAiContent({
          ...data.ai,
          generatedAt: { toDate: () => new Date(data.ai.generatedAt) } as unknown as Timestamp,
        } as ArticleAI)

        if (!data.cached) {
          toast.success("Summary generated", {
            description: `${data.remaining} summaries remaining today`,
          })
        }
      },
      onError: (error) => {
        console.error("Failed to generate AI:", error)
        toast.error("Failed to generate summary", {
          description: "Please try again later",
        })
      },
    })
  }

  const hasAI = !!aiContent
  const isGenerating = generateAI.isPending

  return (
    <Sheet open={open} onOpenChange={onOpenChange}>
      <SheetContent
        side="bottom"
        hideCloseButton
        className="glass-sheet sheet-scroll h-[85vh] overflow-y-auto px-[20px] pb-[calc(52px+var(--safe-area-inset-bottom))] pt-[8px]"
      >
        {/* Drag indicator */}
        <div className="drag-indicator mb-[18px]" />

        <SheetHeader className="mb-[24px] text-left">
          <div className="mb-[10px] flex items-center gap-[8px]">
            <span className="text-[12px] font-semibold uppercase tracking-[0.03em] text-[var(--color-accent)]">
              {article.sourceName}
            </span>
            <span className="text-[12px] text-[var(--color-text-tertiary)]">
              · {formatDate(article.publishedAt)}
            </span>
          </div>
          <SheetTitle className="text-[26px] font-bold leading-[1.18] tracking-[-0.5px] text-[var(--color-text-primary)]">
            {article.title}
          </SheetTitle>
          <SheetDescription className="sr-only">
            Article details from {article.sourceName}
          </SheetDescription>
        </SheetHeader>

        {/* Image */}
        {article.imageUrl && (
          <div className="mb-[24px] aspect-[16/9] w-full overflow-hidden rounded-[var(--radius-2xl)] bg-[var(--color-fill-tertiary)]">
            <img
              src={article.imageUrl}
              alt=""
              className="h-full w-full object-cover"
            />
          </div>
        )}

        {/* AI Summary section */}
        {isGenerating ? (
          <div className="mb-[24px] overflow-hidden rounded-[var(--radius-2xl)] bg-[var(--color-fill-tertiary)]">
            <div className="border-b border-[var(--color-separator)] px-[16px] py-[15px]">
              <Skeleton className="mb-[12px] h-4 w-16" />
              <Skeleton className="h-4 w-full" />
              <Skeleton className="mt-[8px] h-4 w-3/4" />
            </div>
            <div className="px-[16px] py-[15px]">
              <Skeleton className="mb-[12px] h-4 w-24" />
              <Skeleton className="h-4 w-full" />
              <Skeleton className="mt-[8px] h-4 w-5/6" />
            </div>
          </div>
        ) : hasAI ? (
          <div className="mb-[24px] overflow-hidden rounded-[var(--radius-2xl)] bg-[var(--color-fill-tertiary)]">
            <div className="border-b border-[var(--color-separator)] px-[16px] py-[15px]">
              <h4 className="mb-[8px] text-[11px] font-semibold uppercase tracking-[0.03em] text-[var(--color-text-tertiary)]">
                TL;DR
              </h4>
              <p className="text-[15px] leading-[1.55] tracking-[-0.2px] text-[var(--color-text-primary)]">
                {aiContent.tldr}
              </p>
            </div>

            <div className="px-[16px] py-[15px]">
              <h4 className="mb-[8px] text-[11px] font-semibold uppercase tracking-[0.03em] text-[var(--color-text-tertiary)]">
                Why It Matters
              </h4>
              <p className="text-[15px] leading-[1.55] tracking-[-0.2px] text-[var(--color-text-primary)]">
                {aiContent.whyItMatters}
              </p>
            </div>

            {/* Topics */}
            {aiContent.topics && aiContent.topics.length > 0 && (
              <div className="flex flex-wrap gap-[6px] border-t border-[var(--color-separator)] px-[16px] py-[13px]">
                {aiContent.topics.map((topic) => (
                  <span
                    key={topic}
                    className="rounded-full bg-[var(--color-surface)] px-[12px] py-[6px] text-[12px] font-medium tracking-[-0.05px] text-[var(--color-text-secondary)]"
                  >
                    {topic}
                  </span>
                ))}
              </div>
            )}

            {/* AI Disclaimer */}
            <div className="border-t border-[var(--color-separator)] px-[16px] py-[10px]">
              <p className="text-[11px] text-[var(--color-text-tertiary)]">
                Summary generated by AI. Read original source for full article.
              </p>
            </div>
          </div>
        ) : (
          /* Generate TL;DR button when no AI available */
          <div className="mb-[24px]">
            <Button
              variant="outline"
              size="lg"
              className="w-full gap-[10px]"
              onClick={handleGenerateAI}
              disabled={isGenerating}
            >
              <Sparkles className="h-[18px] w-[18px]" />
              <span>Generate AI Summary</span>
            </Button>
          </div>
        )}

        {/* Snippet */}
        {article.snippet && (
          <div className="mb-[28px]">
            <p className="text-[15px] leading-[1.6] tracking-[-0.2px] text-[var(--color-text-secondary)]">
              {article.snippet}
            </p>
          </div>
        )}

        {/* Actions */}
        <div className="flex gap-[12px]">
          <Button onClick={handleOpenArticle} className="flex-1 gap-[8px]" size="lg">
            <span>Read Article</span>
            <ExternalLink className="h-[17px] w-[17px]" />
          </Button>
          <Button
            variant="outline"
            size="lg"
            onClick={handleBookmark}
            disabled={toggleBookmark.isPending}
            className="h-[50px] w-[50px] shrink-0 p-0"
          >
            {toggleBookmark.isPending ? (
              <Loader2 className="h-5 w-5 animate-spin" />
            ) : (
              <Bookmark
                className="h-5 w-5"
                fill={isBookmarked ? "currentColor" : "none"}
              />
            )}
          </Button>
        </div>
      </SheetContent>
    </Sheet>
  )
}



================================================================================
FILE: src/components/feed/ArticleRow.tsx
================================================================================
/**
 * Article row component for the feed list
 */

import { Bookmark, Loader2 } from "lucide-react"
import { Badge } from "@/components/ui/badge"
import { toast } from "sonner"
import { useIsBookmarked, useToggleBookmark } from "@/lib/hooks"
import { useAuth } from "@/lib/auth-context"
import type { Article } from "@/types/firestore"
import type { Timestamp } from "firebase/firestore"

interface ArticleRowProps {
  article: Article
  onSelect: (article: Article) => void
  showBookmark?: boolean
}

function formatRelativeTime(timestamp: Timestamp): string {
  const date = timestamp.toDate()
  const now = new Date()
  const diffMs = now.getTime() - date.getTime()
  const diffMins = Math.floor(diffMs / (1000 * 60))
  const diffHours = Math.floor(diffMs / (1000 * 60 * 60))
  const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24))

  if (diffMins < 60) {
    return `${diffMins}m ago`
  } else if (diffHours < 24) {
    return `${diffHours}h ago`
  } else if (diffDays < 7) {
    return `${diffDays}d ago`
  } else {
    return date.toLocaleDateString("en-US", { month: "short", day: "numeric" })
  }
}

export function ArticleRow({ article, onSelect, showBookmark = true }: ArticleRowProps) {
  const { isAuthenticated } = useAuth()
  const { data: isBookmarked } = useIsBookmarked(showBookmark ? article.id : undefined)
  const toggleBookmark = useToggleBookmark()

  const handleBookmarkClick = (e: React.MouseEvent) => {
    e.stopPropagation()

    if (!isAuthenticated) {
      toast.error("Sign in to bookmark articles")
      return
    }

    toggleBookmark.mutate(
      { article, isCurrentlyBookmarked: !!isBookmarked },
      {
        onSuccess: ({ bookmarked }) => {
          toast.success(bookmarked ? "Article saved" : "Bookmark removed")
        },
        onError: () => {
          toast.error("Failed to update bookmark")
        },
      }
    )
  }

  const handleRowClick = () => {
    onSelect(article)
  }

  return (
    <div
      role="button"
      tabIndex={0}
      onClick={handleRowClick}
      onKeyDown={(e) => {
        if (e.key === "Enter" || e.key === " ") {
          e.preventDefault()
          handleRowClick()
        }
      }}
      className="flex w-full cursor-pointer gap-3 border-b border-[var(--color-border)] px-[var(--spacing-md)] py-[var(--spacing-md)] text-left transition-colors hover:bg-[var(--color-surface)] active:bg-[var(--color-surface)]"
    >
      {/* Content */}
      <div className="min-w-0 flex-1">
        {/* Source and time */}
        <div className="mb-1 flex items-center gap-2">
          <Badge variant="secondary" className="text-[11px]">
            {article.sourceName}
          </Badge>
          <span className="text-[12px] text-[var(--color-text-tertiary)]">
            {formatRelativeTime(article.publishedAt)}
          </span>
        </div>

        {/* Headline */}
        <h3 className="mb-1 line-clamp-2 text-[15px] font-semibold leading-snug text-[var(--color-text-primary)]">
          {article.title}
        </h3>

        {/* Snippet */}
        <p className="line-clamp-1 text-[13px] leading-relaxed text-[var(--color-text-secondary)]">
          {article.snippet}
        </p>
      </div>

      {/* Bookmark button */}
      {showBookmark && (
        <button
          onClick={handleBookmarkClick}
          disabled={toggleBookmark.isPending}
          className="shrink-0 self-start rounded-full p-2 text-[var(--color-text-tertiary)] transition-colors hover:bg-[var(--color-surface)] hover:text-[var(--color-accent)] disabled:opacity-50"
          aria-label={isBookmarked ? "Remove bookmark" : "Add bookmark"}
        >
          {toggleBookmark.isPending ? (
            <Loader2 className="h-5 w-5 animate-spin" />
          ) : (
            <Bookmark
              className="h-5 w-5"
              fill={isBookmarked ? "currentColor" : "none"}
            />
          )}
        </button>
      )}
    </div>
  )
}

export function ArticleRowSkeleton() {
  return (
    <div className="flex gap-3 border-b border-[var(--color-border)] px-[var(--spacing-md)] py-[var(--spacing-md)]">
      <div className="min-w-0 flex-1 space-y-2">
        <div className="flex items-center gap-2">
          <div className="h-5 w-20 animate-pulse rounded-full bg-[var(--color-surface)]" />
          <div className="h-4 w-12 animate-pulse rounded bg-[var(--color-surface)]" />
        </div>
        <div className="h-5 w-full animate-pulse rounded bg-[var(--color-surface)]" />
        <div className="h-5 w-3/4 animate-pulse rounded bg-[var(--color-surface)]" />
        <div className="h-4 w-full animate-pulse rounded bg-[var(--color-surface)]" />
      </div>
      <div className="h-9 w-9 shrink-0 animate-pulse rounded-full bg-[var(--color-surface)]" />
    </div>
  )
}



================================================================================
FILE: src/components/feed/FeedFilters.tsx
================================================================================
/**
 * Filter components for the Feed page
 * Refined iOS-native design with compact, elegant controls
 */

import { useState } from "react"
import { ChevronDown, Check, Clock, Newspaper } from "lucide-react"
import { Button } from "@/components/ui/button"
import {
  Sheet,
  SheetContent,
  SheetHeader,
  SheetTitle,
  SheetTrigger,
} from "@/components/ui/sheet"
import type { SourceCategory } from "@/types/firestore"
import { cn } from "@/lib/utils"
import { hapticLight } from "@/lib/haptics"

// Category configuration
const CATEGORIES: { value: SourceCategory | "all"; label: string }[] = [
  { value: "all", label: "All" },
  { value: "property_cat", label: "Property" },
  { value: "casualty_liability", label: "Casualty" },
  { value: "regulation", label: "Regulation" },
  { value: "claims", label: "Claims" },
  { value: "reinsurance", label: "Reinsurance" },
  { value: "insurtech", label: "InsurTech" },
]

// Time window options
const TIME_WINDOWS: { value: "24h" | "7d" | "all"; label: string }[] = [
  { value: "24h", label: "24h" },
  { value: "7d", label: "7 days" },
  { value: "all", label: "All time" },
]

interface CategoryChipsProps {
  value: SourceCategory | "all"
  onChange: (value: SourceCategory | "all") => void
}

export function CategoryChips({ value, onChange }: CategoryChipsProps) {
  const handleChange = (newValue: SourceCategory | "all") => {
    hapticLight()
    onChange(newValue)
  }

  return (
    <div className="-mx-[var(--spacing-4)] overflow-x-auto px-[var(--spacing-4)] scrollbar-none scroll-smooth">
      <div className="flex gap-[6px]">
        {CATEGORIES.map((cat) => (
          <button
            key={cat.value}
            onClick={() => handleChange(cat.value)}
            className={cn(
              // min-h-[32px] with py gives touch area; horizontal spacing adequate
              "shrink-0 rounded-full min-h-[32px] px-[14px] py-[6px] text-[13px] font-medium tracking-[-0.08px] transition-all duration-[var(--duration-fast)] ease-[var(--ease-ios)]",
              value === cat.value
                ? "bg-[var(--color-text-primary)] text-white"
                : "text-[var(--color-text-secondary)] active:bg-[var(--color-fill-tertiary)]"
            )}
          >
            {cat.label}
          </button>
        ))}
      </div>
    </div>
  )
}

interface TimeWindowToggleProps {
  value: "24h" | "7d" | "all"
  onChange: (value: "24h" | "7d" | "all") => void
}

export function TimeWindowToggle({ value, onChange }: TimeWindowToggleProps) {
  const [open, setOpen] = useState(false)

  const handleChange = (newValue: "24h" | "7d" | "all") => {
    hapticLight()
    onChange(newValue)
    setOpen(false)
  }

  const currentLabel = TIME_WINDOWS.find((tw) => tw.value === value)?.label ?? "7 days"

  return (
    <Sheet open={open} onOpenChange={setOpen}>
      <SheetTrigger asChild>
        <button
          className="flex min-h-[44px] items-center gap-[5px] px-[8px] -ml-[8px] text-[13px] font-medium tracking-[-0.08px] text-[var(--color-text-secondary)] transition-colors active:text-[var(--color-text-tertiary)]"
          onClick={() => hapticLight()}
        >
          <Clock className="h-[14px] w-[14px]" strokeWidth={2} />
          <span>{currentLabel}</span>
          <ChevronDown className="h-[12px] w-[12px] opacity-50" strokeWidth={2} />
        </button>
      </SheetTrigger>
      <SheetContent
        side="bottom"
        className="h-auto max-h-[45vh] rounded-t-[var(--radius-3xl)] bg-[var(--color-bg-grouped)] p-0"
      >
        <div className="drag-indicator" />
        <SheetHeader className="px-[18px] pb-[12px] pt-[14px]">
          <SheetTitle className="text-[17px] font-semibold tracking-[-0.32px]">Time Range</SheetTitle>
        </SheetHeader>
        <div className="mx-[16px] mb-[calc(var(--safe-area-inset-bottom)+16px)] overflow-hidden rounded-[var(--radius-xl)] bg-[var(--color-surface)]">
          {TIME_WINDOWS.map((tw, index) => (
            <div key={tw.value}>
              <button
                onClick={() => handleChange(tw.value)}
                className="flex w-full min-h-[48px] items-center justify-between px-[16px] py-[12px] text-left transition-colors duration-[var(--duration-instant)] active:bg-[var(--color-fill-quaternary)]"
              >
                <span className="text-[15px] font-medium tracking-[-0.18px] text-[var(--color-text-primary)]">
                  {tw.label}
                </span>
                {value === tw.value && (
                  <Check className="h-[18px] w-[18px] text-[var(--color-accent)]" strokeWidth={2.5} />
                )}
              </button>
              {index < TIME_WINDOWS.length - 1 && (
                <div className="ml-[16px] h-[0.5px] bg-[var(--color-separator)]" />
              )}
            </div>
          ))}
        </div>
      </SheetContent>
    </Sheet>
  )
}

interface SourceFilterProps {
  sources: { id: string; name: string }[]
  selectedIds: string[]
  onChange: (ids: string[]) => void
}

export function SourceFilter({ sources, selectedIds, onChange }: SourceFilterProps) {
  const [open, setOpen] = useState(false)

  const toggleSource = (id: string) => {
    hapticLight()
    if (selectedIds.includes(id)) {
      onChange(selectedIds.filter((s) => s !== id))
    } else {
      onChange([...selectedIds, id])
    }
  }

  const clearAll = () => {
    hapticLight()
    onChange([])
  }

  const label = selectedIds.length === 0
    ? "All sources"
    : selectedIds.length === 1
      ? sources.find((s) => s.id === selectedIds[0])?.name ?? "1 source"
      : `${selectedIds.length} sources`

  return (
    <Sheet open={open} onOpenChange={setOpen}>
      <SheetTrigger asChild>
        <button
          className={cn(
            "flex min-h-[44px] items-center gap-[5px] px-[8px] -ml-[8px] text-[13px] font-medium tracking-[-0.08px] transition-colors active:text-[var(--color-text-tertiary)]",
            selectedIds.length > 0
              ? "text-[var(--color-accent)]"
              : "text-[var(--color-text-secondary)]"
          )}
          onClick={() => hapticLight()}
        >
          <Newspaper className="h-[14px] w-[14px]" strokeWidth={2} />
          <span>{label}</span>
          <ChevronDown className="h-[12px] w-[12px] opacity-50" strokeWidth={2} />
        </button>
      </SheetTrigger>
      <SheetContent
        side="bottom"
        className="h-[55vh] rounded-t-[var(--radius-3xl)] bg-[var(--color-bg-grouped)] p-0"
      >
        <div className="drag-indicator" />

        <SheetHeader className="flex-row items-center justify-between px-[18px] pb-[12px] pt-[14px]">
          <SheetTitle className="text-[17px] font-semibold tracking-[-0.32px]">Sources</SheetTitle>
          {selectedIds.length > 0 && (
            <Button variant="ghost" size="sm" onClick={clearAll} className="text-[var(--color-accent)] font-medium text-[14px]">
              Clear
            </Button>
          )}
        </SheetHeader>

        <div className="mx-[16px] mb-[calc(var(--safe-area-inset-bottom)+16px)] overflow-hidden rounded-[var(--radius-xl)] bg-[var(--color-surface)]">
          <div className="max-h-[calc(55vh-120px)] overflow-y-auto">
            {sources.map((source, index) => {
              const isSelected = selectedIds.includes(source.id)
              return (
                <div key={source.id}>
                  <button
                    onClick={() => toggleSource(source.id)}
                    className="flex w-full min-h-[48px] items-center justify-between px-[16px] py-[12px] text-left transition-colors duration-[var(--duration-instant)] active:bg-[var(--color-fill-quaternary)]"
                  >
                    <span className="text-[15px] font-medium tracking-[-0.18px] text-[var(--color-text-primary)]">
                      {source.name}
                    </span>
                    {isSelected && (
                      <Check className="h-[18px] w-[18px] text-[var(--color-accent)]" strokeWidth={2.5} />
                    )}
                  </button>
                  {index < sources.length - 1 && (
                    <div className="ml-[16px] h-[0.5px] bg-[var(--color-separator)]" />
                  )}
                </div>
              )
            })}
          </div>
        </div>
      </SheetContent>
    </Sheet>
  )
}



================================================================================
FILE: src/components/feed/index.ts
================================================================================
/**
 * Feed components exports
 */

export { CategoryChips, TimeWindowToggle, SourceFilter } from "./FeedFilters"
export { SearchBar } from "./SearchBar"
export { ArticleRow, ArticleRowSkeleton } from "./ArticleRow"
export { ArticleCard, ArticleCardSkeleton } from "./ArticleCard"
export { ArticleDetailSheet } from "./ArticleDetailSheet"



================================================================================
FILE: src/components/feed/SearchBar.tsx
================================================================================
/**
 * Search bar component for the Feed page
 * iOS-native search field design
 */

import { Search, X } from "lucide-react"
import { useRef } from "react"

interface SearchBarProps {
  value: string
  onChange: (value: string) => void
  placeholder?: string
}

export function SearchBar({ value, onChange, placeholder = "Search" }: SearchBarProps) {
  const inputRef = useRef<HTMLInputElement>(null)

  const handleClear = () => {
    onChange("")
    inputRef.current?.focus()
  }

  return (
    <div className="relative">
      <Search
        className="absolute left-[10px] top-1/2 h-[16px] w-[16px] -translate-y-1/2 text-[var(--color-text-tertiary)] pointer-events-none"
        strokeWidth={2}
      />
      <input
        ref={inputRef}
        type="text"
        value={value}
        onChange={(e) => onChange(e.target.value)}
        placeholder={placeholder}
        className="h-[36px] w-full rounded-[10px] bg-[var(--color-fill-tertiary)] pl-[32px] pr-[32px] text-[16px] tracking-[-0.2px] text-[var(--color-text-primary)] placeholder:text-[var(--color-text-tertiary)] focus:outline-none focus:bg-[var(--color-fill-secondary)] transition-colors duration-[var(--duration-fast)]"
      />
      {value && (
        <button
          onClick={handleClear}
          aria-label="Clear search"
          className="absolute right-0 top-1/2 flex h-[44px] w-[44px] -translate-y-1/2 items-center justify-center"
        >
          {/* Visual clear button - smaller visible element with proper touch target */}
          <span className="flex h-[18px] w-[18px] items-center justify-center rounded-full bg-[var(--color-fill-secondary)] text-[var(--color-text-tertiary)] transition-transform duration-[var(--duration-instant)] active:scale-90">
            <X className="h-[10px] w-[10px]" strokeWidth={3} />
          </span>
        </button>
      )}
    </div>
  )
}



================================================================================
FILE: src/components/layout/index.ts
================================================================================
/**
 * Layout components for P&C Insurance News AI
 */

export { TopNav, MenuButton } from "./TopNav"



================================================================================
FILE: src/components/layout/TopNav.tsx
================================================================================
/**
 * TopNav - iOS-style sticky top navigation with large title collapse behavior
 * 
 * Features:
 * - Brand mark + app name on top-level screens, or back button for sub-screens
 * - Menu button (Sheet trigger) with 44px tap target
 * - Glass/blur background
 * - Collapsed title that appears when large title scrolls out of view
 * - Optional right-side action slot
 */

import React from "react"
import { useNavigate } from "react-router-dom"
import { Menu, ChevronLeft } from "lucide-react"
import { Button } from "@/components/ui/button"
import { AppLogo } from "@/components/ui/app-logo"
import { hapticLight, hapticMedium } from "@/lib/haptics"
import { cn } from "@/lib/utils"

interface TopNavProps {
  /** Page title shown in collapsed state */
  title: string
  /** Whether the large title is visible (controls collapsed state) */
  isLargeTitleVisible: boolean
  /** Optional action element for the right side (appears left of menu button) */
  rightAction?: React.ReactNode
  /** Sheet trigger to open navigation menu */
  menuTrigger: React.ReactNode
  /** Whether this is a sub-screen with back navigation */
  isSubScreen?: boolean
  /** Custom back action (defaults to navigate(-1)) */
  onBack?: () => void
}

export function TopNav({
  title,
  isLargeTitleVisible,
  rightAction,
  menuTrigger,
  isSubScreen = false,
  onBack,
}: TopNavProps) {
  const navigate = useNavigate()
  
  const handleBack = () => {
    hapticLight()
    if (onBack) {
      onBack()
    } else {
      navigate(-1)
    }
  }

  return (
    <header className="glass-nav sticky top-0 z-40 shadow-[var(--shadow-nav)]">
      <div
        className="safe-area-padding-x"
        style={{ paddingTop: 'var(--safe-area-inset-top)' }}
      >
        <div className="flex h-[52px] items-center justify-between px-[var(--spacing-4)]">
          {/* Left side: Brand or Back button */}
          <div className="flex items-center gap-[10px] min-w-0 flex-1">
            {isSubScreen ? (
              <Button
                variant="ghost"
                size="icon"
                className="-ml-2 h-[44px] w-[44px] rounded-full text-[var(--color-accent)] transition-all duration-[var(--duration-fast)] hover:bg-[var(--color-fill-tertiary)] active:bg-[var(--color-fill-secondary)] active:scale-[0.92]"
                onClick={handleBack}
              >
                <ChevronLeft className="h-[24px] w-[24px]" strokeWidth={2} />
                <span className="sr-only">Go back</span>
              </Button>
            ) : (
              <>
                <AppLogo size={32} glow className="shrink-0 drop-shadow-[0_1px_3px_rgba(10,42,69,0.25)]" />
                {/* Collapsed title - fades in when large title scrolls out */}
                <div
                  className={cn(
                    "transition-all duration-[var(--duration-normal)] ease-[var(--ease-ios)]",
                    isLargeTitleVisible
                      ? "opacity-0 translate-y-[4px]"
                      : "opacity-100 translate-y-0"
                  )}
                >
                  <span className="text-[17px] font-semibold tracking-[-0.35px] text-[var(--color-text-primary)] whitespace-nowrap">
                    {title}
                  </span>
                </div>
              </>
            )}
          </div>

          {/* Right side: Optional action + Menu button */}
          <div className="flex items-center gap-[4px] shrink-0">
            {rightAction}
            {menuTrigger}
          </div>
        </div>
      </div>
    </header>
  )
}

/**
 * MenuButton - Standardized menu trigger button
 * Use with Sheet + SheetTrigger
 */
interface MenuButtonProps {
  onClick?: (e: React.MouseEvent<HTMLButtonElement>) => void
  className?: string
}

export const MenuButton = React.forwardRef<HTMLButtonElement, MenuButtonProps>(
  ({ onClick, className }, ref) => {
    return (
      <Button
        ref={ref}
        variant="ghost"
        size="icon"
        className={cn(
          "-mr-2 h-[44px] w-[44px] rounded-full text-[var(--color-text-secondary)] transition-all duration-[var(--duration-fast)] hover:bg-[var(--color-fill-tertiary)] active:bg-[var(--color-fill-secondary)] active:scale-[0.92]",
          className
        )}
        onClick={(e) => {
          hapticMedium()
          onClick?.(e)
        }}
      >
        <Menu className="h-[22px] w-[22px]" strokeWidth={1.8} />
        <span className="sr-only">Open menu</span>
      </Button>
    )
  }
)
MenuButton.displayName = "MenuButton"



================================================================================
FILE: src/components/sources/index.ts
================================================================================
/**
 * Sources components exports
 */

export { SourceRow, SourceRowSkeleton } from "./SourceRow"



================================================================================
FILE: src/components/sources/SourceRow.tsx
================================================================================
/**
 * Source row component with toggle switch - iOS Settings quality
 */

import { ExternalLink } from "lucide-react"
import { Switch } from "@/components/ui/switch"
import type { Source } from "@/types/firestore"
import { hapticLight } from "@/lib/haptics"

interface SourceRowProps {
  source: Source
  isFollowing: boolean
  onToggle: (enabled: boolean) => void
  isLoading?: boolean
}

// Category display labels
const CATEGORY_LABELS: Record<string, string> = {
  property_cat: "Property",
  casualty_liability: "Casualty",
  regulation: "Regulation",
  claims: "Claims",
  reinsurance: "Reinsurance",
  insurtech: "InsurTech",
}

// Category colors - muted, tasteful palette
const CATEGORY_COLORS: Record<string, string> = {
  property_cat: "rgba(0, 122, 255, 0.65)",
  casualty_liability: "rgba(175, 82, 222, 0.65)",
  regulation: "rgba(88, 86, 214, 0.65)",
  claims: "rgba(255, 149, 0, 0.65)",
  reinsurance: "rgba(48, 176, 199, 0.65)",
  insurtech: "rgba(52, 199, 89, 0.65)",
}

export function SourceRow({
  source,
  isFollowing,
  onToggle,
  isLoading,
}: SourceRowProps) {
  const handleExternalClick = (e: React.MouseEvent) => {
    e.stopPropagation()
    hapticLight()
  }

  return (
    <div className="flex min-h-[56px] items-center gap-[var(--spacing-3)] px-[20px] py-[12px]">
      {/* Source info */}
      <div className="min-w-0 flex-1">
        {/* Name row with external link */}
        <div className="flex items-center gap-[6px]">
          <h3 className="text-[17px] font-normal tracking-[-0.4px] text-[var(--color-text-primary)]">
            {source.name}
          </h3>
          <a
            href={source.siteUrl}
            target="_blank"
            rel="noopener noreferrer"
            onClick={handleExternalClick}
            className="flex h-[28px] w-[28px] shrink-0 items-center justify-center rounded-full text-[var(--color-text-quaternary)] transition-colors active:bg-[var(--color-fill-tertiary)]"
            aria-label={`Visit ${source.name} website`}
          >
            <ExternalLink className="h-[12px] w-[12px]" strokeWidth={1.75} />
          </a>
        </div>

        {/* Category tags - cleaner inline layout */}
        {source.tags.length > 0 && (
          <div className="mt-[3px] flex items-center gap-[6px]">
            {source.tags.slice(0, 3).map((tag, index) => (
              <div key={tag} className="flex items-center gap-[5px]">
                <span
                  className="h-[6px] w-[6px] rounded-full"
                  style={{ backgroundColor: CATEGORY_COLORS[tag] || "rgba(60, 60, 67, 0.3)" }}
                />
                <span className="text-[13px] tracking-[-0.08px] text-[var(--color-text-tertiary)]">
                  {CATEGORY_LABELS[tag] || tag}
                </span>
                {index < Math.min(source.tags.length, 3) - 1 && (
                  <span className="text-[13px] text-[var(--color-text-quaternary)]">·</span>
                )}
              </div>
            ))}
          </div>
        )}
      </div>

      {/* Toggle switch - vertically centered */}
      <Switch
        checked={isFollowing}
        onCheckedChange={onToggle}
        disabled={isLoading}
        aria-label={`${isFollowing ? "Unfollow" : "Follow"} ${source.name}`}
      />
    </div>
  )
}

export function SourceRowSkeleton() {
  return (
    <div className="flex min-h-[56px] items-center gap-[var(--spacing-3)] px-[20px] py-[12px]">
      <div className="min-w-0 flex-1">
        <div className="h-[17px] w-36 rounded-[4px] skeleton-shimmer" />
        <div className="mt-[3px] flex items-center gap-[6px]">
          <div className="h-[6px] w-[6px] rounded-full skeleton-shimmer" />
          <div className="h-[13px] w-24 rounded-[3px] skeleton-shimmer" />
        </div>
      </div>
      <div className="h-[31px] w-[51px] rounded-full skeleton-shimmer" />
    </div>
  )
}



================================================================================
FILE: src/components/ui/app-logo.tsx
================================================================================
/**
 * AppLogo - Shield logo component with gradient
 * 
 * Derived from public/logo.svg - a gradient shield representing
 * protection and trust in the insurance industry.
 * 
 * The gradient flows from deep navy (#0A2A45) through ocean blue (#0D3A66)
 * to bright cyan (#35D3FF), symbolizing depth, stability, and innovation.
 */

import { cn } from "@/lib/utils"

interface AppLogoProps {
  /** Size preset or custom size in pixels */
  size?: "xs" | "sm" | "md" | "lg" | "xl" | number
  /** Additional CSS classes */
  className?: string
  /** Whether to add a subtle shadow glow effect */
  glow?: boolean
  /** Whether to render as a rounded square (for app icon style) */
  rounded?: boolean
}

const SIZE_MAP = {
  xs: 16,
  sm: 20,
  md: 32,
  lg: 40,
  xl: 64,
} as const

export function AppLogo({ 
  size = "md", 
  className,
  glow = false,
  rounded = false,
}: AppLogoProps) {
  const pixelSize = typeof size === "number" ? size : SIZE_MAP[size]
  
  // Generate unique gradient ID to avoid conflicts when multiple logos render
  const gradientId = `logo-gradient-${Math.random().toString(36).slice(2, 9)}`
  
  return (
    <svg
      width={pixelSize}
      height={pixelSize}
      viewBox="0 0 1024 1024"
      fill="none"
      xmlns="http://www.w3.org/2000/svg"
      className={cn(
        "shrink-0",
        glow && "drop-shadow-[0_2px_8px_rgba(53,211,255,0.35)]",
        rounded && "rounded-[22%]",
        className
      )}
      aria-label="P&C Brief logo"
    >
      <defs>
        <linearGradient 
          id={gradientId} 
          x1="260" 
          y1="180" 
          x2="780" 
          y2="920" 
          gradientUnits="userSpaceOnUse"
        >
          <stop offset="0%" stopColor="#0A2A45" />
          <stop offset="55%" stopColor="#0D3A66" />
          <stop offset="100%" stopColor="#35D3FF" />
        </linearGradient>
      </defs>
      
      {/* Shield path */}
      <path
        d="M512 176
           C654 176 776 248 776 380
           V556
           C776 702 654 824 512 904
           C370 824 248 702 248 556
           V380
           C248 248 370 176 512 176
           Z"
        fill={`url(#${gradientId})`}
      />
    </svg>
  )
}

/**
 * AppLogoMark - Compact version for tight spaces
 * Same shield but optimized viewBox for tighter cropping
 */
export function AppLogoMark({ 
  size = 24, 
  className 
}: { 
  size?: number
  className?: string 
}) {
  const gradientId = `logo-mark-${Math.random().toString(36).slice(2, 9)}`
  
  return (
    <svg
      width={size}
      height={size}
      viewBox="200 140 624 800"
      fill="none"
      xmlns="http://www.w3.org/2000/svg"
      className={cn("shrink-0", className)}
      aria-label="P&C Brief"
    >
      <defs>
        <linearGradient 
          id={gradientId} 
          x1="260" 
          y1="180" 
          x2="780" 
          y2="920" 
          gradientUnits="userSpaceOnUse"
        >
          <stop offset="0%" stopColor="#0A2A45" />
          <stop offset="55%" stopColor="#0D3A66" />
          <stop offset="100%" stopColor="#35D3FF" />
        </linearGradient>
      </defs>
      
      <path
        d="M512 176
           C654 176 776 248 776 380
           V556
           C776 702 654 824 512 904
           C370 824 248 702 248 556
           V380
           C248 248 370 176 512 176
           Z"
        fill={`url(#${gradientId})`}
      />
    </svg>
  )
}



================================================================================
FILE: src/components/ui/badge.tsx
================================================================================
import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"
import { cn } from "@/lib/utils"

/**
 * Badge - Compact label for status and categories
 *
 * Consistent with iOS styling: rounded full, proper padding, muted colors.
 */
const badgeVariants = cva(
  "inline-flex items-center justify-center rounded-full text-[12px] font-semibold tracking-[-0.02em] transition-colors",
  {
    variants: {
      variant: {
        default: "bg-[var(--color-accent)] text-white",
        secondary: "bg-[var(--color-fill-tertiary)] text-[var(--color-text-secondary)]",
        muted: "bg-[var(--color-fill-quaternary)] text-[var(--color-text-tertiary)]",
        destructive: "bg-[var(--color-destructive-soft)] text-[var(--color-destructive)]",
        success: "bg-[var(--color-success-soft)] text-[var(--color-success)]",
        warning: "bg-[var(--color-warning-soft)] text-[var(--color-warning)]",
        accent: "bg-gradient-to-r from-[#007AFF]/10 to-[#5856D6]/10 text-[#007AFF]",
      },
      size: {
        default: "h-[22px] px-[10px]",
        sm: "h-[18px] px-[8px] text-[11px]",
        lg: "h-[26px] px-[12px] text-[13px]",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

export interface BadgeProps
  extends React.HTMLAttributes<HTMLDivElement>,
    VariantProps<typeof badgeVariants> {}

const Badge = React.forwardRef<HTMLDivElement, BadgeProps>(
  ({ className, variant, size, ...props }, ref) => (
    <div
      ref={ref}
      className={cn(badgeVariants({ variant, size }), className)}
      {...props}
    />
  )
)
Badge.displayName = "Badge"

export { Badge, badgeVariants }



================================================================================
FILE: src/components/ui/button.tsx
================================================================================
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"
import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-[7px] whitespace-nowrap rounded-[12px] text-[15px] font-semibold tracking-[-0.2px] transition-all duration-[var(--duration-fast)] ease-[var(--ease-ios)] focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-[var(--color-accent)] focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-38 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0 active:scale-[0.96]",
  {
    variants: {
      variant: {
        default:
          "bg-[#007AFF] text-white shadow-[0_1px_3px_rgba(0,122,255,0.24),inset_0_1px_0_rgba(255,255,255,0.10)] hover:bg-[#0066D6] active:bg-[#0055B3]",
        destructive:
          "bg-[#FF3B30] text-white shadow-[0_1px_3px_rgba(255,59,48,0.24),inset_0_1px_0_rgba(255,255,255,0.10)] hover:bg-[#E5352B] active:brightness-90",
        outline:
          "bg-[var(--color-surface)] text-[var(--color-text-primary)] shadow-[var(--shadow-card)] hover:bg-[var(--color-fill-quaternary)] active:bg-[var(--color-fill-tertiary)] active:shadow-[var(--shadow-card-active)]",
        secondary:
          "bg-[var(--color-fill-tertiary)] text-[var(--color-text-primary)] hover:bg-[var(--color-fill-secondary)] active:bg-[var(--color-fill-primary)]",
        ghost:
          "text-[var(--color-text-primary)] hover:bg-[var(--color-fill-quaternary)] active:bg-[var(--color-fill-tertiary)]",
        link:
          "text-[var(--color-accent)] underline-offset-4 hover:underline active:opacity-70",
      },
      size: {
        default: "h-[46px] px-[20px]",
        sm: "h-[36px] rounded-[10px] px-[14px] text-[14px]",
        lg: "h-[52px] rounded-[14px] px-[26px] text-[16px]",
        icon: "h-[44px] w-[44px]",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, asChild = false, ...props }, ref) => {
    const Comp = asChild ? Slot : "button"
    return (
      <Comp
        className={cn(buttonVariants({ variant, size, className }))}
        ref={ref}
        {...props}
      />
    )
  }
)
Button.displayName = "Button"

export { Button, buttonVariants }



================================================================================
FILE: src/components/ui/card.tsx
================================================================================
import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"
import { cn } from "@/lib/utils"

/**
 * Card - Unified surface component with iOS-style variants
 *
 * Variants:
 * - default: Standard card with subtle shadow (for content cards)
 * - grouped: iOS Settings-style grouped list container
 * - interactive: Card that responds to press/hover (for tappable items)
 * - elevated: Slightly more prominent shadow
 */
const cardVariants = cva(
  "overflow-hidden bg-[var(--color-surface)]",
  {
    variants: {
      variant: {
        default: "rounded-[16px] shadow-[0_1px_3px_rgba(0,0,0,0.04),0_0_0_0.5px_rgba(0,0,0,0.02)]",
        grouped: "rounded-[var(--radius-xl)] shadow-[0_0.5px_1px_rgba(0,0,0,0.04),0_0_0_0.5px_rgba(0,0,0,0.015)]",
        interactive: "rounded-[16px] shadow-[0_1px_3px_rgba(0,0,0,0.04),0_0_0_0.5px_rgba(0,0,0,0.02)] transition-all duration-[var(--duration-fast)] ease-[var(--ease-ios)] cursor-pointer active:scale-[0.985] active:bg-[var(--color-fill-quaternary)]",
        elevated: "rounded-[16px] shadow-[var(--shadow-md)]",
        outline: "rounded-[var(--radius-lg)] border border-[var(--color-separator)]",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

export interface CardProps
  extends React.HTMLAttributes<HTMLDivElement>,
    VariantProps<typeof cardVariants> {}

const Card = React.forwardRef<HTMLDivElement, CardProps>(
  ({ className, variant, ...props }, ref) => (
    <div
      ref={ref}
      className={cn(cardVariants({ variant }), className)}
      {...props}
    />
  )
)
Card.displayName = "Card"

const CardHeader = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex flex-col space-y-1.5 px-[18px] py-[14px]", className)}
    {...props}
  />
))
CardHeader.displayName = "CardHeader"

const CardTitle = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn(
      "text-[17px] font-semibold leading-tight tracking-[-0.32px] text-[var(--color-text-primary)]",
      className
    )}
    {...props}
  />
))
CardTitle.displayName = "CardTitle"

const CardDescription = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("text-[15px] leading-[1.45] tracking-[-0.2px] text-[var(--color-text-secondary)]", className)}
    {...props}
  />
))
CardDescription.displayName = "CardDescription"

const CardContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("px-[18px] pb-[18px]", className)}
    {...props}
  />
))
CardContent.displayName = "CardContent"

const CardFooter = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex items-center px-[18px] pb-[14px]", className)}
    {...props}
  />
))
CardFooter.displayName = "CardFooter"

export { Card, cardVariants, CardHeader, CardFooter, CardTitle, CardDescription, CardContent }



================================================================================
FILE: src/components/ui/dropdown-menu.tsx
================================================================================
import * as React from "react"
import * as DropdownMenuPrimitive from "@radix-ui/react-dropdown-menu"
import { Check, ChevronRight, Circle } from "lucide-react"
import { cn } from "@/lib/utils"

const DropdownMenu = DropdownMenuPrimitive.Root
const DropdownMenuTrigger = DropdownMenuPrimitive.Trigger
const DropdownMenuGroup = DropdownMenuPrimitive.Group
const DropdownMenuPortal = DropdownMenuPrimitive.Portal
const DropdownMenuSub = DropdownMenuPrimitive.Sub
const DropdownMenuRadioGroup = DropdownMenuPrimitive.RadioGroup

const DropdownMenuSubTrigger = React.forwardRef<
  React.ComponentRef<typeof DropdownMenuPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubTrigger> & {
    inset?: boolean
  }
>(({ className, inset, children, ...props }, ref) => (
  <DropdownMenuPrimitive.SubTrigger
    ref={ref}
    className={cn(
      "flex cursor-default select-none items-center gap-2 rounded-[var(--radius-sm)] px-3 py-2 text-[15px] outline-none focus:bg-[var(--color-surface)] data-[state=open]:bg-[var(--color-surface)] [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
      inset && "pl-8",
      className
    )}
    {...props}
  >
    {children}
    <ChevronRight className="ml-auto" />
  </DropdownMenuPrimitive.SubTrigger>
))
DropdownMenuSubTrigger.displayName = DropdownMenuPrimitive.SubTrigger.displayName

const DropdownMenuSubContent = React.forwardRef<
  React.ComponentRef<typeof DropdownMenuPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.SubContent
    ref={ref}
    className={cn(
      "z-50 min-w-[8rem] overflow-hidden rounded-[var(--radius-md)] border border-[var(--color-border)] bg-[var(--color-surface-elevated)] p-1 text-[var(--color-text-primary)] shadow-[var(--shadow-lg)] data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95",
      className
    )}
    {...props}
  />
))
DropdownMenuSubContent.displayName = DropdownMenuPrimitive.SubContent.displayName

const DropdownMenuContent = React.forwardRef<
  React.ComponentRef<typeof DropdownMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <DropdownMenuPrimitive.Portal>
    <DropdownMenuPrimitive.Content
      ref={ref}
      sideOffset={sideOffset}
      className={cn(
        "z-50 min-w-[8rem] overflow-hidden rounded-[var(--radius-md)] border border-[var(--color-border)] bg-[var(--color-surface-elevated)] p-1 text-[var(--color-text-primary)] shadow-[var(--shadow-lg)] data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95",
        className
      )}
      {...props}
    />
  </DropdownMenuPrimitive.Portal>
))
DropdownMenuContent.displayName = DropdownMenuPrimitive.Content.displayName

const DropdownMenuItem = React.forwardRef<
  React.ComponentRef<typeof DropdownMenuPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Item> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center gap-2 rounded-[var(--radius-sm)] px-3 py-2 text-[15px] outline-none transition-colors focus:bg-[var(--color-surface)] data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
DropdownMenuItem.displayName = DropdownMenuPrimitive.Item.displayName

const DropdownMenuCheckboxItem = React.forwardRef<
  React.ComponentRef<typeof DropdownMenuPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <DropdownMenuPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-[var(--radius-sm)] py-2 pl-8 pr-3 text-[15px] outline-none transition-colors focus:bg-[var(--color-surface)] data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-4 w-4 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.CheckboxItem>
))
DropdownMenuCheckboxItem.displayName = DropdownMenuPrimitive.CheckboxItem.displayName

const DropdownMenuRadioItem = React.forwardRef<
  React.ComponentRef<typeof DropdownMenuPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <DropdownMenuPrimitive.RadioItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-[var(--radius-sm)] py-2 pl-8 pr-3 text-[15px] outline-none transition-colors focus:bg-[var(--color-surface)] data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-4 w-4 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Circle className="h-2 w-2 fill-current" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.RadioItem>
))
DropdownMenuRadioItem.displayName = DropdownMenuPrimitive.RadioItem.displayName

const DropdownMenuLabel = React.forwardRef<
  React.ComponentRef<typeof DropdownMenuPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Label> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Label
    ref={ref}
    className={cn(
      "px-3 py-1.5 text-[13px] font-semibold text-[var(--color-text-secondary)]",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
DropdownMenuLabel.displayName = DropdownMenuPrimitive.Label.displayName

const DropdownMenuSeparator = React.forwardRef<
  React.ComponentRef<typeof DropdownMenuPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-[var(--color-border)]", className)}
    {...props}
  />
))
DropdownMenuSeparator.displayName = DropdownMenuPrimitive.Separator.displayName

const DropdownMenuShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn("ml-auto text-[12px] tracking-widest text-[var(--color-text-tertiary)]", className)}
      {...props}
    />
  )
}
DropdownMenuShortcut.displayName = "DropdownMenuShortcut"

export {
  DropdownMenu,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuCheckboxItem,
  DropdownMenuRadioItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuGroup,
  DropdownMenuPortal,
  DropdownMenuSub,
  DropdownMenuSubContent,
  DropdownMenuSubTrigger,
  DropdownMenuRadioGroup,
}



================================================================================
FILE: src/components/ui/empty-state.tsx
================================================================================
/**
 * Empty State Component
 *
 * Minimal empty state for lists with no content.
 * iOS-style centered design with refined typography.
 */

import { type ReactNode } from "react"
import { type LucideIcon } from "lucide-react"
import { cn } from "@/lib/utils"

interface EmptyStateProps {
  /** Icon to display */
  icon: LucideIcon
  /** Primary heading text */
  title: string
  /** Optional description text */
  description?: string
  /** Optional action button/element */
  action?: ReactNode
  /** Optional additional class names */
  className?: string
  /** Compact variant with smaller spacing */
  compact?: boolean
}

export function EmptyState({
  icon: Icon,
  title,
  description,
  action,
  className,
  compact = false,
}: EmptyStateProps) {
  return (
    <div
      className={cn(
        "flex flex-col items-center justify-center text-center",
        compact ? "py-[32px]" : "py-[48px]",
        className
      )}
    >
      {/* Icon container - rounded square for iOS feel */}
      <div
        className={cn(
          "flex items-center justify-center rounded-[20px] bg-[var(--color-fill-tertiary)]",
          compact ? "mb-[14px] h-[48px] w-[48px]" : "mb-[18px] h-[64px] w-[64px]"
        )}
      >
        <Icon
          className={cn(
            "text-[var(--color-text-tertiary)]",
            compact ? "h-[22px] w-[22px]" : "h-[28px] w-[28px]"
          )}
          strokeWidth={1.5}
        />
      </div>

      {/* Title */}
      <h3
        className={cn(
          "font-semibold tracking-[-0.4px] text-[var(--color-text-primary)]",
          compact ? "mb-[4px] text-[17px]" : "mb-[8px] text-[20px]"
        )}
      >
        {title}
      </h3>

      {/* Description */}
      {description && (
        <p
          className={cn(
            "max-w-[260px] leading-[1.45] tracking-[-0.16px] text-[var(--color-text-tertiary)]",
            compact ? "text-[14px]" : "text-[15px]"
          )}
        >
          {description}
        </p>
      )}

      {/* Optional action button */}
      {action && <div className="mt-[20px]">{action}</div>}
    </div>
  )
}



================================================================================
FILE: src/components/ui/error-state.tsx
================================================================================
/**
 * Error State Component
 *
 * Non-alarming error display with retry capability.
 * iOS-style calm and professional design.
 */

import { type LucideIcon, WifiOff } from "lucide-react"
import { cn } from "@/lib/utils"
import { Button } from "./button"

interface ErrorStateProps {
  /** Custom icon (defaults to WifiOff) */
  icon?: LucideIcon
  /** Error heading */
  title?: string
  /** Error description */
  description?: string
  /** Retry callback */
  onRetry?: () => void
  /** Retry button label */
  retryLabel?: string
  /** Optional additional class names */
  className?: string
  /** Compact variant with smaller spacing */
  compact?: boolean
}

export function ErrorState({
  icon: Icon = WifiOff,
  title = "Unable to load",
  description = "Check your connection and try again.",
  onRetry,
  retryLabel = "Try Again",
  className,
  compact = false,
}: ErrorStateProps) {
  return (
    <div
      className={cn(
        "flex flex-col items-center justify-center text-center",
        compact ? "py-[32px]" : "py-[48px]",
        className
      )}
    >
      {/* Icon container - rounded square for iOS feel */}
      <div
        className={cn(
          "flex items-center justify-center rounded-[20px] bg-[var(--color-fill-tertiary)]",
          compact ? "mb-[14px] h-[48px] w-[48px]" : "mb-[18px] h-[64px] w-[64px]"
        )}
      >
        <Icon
          className={cn(
            "text-[var(--color-text-tertiary)]",
            compact ? "h-[22px] w-[22px]" : "h-[28px] w-[28px]"
          )}
          strokeWidth={1.5}
        />
      </div>

      {/* Title */}
      <h3
        className={cn(
          "font-semibold tracking-[-0.4px] text-[var(--color-text-primary)]",
          compact ? "mb-[4px] text-[17px]" : "mb-[8px] text-[20px]"
        )}
      >
        {title}
      </h3>

      {/* Description */}
      <p
        className={cn(
          "max-w-[260px] leading-[1.45] tracking-[-0.16px] text-[var(--color-text-tertiary)]",
          compact ? "text-[14px]" : "text-[15px]"
        )}
      >
        {description}
      </p>

      {/* Retry button */}
      {onRetry && (
        <Button variant="secondary" size="sm" onClick={onRetry} className="mt-[20px]">
          {retryLabel}
        </Button>
      )}
    </div>
  )
}



================================================================================
FILE: src/components/ui/index.ts
================================================================================
export * from "./app-logo"
export * from "./badge"
export * from "./button"
export * from "./card"
export * from "./dropdown-menu"
export * from "./empty-state"
export * from "./error-state"
export * from "./list-row"
export * from "./section-label"
export * from "./separator"
export * from "./sheet"
export * from "./skeleton"
export * from "./sonner"
export * from "./switch"
export * from "./tabs"



================================================================================
FILE: src/components/ui/list-row.tsx
================================================================================
/**
 * ListRow - iOS-style interactive list row
 * 
 * Consistent touch targets (min 44px), press feedback, and focus states.
 * Use within Card variant="grouped" for Settings-style lists.
 */

import * as React from "react"
import { cn } from "@/lib/utils"

interface ListRowProps extends React.HTMLAttributes<HTMLDivElement> {
  /** Make row interactive with press states */
  interactive?: boolean
  /** Add disclosure indicator (chevron) */
  hasChevron?: boolean
}

const ListRow = React.forwardRef<HTMLDivElement, ListRowProps>(
  ({ className, interactive = false, children, ...props }, ref) => (
    <div
      ref={ref}
      role={interactive ? "button" : undefined}
      tabIndex={interactive ? 0 : undefined}
      className={cn(
        "flex min-h-[44px] items-center gap-[12px] px-[16px] py-[12px]",
        interactive && [
          "cursor-pointer",
          "transition-colors duration-[var(--duration-instant)] ease-[var(--ease-out)]",
          "active:bg-[var(--color-fill-quaternary)]",
          "focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-[var(--color-accent)] focus-visible:ring-inset",
        ],
        className
      )}
      {...props}
    >
      {children}
    </div>
  )
)
ListRow.displayName = "ListRow"

/**
 * ListRowIcon - Leading icon container for list rows (iOS Settings style)
 */
interface ListRowIconProps extends React.HTMLAttributes<HTMLDivElement> {
  /** Background color for the icon container */
  color?: string
  /** Whether icon is disabled (reduced opacity) */
  disabled?: boolean
}

const ListRowIcon = React.forwardRef<HTMLDivElement, ListRowIconProps>(
  ({ className, color, disabled, children, ...props }, ref) => (
    <div
      ref={ref}
      className={cn(
        "flex h-[29px] w-[29px] shrink-0 items-center justify-center rounded-[6px]",
        disabled && "opacity-50",
        !color && "bg-[var(--color-fill-secondary)]",
        className
      )}
      style={color ? { backgroundColor: color } : undefined}
      {...props}
    >
      {children}
    </div>
  )
)
ListRowIcon.displayName = "ListRowIcon"

/**
 * ListRowContent - Main content area for list rows
 */
const ListRowContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex-1 min-w-0", className)}
    {...props}
  />
))
ListRowContent.displayName = "ListRowContent"

/**
 * ListRowLabel - Primary text for list rows
 */
const ListRowLabel = React.forwardRef<
  HTMLSpanElement,
  React.HTMLAttributes<HTMLSpanElement> & { disabled?: boolean }
>(({ className, disabled, ...props }, ref) => (
  <span
    ref={ref}
    className={cn(
      "block text-[17px] leading-[22px] tracking-[-0.4px]",
      disabled ? "text-[var(--color-text-tertiary)]" : "text-[var(--color-text-primary)]",
      className
    )}
    {...props}
  />
))
ListRowLabel.displayName = "ListRowLabel"

/**
 * ListRowValue - Secondary/trailing value text for list rows
 */
const ListRowValue = React.forwardRef<
  HTMLSpanElement,
  React.HTMLAttributes<HTMLSpanElement>
>(({ className, ...props }, ref) => (
  <span
    ref={ref}
    className={cn(
      "text-[17px] text-[var(--color-text-tertiary)]",
      className
    )}
    {...props}
  />
))
ListRowValue.displayName = "ListRowValue"

export { 
  ListRow, 
  ListRowIcon, 
  ListRowContent, 
  ListRowLabel, 
  ListRowValue,
  type ListRowProps,
  type ListRowIconProps,
}



================================================================================
FILE: src/components/ui/section-label.tsx
================================================================================
/**
 * SectionLabel - iOS-style section header text
 * 
 * Used for labeling groups of content in list views and pages.
 * Follows Apple HIG typography for section headers.
 */

import * as React from "react"
import { cn } from "@/lib/utils"
import type { LucideIcon } from "lucide-react"

interface SectionLabelProps extends React.HTMLAttributes<HTMLDivElement> {
  /** Optional icon to display alongside label */
  icon?: LucideIcon
  /** Add left padding for grouped list context (Settings-style) */
  inset?: boolean
}

const SectionLabel = React.forwardRef<HTMLDivElement, SectionLabelProps>(
  ({ className, children, icon: Icon, inset = false, ...props }, ref) => (
    <div
      ref={ref}
      className={cn(
        "flex items-center gap-[8px] text-[12px] font-semibold uppercase tracking-[0.04em] text-[var(--color-text-tertiary)]",
        inset && "pl-[16px]",
        className
      )}
      {...props}
    >
      {Icon && <Icon className="h-[14px] w-[14px]" strokeWidth={2} />}
      <span>{children}</span>
    </div>
  )
)
SectionLabel.displayName = "SectionLabel"

/**
 * SectionFooter - iOS-style section footer/description text
 * 
 * Used for explanatory text below grouped content sections.
 */
interface SectionFooterProps extends React.HTMLAttributes<HTMLParagraphElement> {
  /** Add left/right padding for grouped list context */
  inset?: boolean
}

const SectionFooter = React.forwardRef<HTMLParagraphElement, SectionFooterProps>(
  ({ className, inset = false, ...props }, ref) => (
    <p
      ref={ref}
      className={cn(
        "text-[13px] leading-[18px] text-[var(--color-text-tertiary)]",
        inset && "px-[16px]",
        className
      )}
      {...props}
    />
  )
)
SectionFooter.displayName = "SectionFooter"

export { SectionLabel, SectionFooter }



================================================================================
FILE: src/components/ui/separator.tsx
================================================================================
import * as React from "react"
import { cn } from "@/lib/utils"

/**
 * Separator - iOS-style divider line
 *
 * Variants:
 * - full: Full-width separator (default)
 * - inset: Standard inset (16px left margin) for list rows
 * - inset-icon: Larger inset (56px left margin) for rows with leading icons
 *
 * Uses 0.5px height for true iOS hairline appearance
 */
interface SeparatorProps extends React.HTMLAttributes<HTMLDivElement> {
  orientation?: "horizontal" | "vertical"
  variant?: "full" | "inset" | "inset-icon"
}

const Separator = React.forwardRef<HTMLDivElement, SeparatorProps>(
  ({ className, orientation = "horizontal", variant = "full", ...props }, ref) => {
    const insetMargin = variant === "inset"
      ? "ml-[16px]"
      : variant === "inset-icon"
        ? "ml-[56px]"
        : ""

    return (
      <div
        ref={ref}
        role="separator"
        aria-orientation={orientation}
        className={cn(
          "shrink-0 bg-[var(--color-separator)]",
          orientation === "horizontal"
            ? `h-[0.5px] w-full ${insetMargin}`
            : "h-full w-[0.5px]",
          className
        )}
        {...props}
      />
    )
  }
)
Separator.displayName = "Separator"

export { Separator, type SeparatorProps }



================================================================================
FILE: src/components/ui/sheet.tsx
================================================================================
import * as React from "react"
import * as DialogPrimitive from "@radix-ui/react-dialog"
import { cva, type VariantProps } from "class-variance-authority"
import { X } from "lucide-react"
import { cn } from "@/lib/utils"

const Sheet = DialogPrimitive.Root
const SheetTrigger = DialogPrimitive.Trigger
const SheetClose = DialogPrimitive.Close
const SheetPortal = DialogPrimitive.Portal

const SheetOverlay = React.forwardRef<
  React.ComponentRef<typeof DialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Overlay
    className={cn(
      "fixed inset-0 z-50 bg-black/45 backdrop-blur-[8px] data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:duration-[var(--duration-fast)] data-[state=open]:duration-[var(--duration-normal)]",
      className
    )}
    {...props}
    ref={ref}
  />
))
SheetOverlay.displayName = DialogPrimitive.Overlay.displayName

const sheetVariants = cva(
  "fixed z-50 bg-[var(--color-surface-elevated)] shadow-[var(--shadow-sheet)] transition ease-[var(--ease-ios)] data-[state=closed]:duration-[var(--duration-normal)] data-[state=open]:duration-[var(--duration-sheet)] data-[state=open]:animate-in data-[state=closed]:animate-out",
  {
    variants: {
      side: {
        top: "inset-x-0 top-0 data-[state=closed]:slide-out-to-top data-[state=open]:slide-in-from-top",
        bottom:
          "inset-x-0 bottom-0 rounded-t-[var(--radius-3xl)] data-[state=closed]:slide-out-to-bottom data-[state=open]:slide-in-from-bottom",
        left: "inset-y-0 left-0 h-full w-3/4 data-[state=closed]:slide-out-to-left data-[state=open]:slide-in-from-left sm:max-w-sm",
        right:
          "inset-y-0 right-0 h-full w-3/4 data-[state=closed]:slide-out-to-right data-[state=open]:slide-in-from-right sm:max-w-sm",
      },
    },
    defaultVariants: {
      side: "right",
    },
  }
)

interface SheetContentProps
  extends React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content>,
    VariantProps<typeof sheetVariants> {
  /** Hide the default close button (for bottom sheets with drag indicator) */
  hideCloseButton?: boolean
}

const SheetContent = React.forwardRef<
  React.ComponentRef<typeof DialogPrimitive.Content>,
  SheetContentProps
>(({ side = "right", className, children, hideCloseButton = false, ...props }, ref) => {
  const isBottomSheet = side === "bottom"
  const isSideSheet = side === "left" || side === "right"

  return (
    <SheetPortal>
      <SheetOverlay />
      <DialogPrimitive.Content
        ref={ref}
        className={cn(sheetVariants({ side }), className)}
        {...props}
      >
        {/* Close button - positioned with safe area awareness for side sheets, hidden for bottom sheets by default */}
        {!hideCloseButton && !isBottomSheet && (
          <DialogPrimitive.Close
            className={cn(
              "absolute z-10 flex h-[32px] w-[32px] items-center justify-center rounded-full bg-[var(--color-fill-tertiary)] text-[var(--color-text-secondary)] transition-all duration-[var(--duration-fast)] hover:bg-[var(--color-fill-secondary)] active:scale-[0.92] focus:outline-none",
              isSideSheet && "right-[16px] top-[calc(16px+var(--safe-area-inset-top))]"
            )}
          >
            <X className="h-[15px] w-[15px]" strokeWidth={2.25} />
            <span className="sr-only">Close</span>
          </DialogPrimitive.Close>
        )}
        {children}
      </DialogPrimitive.Content>
    </SheetPortal>
  )
})
SheetContent.displayName = DialogPrimitive.Content.displayName

const SheetHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col gap-[4px] text-center sm:text-left",
      className
    )}
    {...props}
  />
)
SheetHeader.displayName = "SheetHeader"

const SheetFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse gap-[10px] sm:flex-row sm:justify-end",
      className
    )}
    {...props}
  />
)
SheetFooter.displayName = "SheetFooter"

const SheetTitle = React.forwardRef<
  React.ComponentRef<typeof DialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Title
    ref={ref}
    className={cn("text-[20px] font-bold leading-[1.2] tracking-[-0.36px] text-[var(--color-text-primary)]", className)}
    {...props}
  />
))
SheetTitle.displayName = DialogPrimitive.Title.displayName

const SheetDescription = React.forwardRef<
  React.ComponentRef<typeof DialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Description
    ref={ref}
    className={cn("text-[14px] leading-[1.5] tracking-[-0.14px] text-[var(--color-text-secondary)]", className)}
    {...props}
  />
))
SheetDescription.displayName = DialogPrimitive.Description.displayName

export {
  Sheet,
  SheetPortal,
  SheetOverlay,
  SheetTrigger,
  SheetClose,
  SheetContent,
  SheetHeader,
  SheetFooter,
  SheetTitle,
  SheetDescription,
}



================================================================================
FILE: src/components/ui/skeleton.tsx
================================================================================
import { cn } from "@/lib/utils"

function Skeleton({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) {
  return (
    <div
      className={cn(
        "skeleton-shimmer rounded-[var(--radius-sm)]",
        className
      )}
      {...props}
    />
  )
}

export { Skeleton }



================================================================================
FILE: src/components/ui/sonner.tsx
================================================================================
import { Toaster as Sonner } from "sonner"

type ToasterProps = React.ComponentProps<typeof Sonner>

const Toaster = ({ ...props }: ToasterProps) => {
  return (
    <Sonner
      className="toaster group"
      toastOptions={{
        classNames: {
          toast:
            "group toast group-[.toaster]:bg-[var(--color-surface-elevated)] group-[.toaster]:text-[var(--color-text-primary)] group-[.toaster]:border-[var(--color-border)] group-[.toaster]:shadow-[var(--shadow-lg)] group-[.toaster]:rounded-[var(--radius-md)]",
          description: "group-[.toast]:text-[var(--color-text-secondary)]",
          actionButton:
            "group-[.toast]:bg-[var(--color-accent)] group-[.toast]:text-white",
          cancelButton:
            "group-[.toast]:bg-[var(--color-surface)] group-[.toast]:text-[var(--color-text-secondary)]",
        },
      }}
      {...props}
    />
  )
}

export { Toaster }



================================================================================
FILE: src/components/ui/switch.tsx
================================================================================
/**
 * Switch component - iOS-style toggle
 */

import * as React from "react"
import * as SwitchPrimitives from "@radix-ui/react-switch"
import { cn } from "@/lib/utils"

const Switch = React.forwardRef<
  React.ComponentRef<typeof SwitchPrimitives.Root>,
  React.ComponentPropsWithoutRef<typeof SwitchPrimitives.Root>
>(({ className, ...props }, ref) => (
  <SwitchPrimitives.Root
    className={cn(
      "peer inline-flex h-[31px] w-[51px] shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent transition-all duration-[var(--duration-normal)] ease-[var(--ease-ios)] focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-[var(--color-accent)] focus-visible:ring-offset-2 focus-visible:ring-offset-[var(--color-background)] disabled:cursor-not-allowed disabled:opacity-38 data-[state=checked]:bg-[#34C759] data-[state=unchecked]:bg-[rgba(120,120,128,0.16)]",
      className
    )}
    {...props}
    ref={ref}
  >
    <SwitchPrimitives.Thumb
      className={cn(
        "pointer-events-none block h-[27px] w-[27px] rounded-full bg-white shadow-[0_2px_4px_rgba(0,0,0,0.12),0_0_1px_rgba(0,0,0,0.04)] ring-0 transition-transform duration-[var(--duration-normal)] ease-[var(--ease-ios-spring)] data-[state=checked]:translate-x-5 data-[state=unchecked]:translate-x-0"
      )}
    />
  </SwitchPrimitives.Root>
))
Switch.displayName = SwitchPrimitives.Root.displayName

export { Switch }



================================================================================
FILE: src/components/ui/tabs.tsx
================================================================================
import * as React from "react"
import * as TabsPrimitive from "@radix-ui/react-tabs"
import { cn } from "@/lib/utils"

const Tabs = TabsPrimitive.Root

const TabsList = React.forwardRef<
  React.ComponentRef<typeof TabsPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.List>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.List
    ref={ref}
    className={cn(
      "inline-flex h-11 items-center justify-center rounded-[var(--radius-md)] bg-[var(--color-surface)] p-1 text-[var(--color-text-secondary)]",
      className
    )}
    {...props}
  />
))
TabsList.displayName = TabsPrimitive.List.displayName

const TabsTrigger = React.forwardRef<
  React.ComponentRef<typeof TabsPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Trigger>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Trigger
    ref={ref}
    className={cn(
      "inline-flex items-center justify-center whitespace-nowrap rounded-[var(--radius-sm)] px-4 py-1.5 text-[15px] font-medium transition-all duration-[var(--duration-fast)] focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-[var(--color-accent)] focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:bg-[var(--color-surface-elevated)] data-[state=active]:text-[var(--color-text-primary)] data-[state=active]:shadow-[var(--shadow-sm)]",
      className
    )}
    {...props}
  />
))
TabsTrigger.displayName = TabsPrimitive.Trigger.displayName

const TabsContent = React.forwardRef<
  React.ComponentRef<typeof TabsPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Content>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Content
    ref={ref}
    className={cn(
      "mt-[var(--spacing-md)] focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-[var(--color-accent)] focus-visible:ring-offset-2",
      className
    )}
    {...props}
  />
))
TabsContent.displayName = TabsPrimitive.Content.displayName

export { Tabs, TabsList, TabsTrigger, TabsContent }



================================================================================
FILE: src/index.css
================================================================================
@import "tailwindcss";

/* ===== Apple-Inspired Design Tokens (2026) ===== */
:root {
  /* Typography - SF Pro-like system font stack with optimized rendering */
  --font-sans: -apple-system, BlinkMacSystemFont, "SF Pro Text", "SF Pro Display",
    "Helvetica Neue", "Segoe UI", Roboto, system-ui, sans-serif;
  --font-display: -apple-system, BlinkMacSystemFont, "SF Pro Display",
    "Helvetica Neue", "Segoe UI", Roboto, system-ui, sans-serif;

  /* Colors - Light mode (iOS 18+ / visionOS 2026 refined palette) */
  --color-background: #FFFFFF;
  --color-bg-grouped: #F2F2F7;
  --color-bg-grouped-secondary: #EFEFF4;
  --color-bg-subtle: #FAFAFA;
  --color-surface: #FFFFFF;
  --color-surface-elevated: #FFFFFF;
  --color-surface-secondary: #F9F9FB;
  --color-surface-tertiary: #F5F5F7;
  --color-border: rgba(0, 0, 0, 0.04);
  --color-border-strong: rgba(0, 0, 0, 0.06);
  --color-separator: rgba(60, 60, 67, 0.08);
  --color-separator-opaque: #E5E5EA;
  --color-text-primary: #1D1D1F;
  --color-text-secondary: rgba(60, 60, 67, 0.68);
  --color-text-tertiary: rgba(60, 60, 67, 0.42);
  --color-text-quaternary: rgba(60, 60, 67, 0.28);
  --color-accent: #007AFF;
  --color-accent-soft: rgba(0, 122, 255, 0.12);
  --color-accent-hover: #0066D6;
  --color-accent-pressed: #0055B3;
  --color-destructive: #FF3B30;
  --color-destructive-soft: rgba(255, 59, 48, 0.12);
  --color-success: #34C759;
  --color-success-soft: rgba(52, 199, 89, 0.12);
  --color-warning: #FF9500;
  --color-warning-soft: rgba(255, 149, 0, 0.12);
  --color-purple: #AF52DE;
  --color-purple-soft: rgba(175, 82, 222, 0.12);
  --color-orange: #FF9500;
  --color-orange-soft: rgba(255, 149, 0, 0.12);
  --color-red: #FF3B30;
  --color-teal: #5AC8FA;
  --color-teal-soft: rgba(90, 200, 250, 0.12);
  --color-indigo: #5856D6;
  --color-indigo-soft: rgba(88, 86, 214, 0.12);
  --color-pink: #FF2D55;
  --color-pink-soft: rgba(255, 45, 85, 0.12);
  --color-cyan: #32ADE6;
  --color-cyan-soft: rgba(50, 173, 230, 0.12);
  --color-mint: #00C7BE;
  --color-mint-soft: rgba(0, 199, 190, 0.12);
  --color-fill-primary: rgba(120, 120, 128, 0.16);
  --color-fill-secondary: rgba(120, 120, 128, 0.12);
  --color-fill-tertiary: rgba(120, 120, 128, 0.08);
  --color-fill-quaternary: rgba(120, 120, 128, 0.04);

  /* Spacing - iOS-inspired rhythm (4pt base with enhanced scale) */
  --spacing-0: 0px;
  --spacing-px: 1px;
  --spacing-0-5: 2px;
  --spacing-1: 4px;
  --spacing-1-5: 6px;
  --spacing-2: 8px;
  --spacing-2-5: 10px;
  --spacing-3: 12px;
  --spacing-3-5: 14px;
  --spacing-4: 16px;
  --spacing-5: 20px;
  --spacing-6: 24px;
  --spacing-7: 28px;
  --spacing-8: 32px;
  --spacing-9: 36px;
  --spacing-10: 40px;
  --spacing-11: 44px;
  --spacing-12: 48px;
  --spacing-14: 56px;
  --spacing-16: 64px;
  --spacing-20: 80px;

  /* Border Radius - iOS continuous corners (squircle-inspired) */
  --radius-xs: 6px;
  --radius-sm: 8px;
  --radius-md: 10px;
  --radius-lg: 12px;
  --radius-xl: 14px;
  --radius-2xl: 18px;
  --radius-3xl: 22px;
  --radius-4xl: 28px;
  --radius-full: 9999px;

  /* Shadows - refined iOS-style with natural depth (2026 ultra-subtle) */
  --shadow-xs: 0 1px 2px rgba(0, 0, 0, 0.03);
  --shadow-sm: 0 1px 3px rgba(0, 0, 0, 0.05), 0 1px 2px rgba(0, 0, 0, 0.02);
  --shadow-md: 0 2px 8px rgba(0, 0, 0, 0.06), 0 1px 3px rgba(0, 0, 0, 0.03);
  --shadow-lg: 0 4px 16px rgba(0, 0, 0, 0.08), 0 2px 4px rgba(0, 0, 0, 0.03);
  --shadow-xl: 0 8px 28px rgba(0, 0, 0, 0.10), 0 4px 8px rgba(0, 0, 0, 0.04);
  --shadow-2xl: 0 16px 48px rgba(0, 0, 0, 0.14), 0 6px 16px rgba(0, 0, 0, 0.06);
  --shadow-card: 0 1px 3px rgba(0, 0, 0, 0.04), 0 1px 2px rgba(0, 0, 0, 0.02);
  --shadow-card-hover: 0 6px 20px rgba(0, 0, 0, 0.08), 0 2px 6px rgba(0, 0, 0, 0.03);
  --shadow-card-active: 0 1px 2px rgba(0, 0, 0, 0.04);
  --shadow-button: 0 1px 3px rgba(0, 0, 0, 0.08), 0 1px 1px rgba(0, 0, 0, 0.04);
  --shadow-button-active: 0 1px 1px rgba(0, 0, 0, 0.04);
  --shadow-inset: inset 0 1px 2px rgba(0, 0, 0, 0.03);
  --shadow-up-sm: 0 -1px 3px rgba(0, 0, 0, 0.05);
  --shadow-up-lg: 0 -4px 16px rgba(0, 0, 0, 0.08);
  --shadow-sheet: 0 -8px 32px rgba(0, 0, 0, 0.12), 0 -2px 8px rgba(0, 0, 0, 0.04);
  --shadow-nav: 0 1px 0 rgba(0, 0, 0, 0.04);

  /* Blur - frosted glass effects */
  --blur-xs: 4px;
  --blur-sm: 8px;
  --blur-md: 16px;
  --blur-lg: 24px;
  --blur-xl: 40px;
  --blur-2xl: 64px;
  --blur-3xl: 80px;

  /* Safe Area Insets */
  --safe-area-inset-top: env(safe-area-inset-top, 0px);
  --safe-area-inset-right: env(safe-area-inset-right, 0px);
  --safe-area-inset-bottom: env(safe-area-inset-bottom, 0px);
  --safe-area-inset-left: env(safe-area-inset-left, 0px);

  /* Animation - Apple-tuned curves with refined timing (iOS 18 / 2026) */
  --duration-instant: 100ms;
  --duration-fast: 180ms;
  --duration-normal: 250ms;
  --duration-slow: 350ms;
  --duration-slower: 450ms;
  --duration-sheet: 400ms;
  --ease-out: cubic-bezier(0.16, 1, 0.3, 1);
  --ease-in: cubic-bezier(0.7, 0, 1, 0.5);
  --ease-in-out: cubic-bezier(0.4, 0, 0.2, 1);
  --ease-spring: cubic-bezier(0.175, 0.885, 0.32, 1.175);
  --ease-ios: cubic-bezier(0.25, 0.1, 0.25, 1);
  --ease-ios-spring: cubic-bezier(0.16, 1.11, 0.3, 1.02);
  --ease-bounce: cubic-bezier(0.34, 1.4, 0.64, 1);
}

/* ===== Base Styles ===== */
* {
  box-sizing: border-box;
}

html {
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  text-rendering: optimizeLegibility;
  font-feature-settings: "kern" 1, "liga" 1;
}

body {
  margin: 0;
  padding: 0;
  font-family: var(--font-sans);
  background-color: var(--color-bg-grouped);
  color: var(--color-text-primary);
  line-height: 1.47;
  font-size: 17px;
  letter-spacing: -0.022em;
  min-height: 100vh;
  min-height: 100dvh;
  -webkit-tap-highlight-color: transparent;
  touch-action: manipulation;
  scroll-behavior: smooth;
  overscroll-behavior-y: none;
}

#root {
  min-height: 100vh;
  min-height: 100dvh;
  display: flex;
  flex-direction: column;
}

/* ===== Typography Scale (SF Pro-inspired, 2026 refinements) ===== */
.text-large-title, h1 {
  font-size: 34px;
  font-weight: 700;
  line-height: 1.10;
  letter-spacing: -0.4px;
}

.text-title-1, h2 {
  font-size: 28px;
  font-weight: 700;
  line-height: 1.14;
  letter-spacing: -0.36px;
}

.text-title-2 {
  font-size: 22px;
  font-weight: 700;
  line-height: 1.18;
  letter-spacing: -0.28px;
}

.text-title-3, h3 {
  font-size: 20px;
  font-weight: 600;
  line-height: 1.20;
  letter-spacing: -0.24px;
}

.text-headline, h4 {
  font-size: 17px;
  font-weight: 600;
  line-height: 1.24;
  letter-spacing: -0.41px;
}

.text-body, p {
  font-size: 17px;
  font-weight: 400;
  line-height: 1.47;
  letter-spacing: -0.41px;
}

.text-callout {
  font-size: 16px;
  font-weight: 400;
  line-height: 1.35;
  letter-spacing: -0.32px;
}

.text-subheadline {
  font-size: 15px;
  font-weight: 400;
  line-height: 1.40;
  letter-spacing: -0.24px;
}

.text-footnote {
  font-size: 13px;
  font-weight: 400;
  line-height: 1.42;
  letter-spacing: -0.08px;
  color: var(--color-text-secondary);
}

.text-caption-1 {
  font-size: 12px;
  font-weight: 500;
  line-height: 1.33;
  letter-spacing: 0px;
  color: var(--color-text-tertiary);
}

.text-caption-2 {
  font-size: 11px;
  font-weight: 500;
  line-height: 1.27;
  letter-spacing: 0.06px;
  color: var(--color-text-tertiary);
}

/* Section label - uppercase with proper letter spacing */
.text-section-label {
  font-size: 13px;
  font-weight: 600;
  line-height: 1.23;
  letter-spacing: 0.02em;
  text-transform: uppercase;
  color: var(--color-text-tertiary);
}

/* ===== Focus States ===== */
:focus-visible {
  outline: 3px solid var(--color-accent-soft);
  outline-offset: 2px;
}

button:focus-visible,
a:focus-visible,
[role="button"]:focus-visible {
  outline: 2px solid var(--color-accent);
  outline-offset: 2px;
}

/* ===== Reduced Motion ===== */
@media (prefers-reduced-motion: reduce) {
  *,
  *::before,
  *::after {
    animation-duration: 0.01ms !important;
    animation-iteration-count: 1 !important;
    transition-duration: 0.01ms !important;
    scroll-behavior: auto !important;
  }
}

/* ===== Utility Classes ===== */
.safe-area-padding {
  padding-top: var(--safe-area-inset-top);
  padding-right: var(--safe-area-inset-right);
  padding-bottom: var(--safe-area-inset-bottom);
  padding-left: var(--safe-area-inset-left);
}

.safe-area-padding-x {
  padding-left: var(--safe-area-inset-left);
  padding-right: var(--safe-area-inset-right);
}

.safe-area-padding-y {
  padding-top: var(--safe-area-inset-top);
  padding-bottom: var(--safe-area-inset-bottom);
}

.safe-area-margin-bottom {
  margin-bottom: var(--safe-area-inset-bottom);
}

/* Glass morphism effects - refined for iOS 18 / 2026 aesthetic */
.glass {
  background: rgba(255, 255, 255, 0.85);
  backdrop-filter: saturate(180%) blur(var(--blur-xl));
  -webkit-backdrop-filter: saturate(180%) blur(var(--blur-xl));
}

.glass-subtle {
  background: rgba(255, 255, 255, 0.92);
  backdrop-filter: saturate(150%) blur(var(--blur-lg));
  -webkit-backdrop-filter: saturate(150%) blur(var(--blur-lg));
}

.glass-solid {
  background: rgba(255, 255, 255, 0.98);
  backdrop-filter: saturate(140%) blur(var(--blur-md));
  -webkit-backdrop-filter: saturate(140%) blur(var(--blur-md));
}

.glass-sheet {
  background: rgba(255, 255, 255, 0.98);
  backdrop-filter: saturate(180%) blur(var(--blur-3xl));
  -webkit-backdrop-filter: saturate(180%) blur(var(--blur-3xl));
}

.glass-nav {
  background: rgba(255, 255, 255, 0.94);
  backdrop-filter: saturate(180%) blur(28px);
  -webkit-backdrop-filter: saturate(180%) blur(28px);
}

.glass-card {
  background: rgba(255, 255, 255, 0.90);
  backdrop-filter: saturate(160%) blur(var(--blur-lg));
  -webkit-backdrop-filter: saturate(160%) blur(var(--blur-lg));
}

/* Hide scrollbar for carousel elements */
.scrollbar-none {
  -ms-overflow-style: none;
  scrollbar-width: none;
}

.scrollbar-none::-webkit-scrollbar {
  display: none;
}

/* Note: grouped-list, section-header, list-row, list-separator replaced by
   React components: Card variant="grouped", SectionLabel, ListRow, Separator */

/* Touch target minimum */
.touch-target {
  min-height: 44px;
  min-width: 44px;
}

/* iOS-style tap highlight */
@media (hover: none) {
  .tap-highlight:active {
    background-color: var(--color-fill-quaternary);
  }
}

/* Smooth scroll for carousels */
.scroll-smooth {
  scroll-behavior: smooth;
}

/* iOS-native scroll behavior for sheets */
.sheet-scroll {
  -webkit-overflow-scrolling: touch;
  overscroll-behavior: contain;
}

/* Skeleton animation - ultra-smooth, subtle */
@keyframes shimmer {
  0% {
    background-position: -200% 0;
  }
  100% {
    background-position: 200% 0;
  }
}

.skeleton-shimmer {
  background: linear-gradient(
    90deg,
    rgba(120, 120, 128, 0.08) 0%,
    rgba(120, 120, 128, 0.04) 50%,
    rgba(120, 120, 128, 0.08) 100%
  );
  background-size: 200% 100%;
  animation: shimmer 1.8s ease-in-out infinite;
  border-radius: var(--radius-sm);
}

/* Pulse animation for subtle loading states */
@keyframes subtle-pulse {
  0%, 100% {
    opacity: 1;
  }
  50% {
    opacity: 0.6;
  }
}

.animate-subtle-pulse {
  animation: subtle-pulse 2s ease-in-out infinite;
}

/* Note: card-surface, card-surface-interactive, grouped-container
   replaced by Card component variants */

/* Active press state for buttons */
.press-scale {
  transition: transform var(--duration-fast) var(--ease-out);
}

.press-scale:active {
  transform: scale(0.97);
}

/* Pill button style */
.pill {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  height: 32px;
  padding: 0 var(--spacing-3);
  border-radius: var(--radius-full);
  font-size: 14px;
  font-weight: 500;
  letter-spacing: -0.01em;
  transition: all var(--duration-fast) var(--ease-out);
}

.pill-active {
  background-color: var(--color-accent);
  color: white;
  box-shadow: var(--shadow-xs);
}

.pill-inactive {
  background-color: var(--color-fill-tertiary);
  color: var(--color-text-secondary);
}

.pill-inactive:active {
  background-color: var(--color-fill-secondary);
}

/* Drag indicator for bottom sheets - iOS HIG compliant */
.drag-indicator {
  width: 36px;
  height: 5px;
  border-radius: 100px;
  background-color: rgba(60, 60, 67, 0.20);
  margin: 8px auto 0;
  flex-shrink: 0;
}

/* Note: section-label, section-group, inset-row, section-subhead
   replaced by SectionLabel, Card variant="grouped", ListRow components */

/* Header large title style */
.large-title {
  font-size: 34px;
  font-weight: 700;
  letter-spacing: -0.4px;
  line-height: 1.10;
  color: var(--color-text-primary);
}

/* Segmented control */
.segmented-control {
  display: inline-flex;
  padding: 2px;
  background-color: var(--color-fill-tertiary);
  border-radius: var(--radius-sm);
}

.segmented-control-item {
  padding: 5px 12px;
  font-size: 13px;
  font-weight: 500;
  border-radius: 6px;
  color: var(--color-text-secondary);
  transition: all var(--duration-fast) var(--ease-ios);
}

.segmented-control-item[data-active="true"] {
  background-color: var(--color-surface);
  color: var(--color-text-primary);
  box-shadow: var(--shadow-xs);
}

/* Input field styling */
.input-field {
  height: 40px;
  padding: 0 14px;
  font-size: 16px;
  background-color: var(--color-fill-tertiary);
  border-radius: var(--radius-lg);
  border: none;
  color: var(--color-text-primary);
  transition: box-shadow var(--duration-fast) var(--ease-ios);
}

.input-field::placeholder {
  color: var(--color-text-tertiary);
}

.input-field:focus {
  outline: none;
  box-shadow: 0 0 0 3px var(--color-accent-soft);
}

/* Pill tag style - for topics, categories */
.pill-tag {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  height: 30px;
  padding: 0 14px;
  border-radius: var(--radius-full);
  font-size: 13px;
  font-weight: 500;
  letter-spacing: -0.01em;
  background-color: var(--color-surface);
  color: var(--color-text-secondary);
  box-shadow: 0 0.5px 1px rgba(0, 0, 0, 0.04), 0 0 0 0.5px rgba(0, 0, 0, 0.02);
  transition: all var(--duration-fast) var(--ease-out);
}

/* Note: list-row-interactive, section-title, card-grouped, topic-pill,
   list-row-inset, card-interactive replaced by ListRow, SectionLabel,
   Card, Badge components */

/* Page header subtitle */
.page-subtitle {
  font-size: 15px;
  font-weight: 400;
  line-height: 1.5;
  letter-spacing: -0.2px;
  color: var(--color-text-secondary);
  margin-top: -2px;
}

/* Refined bullet point */
.bullet-dot {
  width: 6px;
  height: 6px;
  border-radius: 50%;
  flex-shrink: 0;
}

/* Source meta text */
.meta-text {
  font-size: 13px;
  letter-spacing: -0.1px;
  color: var(--color-text-tertiary);
}

/* Footer text */
.footer-text {
  font-size: 12px;
  letter-spacing: -0.1px;
  color: var(--color-text-quaternary);
  line-height: 1.5;
}

/* Subtle focus ring */
.focus-ring:focus-visible {
  outline: none;
  box-shadow: 0 0 0 3px var(--color-accent-soft), 0 0 0 1px var(--color-accent);
}

/* iOS-style active state for list items */
.list-active {
  transition: background-color var(--duration-instant) var(--ease-out);
}

.list-active:active {
  background-color: var(--color-fill-quaternary);
}

/* Content visibility optimization */
.content-visibility-auto {
  content-visibility: auto;
  contain-intrinsic-size: auto 200px;
}

/* Improved text rendering for headlines */
.headline-text {
  text-rendering: optimizeLegibility;
  font-feature-settings: "kern" 1, "liga" 1;
  word-spacing: -0.02em;
}

/* Accent gradient for branded elements */
.accent-gradient {
  background: linear-gradient(135deg, var(--color-accent) 0%, #5856D6 100%);
}

/* Subtle inner shadow for inputs */
.input-inset {
  box-shadow: inset 0 1px 2px rgba(0, 0, 0, 0.03);
}

/* Enhanced loading spinner */
@keyframes spin-smooth {
  0% {
    transform: rotate(0deg);
  }
  100% {
    transform: rotate(360deg);
  }
}

.spinner {
  animation: spin-smooth 0.8s linear infinite;
}

/* ===== Layout & Utility Patterns ===== */

/* Section container with consistent vertical rhythm */
.section-container {
  margin-bottom: var(--spacing-8);
}

/* Page description text */
.page-description {
  font-size: 15px;
  font-weight: 400;
  line-height: 1.52;
  letter-spacing: -0.2px;
  color: var(--color-text-secondary);
}

/* Stats/meta text */
.stats-text {
  font-size: 13px;
  font-weight: 500;
  letter-spacing: -0.08px;
  color: var(--color-text-tertiary);
}

/* Note: section-heading, card-container, card-row, separator-inset,
   separator-full replaced by SectionLabel, Card, ListRow, Separator components */

/* Accent dot indicator */
.accent-dot {
  width: 7px;
  height: 7px;
  border-radius: 50%;
  background: linear-gradient(135deg, #007AFF 0%, #5856D6 100%);
  flex-shrink: 0;
}

/* Note: pill-tag-refined, section-label-with-icon replaced by Badge, SectionLabel components */

/* Smooth content fade-in */
@keyframes content-fade-in {
  from {
    opacity: 0;
    transform: translateY(8px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

.animate-content-in {
  animation: content-fade-in var(--duration-normal) var(--ease-out);
}

/* Scroll shadow indicators */
.scroll-shadow-top {
  box-shadow: inset 0 12px 8px -8px rgba(0, 0, 0, 0.04);
}

.scroll-shadow-bottom {
  box-shadow: inset 0 -12px 8px -8px rgba(0, 0, 0, 0.04);
}


================================================================================
FILE: src/layouts/MainLayout.tsx
================================================================================
import { Outlet, useLocation, useNavigate } from "react-router-dom"
import { Newspaper, LayoutList, Globe, Bookmark, Settings, ChevronRight, type LucideIcon } from "lucide-react"
import { AppLogo } from "@/components/ui/app-logo"
import {
  Sheet,
  SheetContent,
  SheetHeader,
  SheetTitle,
  SheetTrigger,
} from "@/components/ui/sheet"
import { useState, createContext, useContext } from "react"
import { hapticMedium } from "@/lib/haptics"
import { cn } from "@/lib/utils"
import { TopNav, MenuButton } from "@/components/layout"
import { useLargeTitle } from "@/lib/hooks"

// Context to share large title state with child pages
interface LargeTitleContextValue {
  titleRef: React.RefObject<HTMLDivElement | null>
  isVisible: boolean
}

const LargeTitleContext = createContext<LargeTitleContextValue | null>(null)

export function useLargeTitleContext() {
  const context = useContext(LargeTitleContext)
  if (!context) {
    throw new Error("useLargeTitleContext must be used within MainLayout")
  }
  return context
}

interface NavItem {
  path: string
  label: string
  icon: LucideIcon
  iconBg: string
  description?: string
}

const primaryNavItems: NavItem[] = [
  { path: "/", label: "Today", icon: Newspaper, iconBg: "#007AFF", description: "Daily brief" },
  { path: "/feed", label: "Feed", icon: LayoutList, iconBg: "#FF9500", description: "All articles" },
  { path: "/sources", label: "Sources", icon: Globe, iconBg: "#32ADE6", description: "News sources" },
  { path: "/bookmarks", label: "Bookmarks", icon: Bookmark, iconBg: "#FF2D55", description: "Saved articles" },
]

const secondaryNavItems: NavItem[] = [
  { path: "/settings", label: "Settings", icon: Settings, iconBg: "#8E8E93", description: "Preferences" },
]

const allNavItems = [...primaryNavItems, ...secondaryNavItems]

function getPageTitle(pathname: string): string {
  const item = allNavItems.find((nav) => nav.path === pathname)
  return item?.label ?? "Today"
}

export function MainLayout() {
  const location = useLocation()
  const navigate = useNavigate()
  const [open, setOpen] = useState(false)
  const { titleRef, isVisible } = useLargeTitle()

  const handleNavigation = (path: string) => {
    navigate(path)
    setOpen(false)
  }

  const pageTitle = getPageTitle(location.pathname)

  // Menu trigger element for TopNav (contains full Sheet with trigger + content)
  const menuTrigger = (
    <Sheet open={open} onOpenChange={setOpen}>
      <SheetTrigger asChild>
        <MenuButton />
      </SheetTrigger>
      <SheetContent
        side="right"
        className="w-[300px] border-l-0 bg-[var(--color-bg-grouped)] p-0"
      >
        <SheetHeader className="sr-only">
          <SheetTitle>Navigation Menu</SheetTitle>
        </SheetHeader>

        <div className="flex h-full flex-col">
          {/* Header with brand - padding accounts for safe area */}
          <div className="px-[20px] pb-[32px]" style={{ paddingTop: 'calc(24px + var(--safe-area-inset-top))' }}>
            <div className="flex items-center gap-[12px]">
              <AppLogo size={44} glow className="drop-shadow-[0_2px_8px_rgba(53,211,255,0.3)]" />
              <div>
                <span className="block text-[18px] font-bold tracking-[-0.38px] text-[var(--color-text-primary)]">
                  P&C Brief
                </span>
                <span className="block text-[13px] text-[var(--color-text-tertiary)] tracking-[-0.08px] mt-[2px]">
                  Insurance News AI
                </span>
              </div>
            </div>
          </div>

          {/* Primary Navigation */}
          <nav className="flex-1 px-[12px]">
            <p className="mb-[8px] ml-[8px] text-[11px] font-semibold uppercase tracking-[0.5px] text-[var(--color-text-tertiary)]">
              Navigation
            </p>
            <div className="overflow-hidden rounded-[var(--radius-xl)] bg-[var(--color-surface)] shadow-[var(--shadow-card)]">
              {primaryNavItems.map((item, index) => {
                const isActive = location.pathname === item.path
                const Icon = item.icon
                return (
                  <div key={item.path}>
                    <button
                      onClick={() => {
                        hapticMedium()
                        handleNavigation(item.path)
                      }}
                      className={cn(
                        "flex w-full items-center gap-[12px] px-[14px] py-[12px] text-left transition-all duration-[var(--duration-fast)]",
                        isActive
                          ? "bg-[var(--color-accent)]"
                          : "active:bg-[var(--color-fill-quaternary)]"
                      )}
                    >
                      <div
                        className="flex h-[32px] w-[32px] items-center justify-center rounded-[8px]"
                        style={{
                          backgroundColor: isActive ? 'rgba(255,255,255,0.22)' : `${item.iconBg}14`
                        }}
                      >
                        <Icon
                          className="h-[17px] w-[17px]"
                          style={{ color: isActive ? 'white' : item.iconBg }}
                          strokeWidth={1.8}
                        />
                      </div>
                      <div className="flex-1 min-w-0">
                        <span
                          className={cn(
                            "block text-[15px] font-semibold tracking-[-0.2px]",
                            isActive ? "text-white" : "text-[var(--color-text-primary)]"
                          )}
                        >
                          {item.label}
                        </span>
                        {item.description && (
                          <span
                            className={cn(
                              "block text-[12px] tracking-[-0.04px] mt-[1px]",
                              isActive ? "text-white/70" : "text-[var(--color-text-tertiary)]"
                            )}
                          >
                            {item.description}
                          </span>
                        )}
                      </div>
                      <ChevronRight
                        className={cn(
                          "h-[16px] w-[16px] shrink-0",
                          isActive ? "text-white/50" : "text-[var(--color-text-quaternary)]"
                        )}
                        strokeWidth={2}
                      />
                    </button>
                    {index < primaryNavItems.length - 1 && !isActive && location.pathname !== primaryNavItems[index + 1]?.path && (
                      <div className="ml-[58px] h-[0.5px] bg-[var(--color-separator)]" />
                    )}
                  </div>
                )
              })}
            </div>

            {/* Secondary Navigation */}
            <div className="mt-[16px] overflow-hidden rounded-[var(--radius-xl)] bg-[var(--color-surface)] shadow-[var(--shadow-card)]">
              {secondaryNavItems.map((item) => {
                const isActive = location.pathname === item.path
                const Icon = item.icon
                return (
                  <button
                    key={item.path}
                    onClick={() => {
                      hapticMedium()
                      handleNavigation(item.path)
                    }}
                    className={cn(
                      "flex w-full items-center gap-[12px] px-[14px] py-[12px] text-left transition-all duration-[var(--duration-fast)]",
                      isActive
                        ? "bg-[var(--color-accent)]"
                        : "active:bg-[var(--color-fill-quaternary)]"
                    )}
                  >
                    <div
                      className={cn(
                        "flex h-[32px] w-[32px] items-center justify-center rounded-[8px]",
                        isActive
                          ? "bg-white/22"
                          : "bg-[var(--color-fill-tertiary)]"
                      )}
                    >
                      <Icon
                        className={cn(
                          "h-[17px] w-[17px]",
                          isActive ? "text-white" : "text-[var(--color-text-secondary)]"
                        )}
                        strokeWidth={1.8}
                      />
                    </div>
                    <div className="flex-1 min-w-0">
                      <span
                        className={cn(
                          "block text-[15px] font-semibold tracking-[-0.2px]",
                          isActive ? "text-white" : "text-[var(--color-text-primary)]"
                        )}
                      >
                        {item.label}
                      </span>
                      {item.description && (
                        <span
                          className={cn(
                            "block text-[12px] tracking-[-0.04px] mt-[1px]",
                            isActive ? "text-white/70" : "text-[var(--color-text-tertiary)]"
                          )}
                        >
                          {item.description}
                        </span>
                      )}
                    </div>
                    <ChevronRight
                      className={cn(
                        "h-[16px] w-[16px] shrink-0",
                        isActive ? "text-white/50" : "text-[var(--color-text-quaternary)]"
                      )}
                      strokeWidth={2}
                    />
                  </button>
                )
              })}
            </div>
          </nav>

          {/* Footer */}
          <div className="px-[20px] pb-[calc(40px+var(--safe-area-inset-bottom))] pt-[28px] text-center">
            <p className="text-[7px] font-medium uppercase tracking-[0.12em] text-[var(--color-text-quaternary)]">
              Made in Hackensack | v5.16
            </p>
          </div>
        </div>
      </SheetContent>
    </Sheet>
  )

  return (
    <LargeTitleContext.Provider value={{ titleRef, isVisible }}>
      <div className="flex min-h-screen flex-col bg-[var(--color-bg-grouped)]">
        {/* Top Navigation Bar */}
        <TopNav
          title={pageTitle}
          isLargeTitleVisible={isVisible}
          menuTrigger={menuTrigger}
        />

        {/* Main Content */}
        <main className="flex-1">
          <div className="safe-area-padding-x">
            <div className="mx-auto max-w-2xl px-[var(--spacing-4)] pb-[52px] pt-[20px]">
              {/* Large Page Title - iOS style with ref for IntersectionObserver */}
              <div ref={titleRef}>
                <h1 className="mb-[20px] text-[32px] font-bold leading-[1.1] tracking-[-0.4px] text-[var(--color-text-primary)]">
                  {pageTitle}
                </h1>
              </div>
              <Outlet />
            </div>
          </div>
        </main>

        {/* Safe area bottom padding */}
        <div style={{ paddingBottom: 'var(--safe-area-inset-bottom)' }} />
      </div>
    </LargeTitleContext.Provider>
  )
}



================================================================================
FILE: src/lib/auth-context.tsx
================================================================================
/**
 * Firebase Auth Context
 *
 * Provides authentication state throughout the app.
 * Uses anonymous auth by default for user preferences.
 */

import {
  createContext,
  useContext,
  useEffect,
  useState,
  type ReactNode,
} from "react"
import {
  onAuthStateChanged,
  signInAnonymously,
  type User,
} from "firebase/auth"
import { auth } from "@/lib/firebase"

interface AuthContextValue {
  user: User | null
  isLoading: boolean
  isAuthenticated: boolean
}

const AuthContext = createContext<AuthContextValue>({
  user: null,
  isLoading: true,
  isAuthenticated: false,
})

export function AuthProvider({ children }: { children: ReactNode }) {
  const [user, setUser] = useState<User | null>(null)
  const [isLoading, setIsLoading] = useState(true)

  useEffect(() => {
    const unsubscribe = onAuthStateChanged(auth, async (firebaseUser) => {
      if (firebaseUser) {
        setUser(firebaseUser)
        setIsLoading(false)
      } else {
        // Sign in anonymously if no user
        try {
          await signInAnonymously(auth)
          // onAuthStateChanged will fire again with the new user
        } catch (error) {
          console.error("Anonymous auth failed:", error)
          setIsLoading(false)
        }
      }
    })

    return () => unsubscribe()
  }, [])

  return (
    <AuthContext.Provider
      value={{
        user,
        isLoading,
        isAuthenticated: !!user,
      }}
    >
      {children}
    </AuthContext.Provider>
  )
}

export function useAuth() {
  return useContext(AuthContext)
}



================================================================================
FILE: src/lib/cache.ts
================================================================================
/**
 * LocalStorage Cache Utility
 * 
 * Simple TTL-based cache for expensive data like the Today brief.
 * Provides instant fallback while fresh data loads.
 */

interface CacheEntry<T> {
  data: T
  timestamp: number
  ttl: number
}

const CACHE_PREFIX = "pcbrief_cache_"

/**
 * Get cached data if valid (not expired)
 */
export function getCached<T>(key: string): T | null {
  try {
    const raw = localStorage.getItem(CACHE_PREFIX + key)
    if (!raw) return null

    const entry: CacheEntry<T> = JSON.parse(raw)
    const now = Date.now()
    const age = now - entry.timestamp

    // Return data if within TTL
    if (age < entry.ttl) {
      return entry.data
    }

    // Expired - remove and return null
    localStorage.removeItem(CACHE_PREFIX + key)
    return null
  } catch {
    return null
  }
}

/**
 * Set cached data with TTL
 * @param key Cache key
 * @param data Data to cache
 * @param ttlMs Time-to-live in milliseconds (default: 30 minutes)
 */
export function setCache<T>(key: string, data: T, ttlMs: number = 30 * 60 * 1000): void {
  try {
    const entry: CacheEntry<T> = {
      data,
      timestamp: Date.now(),
      ttl: ttlMs,
    }
    localStorage.setItem(CACHE_PREFIX + key, JSON.stringify(entry))
  } catch {
    // Storage may be full or disabled - silently ignore
  }
}

/**
 * Remove cached data
 */
export function removeCache(key: string): void {
  try {
    localStorage.removeItem(CACHE_PREFIX + key)
  } catch {
    // Silently ignore
  }
}

/**
 * Clear all cache entries
 */
export function clearCache(): void {
  try {
    const keys = Object.keys(localStorage).filter((k) => k.startsWith(CACHE_PREFIX))
    keys.forEach((k) => localStorage.removeItem(k))
  } catch {
    // Silently ignore
  }
}



================================================================================
FILE: src/lib/firebase.ts
================================================================================
/**
 * Firebase Client SDK Initialization
 *
 * Initializes the Firebase app and exports Functions, Firestore, and Auth instances.
 * Enables offline persistence for improved performance and reduced reads.
 */

import { initializeApp, getApps, getApp } from "firebase/app"
import { getFunctions, connectFunctionsEmulator } from "firebase/functions"
import {
  initializeFirestore,
  persistentLocalCache,
  persistentMultipleTabManager,
  connectFirestoreEmulator,
  type Firestore,
} from "firebase/firestore"
import { getAuth, connectAuthEmulator } from "firebase/auth"

// Firebase configuration
// These are public keys - safe to expose in client code
const firebaseConfig = {
  apiKey: "AIzaSyC55lowlixG6V8KI-bWV4T-x6MiuNp38-g",
  projectId: "insurance-news-ai",
  authDomain: "insurance-news-ai.firebaseapp.com",
  storageBucket: "insurance-news-ai.firebasestorage.app",
  messagingSenderId: "695640024145",
  appId: "1:695640024145:web:ab17c496e14b3d915ac470",
}

// Initialize Firebase (singleton pattern)
const app = getApps().length === 0 ? initializeApp(firebaseConfig) : getApp()

// Get Functions instance
const functions = getFunctions(app, "us-central1")

// Initialize Firestore with offline persistence
// Uses IndexedDB for caching and supports multiple tabs
let db: Firestore
try {
  db = initializeFirestore(app, {
    localCache: persistentLocalCache({
      tabManager: persistentMultipleTabManager(),
    }),
  })
} catch {
  // Firestore may already be initialized (hot reload), use existing instance
  const { getFirestore } = await import("firebase/firestore")
  db = getFirestore(app)
}

// Get Auth instance
const auth = getAuth(app)

// Connect to emulators in development
if (import.meta.env.DEV && import.meta.env.VITE_FIREBASE_USE_EMULATOR === "true") {
  connectFunctionsEmulator(functions, "localhost", 5001)
  connectFirestoreEmulator(db, "localhost", 8080)
  connectAuthEmulator(auth, "http://localhost:9099")
}

export { app, functions, db, auth }



================================================================================
FILE: src/lib/haptics.ts
================================================================================
/**
 * iOS Haptic Feedback Utility
 * 
 * Provides haptic feedback on iOS devices. Gracefully no-ops on web.
 */

import { Capacitor } from "@capacitor/core"
import { Haptics, ImpactStyle, NotificationType } from "@capacitor/haptics"

const isNative = Capacitor.isNativePlatform()

/**
 * Light impact - for subtle UI feedback (toggles, selections)
 */
export async function hapticLight(): Promise<void> {
  if (!isNative) return
  try {
    await Haptics.impact({ style: ImpactStyle.Light })
  } catch {
    // Silently ignore errors
  }
}

/**
 * Medium impact - for button presses, card taps
 */
export async function hapticMedium(): Promise<void> {
  if (!isNative) return
  try {
    await Haptics.impact({ style: ImpactStyle.Medium })
  } catch {
    // Silently ignore errors
  }
}

/**
 * Heavy impact - for significant actions
 */
export async function hapticHeavy(): Promise<void> {
  if (!isNative) return
  try {
    await Haptics.impact({ style: ImpactStyle.Heavy })
  } catch {
    // Silently ignore errors
  }
}

/**
 * Selection changed - for picker/segment changes
 */
export async function hapticSelection(): Promise<void> {
  if (!isNative) return
  try {
    await Haptics.selectionChanged()
  } catch {
    // Silently ignore errors
  }
}

/**
 * Success notification - for successful actions
 */
export async function hapticSuccess(): Promise<void> {
  if (!isNative) return
  try {
    await Haptics.notification({ type: NotificationType.Success })
  } catch {
    // Silently ignore errors
  }
}

/**
 * Warning notification - for warnings
 */
export async function hapticWarning(): Promise<void> {
  if (!isNative) return
  try {
    await Haptics.notification({ type: NotificationType.Warning })
  } catch {
    // Silently ignore errors
  }
}

/**
 * Error notification - for errors
 */
export async function hapticError(): Promise<void> {
  if (!isNative) return
  try {
    await Haptics.notification({ type: NotificationType.Error })
  } catch {
    // Silently ignore errors
  }
}



================================================================================
FILE: src/lib/hooks/index.ts
================================================================================
/**
 * Custom hooks for P&C Insurance News AI
 */

export { useTodayBrief, type TodayBriefResponse, type TopStoryWithArticle } from "./use-today-brief"
export { useArticles, useSources, useAllSources, type ArticleFilters } from "./use-articles"
export {
  useBookmarks,
  useIsBookmarked,
  useToggleBookmark,
  useArticleAI,
  useCachedArticleAI,
} from "./use-bookmarks"
export {
  useUserPreferences,
  useToggleSource,
  useResetSourcePreferences,
  useToggleNotifications,
} from "./use-user-preferences"
export { usePushNotifications } from "./use-push-notifications"
export { useLargeTitle, useLargeTitleWithScroll } from "./use-large-title"



================================================================================
FILE: src/lib/hooks/use-articles.ts
================================================================================
/**
 * Hook for fetching articles with infinite scroll, filters, and search
 */

import { useInfiniteQuery, useQuery } from "@tanstack/react-query"
import {
  collection,
  query,
  orderBy,
  limit,
  startAfter,
  where,
  getDocs,
  Timestamp,
  QueryDocumentSnapshot,
  type DocumentData,
} from "firebase/firestore"
import { db } from "@/lib/firebase"
import type { Article, SourceCategory } from "@/types/firestore"

const ARTICLES_PER_PAGE = 20

export interface ArticleFilters {
  category?: SourceCategory | "all"
  sourceIds?: string[]
  timeWindow?: "24h" | "7d" | "all"
  searchQuery?: string
}

// Convert Firestore doc to Article
function docToArticle(doc: QueryDocumentSnapshot<DocumentData>): Article {
  const data = doc.data()
  return {
    id: doc.id,
    sourceId: data.sourceId,
    sourceName: data.sourceName,
    title: data.title,
    snippet: data.snippet,
    url: data.url,
    canonicalUrl: data.canonicalUrl,
    guid: data.guid,
    imageUrl: data.imageUrl,
    categories: data.categories,
    publishedAt: data.publishedAt,
    ingestedAt: data.ingestedAt,
    relevanceScore: data.relevanceScore,
    isRelevant: data.isRelevant,
    ai: data.ai,
  } as Article
}

// Get time threshold for filtering
function getTimeThreshold(timeWindow: "24h" | "7d" | "all"): Date | null {
  if (timeWindow === "all") return null
  const now = new Date()
  if (timeWindow === "24h") {
    return new Date(now.getTime() - 24 * 60 * 60 * 1000)
  }
  return new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000)
}

interface FetchArticlesParams {
  filters: ArticleFilters
  pageParam?: QueryDocumentSnapshot<DocumentData> | null
}

async function fetchArticles({ filters, pageParam }: FetchArticlesParams) {
  const articlesRef = collection(db, "articles")
  const constraints: Parameters<typeof query>[1][] = []

  // Time window filter
  const timeThreshold = getTimeThreshold(filters.timeWindow ?? "all")
  if (timeThreshold) {
    constraints.push(where("publishedAt", ">=", Timestamp.fromDate(timeThreshold)))
  }

  // Category filter (only if not "all")
  if (filters.category && filters.category !== "all") {
    constraints.push(where("categories", "array-contains", filters.category))
  }

  // Source filter
  if (filters.sourceIds && filters.sourceIds.length > 0 && filters.sourceIds.length <= 10) {
    constraints.push(where("sourceId", "in", filters.sourceIds))
  }

  // Order by publishedAt desc
  constraints.push(orderBy("publishedAt", "desc"))

  // Pagination
  if (pageParam) {
    constraints.push(startAfter(pageParam))
  }

  // Limit
  constraints.push(limit(ARTICLES_PER_PAGE))

  const q = query(articlesRef, ...constraints)
  const snapshot = await getDocs(q)

  const articles = snapshot.docs.map(docToArticle)
  const lastDoc = snapshot.docs[snapshot.docs.length - 1] || null

  return {
    articles,
    lastDoc,
    hasMore: snapshot.docs.length === ARTICLES_PER_PAGE,
  }
}

/**
 * Hook for infinite scroll articles list
 */
export function useArticles(filters: ArticleFilters = {}) {
  return useInfiniteQuery({
    queryKey: ["articles", filters],
    queryFn: ({ pageParam }) => fetchArticles({ filters, pageParam }),
    initialPageParam: null as QueryDocumentSnapshot<DocumentData> | null,
    getNextPageParam: (lastPage) => (lastPage.hasMore ? lastPage.lastDoc : undefined),
    staleTime: 1000 * 60 * 2, // 2 minutes
    gcTime: 1000 * 60 * 10, // 10 minutes
  })
}

// Maximum sources to fetch (prevents runaway reads if sources grow)
const MAX_SOURCES = 50

/**
 * Hook for fetching available sources for filter (lightweight)
 */
export function useSources() {
  return useQuery({
    queryKey: ["sources"],
    queryFn: async () => {
      const sourcesRef = collection(db, "sources")
      const q = query(sourcesRef, where("enabled", "==", true), orderBy("name"), limit(MAX_SOURCES))
      const snapshot = await getDocs(q)
      return snapshot.docs.map((doc) => ({
        id: doc.id,
        name: doc.data().name as string,
      }))
    },
    staleTime: 1000 * 60 * 30, // 30 minutes
  })
}

/**
 * Hook for fetching all enabled sources with full data (for Sources page)
 */
export function useAllSources() {
  return useQuery({
    queryKey: ["sources", "full"],
    queryFn: async () => {
      const sourcesRef = collection(db, "sources")
      const q = query(sourcesRef, where("enabled", "==", true), orderBy("name"), limit(MAX_SOURCES))
      const snapshot = await getDocs(q)
      return snapshot.docs.map((doc) => {
        const data = doc.data()
        return {
          id: doc.id,
          name: data.name,
          siteUrl: data.siteUrl,
          rssUrl: data.rssUrl,
          enabled: data.enabled,
          tier: data.tier,
          tags: data.tags || [],
          createdAt: data.createdAt,
          updatedAt: data.updatedAt,
          fetchState: data.fetchState,
        } as import("@/types/firestore").Source
      })
    },
    staleTime: 1000 * 60 * 30, // 30 minutes
  })
}



================================================================================
FILE: src/lib/hooks/use-bookmarks.ts
================================================================================
/**
 * Hooks for bookmark management
 */

import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query"
import {
  collection,
  doc,
  getDocs,
  getDoc,
  setDoc,
  deleteDoc,
  orderBy,
  query,
  limit,
  Timestamp,
} from "firebase/firestore"
import { httpsCallable } from "firebase/functions"
import { db, functions } from "@/lib/firebase"
import { useAuth } from "@/lib/auth-context"
import type { Bookmark, Article, ArticleAI } from "@/types/firestore"

// Maximum bookmarks to fetch (most users won't have more than this)
const MAX_BOOKMARKS = 100

// ============================================================================
// Bookmarks Hooks
// ============================================================================

/**
 * Fetch bookmarks for the current user (limited to prevent excessive reads)
 */
export function useBookmarks() {
  const { user, isLoading: authLoading } = useAuth()

  return useQuery({
    queryKey: ["bookmarks", user?.uid],
    queryFn: async () => {
      if (!user) return []

      const bookmarksRef = collection(db, "users", user.uid, "bookmarks")
      const q = query(bookmarksRef, orderBy("bookmarkedAt", "desc"), limit(MAX_BOOKMARKS))
      const snapshot = await getDocs(q)

      return snapshot.docs.map((doc) => ({
        ...doc.data(),
        articleId: doc.id,
      })) as Bookmark[]
    },
    enabled: !authLoading && !!user,
    staleTime: 1000 * 60 * 5, // 5 minutes
  })
}

/**
 * Check if a specific article is bookmarked
 */
export function useIsBookmarked(articleId: string | undefined) {
  const { user, isLoading: authLoading } = useAuth()

  return useQuery({
    queryKey: ["bookmark", user?.uid, articleId],
    queryFn: async () => {
      if (!user || !articleId) return false
      
      const bookmarkRef = doc(db, "users", user.uid, "bookmarks", articleId)
      const snapshot = await getDoc(bookmarkRef)
      return snapshot.exists()
    },
    enabled: !authLoading && !!user && !!articleId,
    staleTime: 1000 * 60 * 5, // 5 minutes
  })
}

interface ToggleBookmarkParams {
  article: Article
  isCurrentlyBookmarked: boolean
}

/**
 * Toggle bookmark status for an article
 */
export function useToggleBookmark() {
  const { user } = useAuth()
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: async ({ article, isCurrentlyBookmarked }: ToggleBookmarkParams) => {
      if (!user) throw new Error("Must be authenticated to bookmark")
      
      const bookmarkRef = doc(db, "users", user.uid, "bookmarks", article.id)
      
      if (isCurrentlyBookmarked) {
        // Remove bookmark
        await deleteDoc(bookmarkRef)
        return { bookmarked: false }
      } else {
        // Add bookmark
        const bookmark: Bookmark = {
          articleId: article.id,
          title: article.title,
          sourceName: article.sourceName,
          url: article.url,
          bookmarkedAt: Timestamp.now(),
        }
        await setDoc(bookmarkRef, bookmark)
        return { bookmarked: true }
      }
    },
    onSuccess: (_, { article }) => {
      // Invalidate bookmark queries
      queryClient.invalidateQueries({ queryKey: ["bookmarks", user?.uid] })
      queryClient.invalidateQueries({ queryKey: ["bookmark", user?.uid, article.id] })
    },
  })
}

// ============================================================================
// Article AI Hook
// ============================================================================

interface ArticleAIResponse {
  cached: boolean
  ai: ArticleAI & { generatedAt: string }
  remaining: number
}

/**
 * Generate or retrieve AI summary for an article
 */
export function useArticleAI() {
  const { user } = useAuth()
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: async (articleId: string): Promise<ArticleAIResponse> => {
      if (!user) throw new Error("Must be authenticated to generate AI summary")
      
      const getOrCreateArticleAI = httpsCallable<{ articleId: string }, ArticleAIResponse>(
        functions,
        "getOrCreateArticleAI"
      )
      
      const result = await getOrCreateArticleAI({ articleId })
      return result.data
    },
    onSuccess: (data, articleId) => {
      // Update article cache with AI data
      queryClient.invalidateQueries({ queryKey: ["articles"] })
      // Cache the AI response
      queryClient.setQueryData(["articleAI", articleId], data)
    },
  })
}

/**
 * Get cached AI data for an article
 */
export function useCachedArticleAI(articleId: string | undefined) {
  return useQuery<ArticleAIResponse | null>({
    queryKey: ["articleAI", articleId],
    queryFn: () => null, // Only used for cached data
    enabled: false,
    staleTime: Infinity,
  })
}



================================================================================
FILE: src/lib/hooks/use-large-title.ts
================================================================================
/**
 * useLargeTitle - Hook for iOS-style large title collapse behavior
 * 
 * Uses IntersectionObserver to track when the large title element
 * scrolls out of view, enabling the collapsed title in TopNav.
 */

import { useRef, useState, useEffect, type RefObject } from "react"

interface UseLargeTitleResult {
  /** Ref to attach to the large title container element */
  titleRef: RefObject<HTMLDivElement | null>
  /** Whether the large title is currently visible */
  isVisible: boolean
}

/**
 * Track large title visibility for iOS-style collapse behavior
 * 
 * @param threshold - Visibility threshold (0-1). Default 0.1 means title is considered
 *                    "not visible" when less than 10% is showing
 * @returns titleRef to attach to large title element, and isVisible state
 */
export function useLargeTitle(threshold = 0.1): UseLargeTitleResult {
  const titleRef = useRef<HTMLDivElement>(null)
  const [isVisible, setIsVisible] = useState(true)

  useEffect(() => {
    const element = titleRef.current
    if (!element) return

    const observer = new IntersectionObserver(
      (entries) => {
        // The title is considered visible if it's intersecting above threshold
        const entry = entries[0]
        if (entry) {
          setIsVisible(entry.isIntersecting)
        }
      },
      {
        // Use the viewport as root
        root: null,
        // Account for sticky header height (52px) + safe area
        // We observe when the title hits the bottom of the header
        rootMargin: "-52px 0px 0px 0px",
        threshold,
      }
    )

    observer.observe(element)

    return () => {
      observer.disconnect()
    }
  }, [threshold])

  return {
    titleRef,
    isVisible,
  }
}

/**
 * Scrollable container variant of useLargeTitle
 * Use when the scrollable element is not the viewport
 */
export function useLargeTitleWithScroll(
  scrollContainerRef: RefObject<HTMLElement | null>,
  threshold = 0.1
): UseLargeTitleResult {
  const titleRef = useRef<HTMLDivElement>(null)
  const [isVisible, setIsVisible] = useState(true)

  useEffect(() => {
    const element = titleRef.current
    const scrollContainer = scrollContainerRef.current
    if (!element || !scrollContainer) return

    const observer = new IntersectionObserver(
      (entries) => {
        const entry = entries[0]
        if (entry) {
          setIsVisible(entry.isIntersecting)
        }
      },
      {
        root: scrollContainer,
        rootMargin: "-52px 0px 0px 0px",
        threshold,
      }
    )

    observer.observe(element)

    return () => {
      observer.disconnect()
    }
  }, [scrollContainerRef, threshold])

  return {
    titleRef,
    isVisible,
  }
}



================================================================================
FILE: src/lib/hooks/use-push-notifications.ts
================================================================================
/**
 * Hook for managing push notifications
 */

import { useState, useEffect, useCallback } from "react"
import { useAuth } from "@/lib/auth-context"
import { useUserPreferences } from "@/lib/hooks/use-user-preferences"
import {
  isPushSupported,
  registerPushToken,
  unregisterPush,
} from "@/lib/push-notifications"

interface UsePushNotificationsResult {
  /** Whether push is supported on this platform */
  isSupported: boolean
  /** Whether we're loading the support check */
  isLoading: boolean
  /** Current permission status */
  permissionStatus: NotificationPermission | "unknown"
  /** Whether notifications are enabled in user preferences */
  isEnabled: boolean
  /** Register for push notifications */
  enableNotifications: () => Promise<boolean>
  /** Current push token (if registered) */
  pushToken: string | null
}

export function usePushNotifications(): UsePushNotificationsResult {
  const { user } = useAuth()
  const { data: prefs } = useUserPreferences()

  const [isSupported, setIsSupported] = useState(false)
  const [isLoading, setIsLoading] = useState(true)
  const [permissionStatus, setPermissionStatus] = useState<NotificationPermission | "unknown">("unknown")
  const [pushToken, setPushToken] = useState<string | null>(null)

  // Check support on mount
  useEffect(() => {
    async function checkSupport() {
      const supported = await isPushSupported()
      setIsSupported(supported)
      setIsLoading(false)

      // Check current permission status
      if (supported && "Notification" in window) {
        setPermissionStatus(Notification.permission)
      }
    }
    checkSupport()
  }, [])

  // Auto-register if user has notifications enabled
  useEffect(() => {
    async function autoRegister() {
      if (
        user &&
        isSupported &&
        prefs?.notifications?.dailyBrief &&
        permissionStatus === "granted" &&
        !pushToken
      ) {
        const token = await registerPushToken(user.uid)
        if (token) {
          setPushToken(token)
        }
      }
    }
    autoRegister()
  }, [user, isSupported, prefs?.notifications?.dailyBrief, permissionStatus, pushToken])

  const enableNotifications = useCallback(async (): Promise<boolean> => {
    if (!user || !isSupported) return false

    const token = await registerPushToken(user.uid)
    if (token) {
      setPushToken(token)
      setPermissionStatus("granted")
      return true
    }
    setPermissionStatus("denied")
    return false
  }, [user, isSupported])

  // Cleanup on unmount
  useEffect(() => {
    return () => {
      unregisterPush()
    }
  }, [])

  return {
    isSupported,
    isLoading,
    permissionStatus,
    isEnabled: prefs?.notifications?.dailyBrief ?? true,
    enableNotifications,
    pushToken,
  }
}



================================================================================
FILE: src/lib/hooks/use-today-brief.ts
================================================================================
/**
 * Hook for fetching today's brief from Cloud Functions
 *
 * Features:
 * - localStorage caching with 30min TTL for instant display
 * - Falls back to cache while fresh data loads
 */

import { useQuery } from "@tanstack/react-query"
import { httpsCallable } from "firebase/functions"
import { functions } from "@/lib/firebase"
import { getCached, setCache } from "@/lib/cache"
import type { Brief } from "@/types/firestore"

// Response type from getTodayBrief callable
export interface TopStoryWithArticle {
  articleId: string
  headline: string
  whyItMatters: string
  article: {
    id: string
    title: string
    url: string
    sourceName: string
    publishedAt: string
    snippet: string
    imageUrl: string | null
  }
}

export interface TodayBriefResponse {
  found: boolean
  date: string
  brief: Brief | null
  topStoriesWithArticles: TopStoryWithArticle[]
}

// Cache key for today's brief
const BRIEF_CACHE_KEY = "today_brief"
const BRIEF_CACHE_TTL = 30 * 60 * 1000 // 30 minutes

// Callable function reference
const getTodayBriefCallable = httpsCallable<{ date?: string }, TodayBriefResponse>(
  functions,
  "getTodayBrief"
)

/**
 * Fetch today's brief (or a specific date's brief)
 * Updates localStorage cache on success
 */
async function fetchTodayBrief(date?: string): Promise<TodayBriefResponse> {
  const result = await getTodayBriefCallable({ date })
  const data = result.data

  // Cache the response (only for "today" queries)
  if (!date && data.found) {
    setCache(BRIEF_CACHE_KEY, data, BRIEF_CACHE_TTL)
  }

  return data
}

/**
 * Hook to fetch today's brief with TanStack Query
 *
 * Uses localStorage cache for instant initial display, then fetches fresh data.
 *
 * @param date - Optional date in yyyy-mm-dd format (defaults to today ET)
 */
export function useTodayBrief(date?: string) {
  // Get cached data for initial display (only for "today")
  const cachedData = !date ? getCached<TodayBriefResponse>(BRIEF_CACHE_KEY) : null

  return useQuery({
    queryKey: ["brief", date ?? "today"],
    queryFn: () => fetchTodayBrief(date),
    staleTime: 1000 * 60 * 5, // 5 minutes
    gcTime: 1000 * 60 * 30, // 30 minutes
    // Use cached data as placeholder while fetching
    placeholderData: cachedData ?? undefined,
  })
}



================================================================================
FILE: src/lib/hooks/use-user-preferences.ts
================================================================================
/**
 * Hook for managing user preferences (source toggles, etc.)
 */

import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query"
import {
  doc,
  getDoc,
  setDoc,
  updateDoc,
  serverTimestamp,
} from "firebase/firestore"
import { db } from "@/lib/firebase"
import { useAuth } from "@/lib/auth-context"
import type { UserPreferences } from "@/types/firestore"

// Default preferences for new users
const DEFAULT_PREFERENCES: Omit<UserPreferences, "updatedAt"> = {
  enabledSourceIds: [], // Empty means "all sources"
  enabledCategories: [
    "property_cat",
    "casualty_liability",
    "regulation",
    "claims",
    "reinsurance",
    "insurtech",
  ],
  notifications: {
    dailyBrief: true,
    breakingNews: false,
  },
}

/**
 * Fetch user preferences from Firestore
 */
async function fetchUserPreferences(uid: string): Promise<UserPreferences | null> {
  const prefsRef = doc(db, "users", uid, "prefs", "main")
  const snapshot = await getDoc(prefsRef)

  if (!snapshot.exists()) {
    return null
  }

  return snapshot.data() as UserPreferences
}

/**
 * Hook to get user preferences
 */
export function useUserPreferences() {
  const { user, isLoading: authLoading } = useAuth()

  return useQuery({
    queryKey: ["userPreferences", user?.uid],
    queryFn: () => fetchUserPreferences(user!.uid),
    enabled: !!user && !authLoading,
    staleTime: 1000 * 60 * 5, // 5 minutes
  })
}

/**
 * Hook to toggle a source in user preferences
 */
export function useToggleSource() {
  const { user } = useAuth()
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: async ({
      sourceId,
      enabled,
      currentEnabledIds,
    }: {
      sourceId: string
      enabled: boolean
      currentEnabledIds: string[]
    }) => {
      if (!user) throw new Error("Not authenticated")

      const prefsRef = doc(db, "users", user.uid, "prefs", "main")
      const prefsDoc = await getDoc(prefsRef)

      let newEnabledIds: string[]

      if (enabled) {
        // Add source to enabled list
        newEnabledIds = [...currentEnabledIds, sourceId]
      } else {
        // Remove source from enabled list
        newEnabledIds = currentEnabledIds.filter((id) => id !== sourceId)
      }

      if (prefsDoc.exists()) {
        // Update existing preferences
        await updateDoc(prefsRef, {
          enabledSourceIds: newEnabledIds,
          updatedAt: serverTimestamp(),
        })
      } else {
        // Create new preferences document
        await setDoc(prefsRef, {
          ...DEFAULT_PREFERENCES,
          enabledSourceIds: newEnabledIds,
          updatedAt: serverTimestamp(),
        })
      }

      return newEnabledIds
    },
    onSuccess: () => {
      // Invalidate preferences query to refetch
      queryClient.invalidateQueries({ queryKey: ["userPreferences", user?.uid] })
    },
  })
}

/**
 * Hook to reset all source preferences (follow all)
 */
export function useResetSourcePreferences() {
  const { user } = useAuth()
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: async () => {
      if (!user) throw new Error("Not authenticated")

      const prefsRef = doc(db, "users", user.uid, "prefs", "main")
      const prefsDoc = await getDoc(prefsRef)

      if (prefsDoc.exists()) {
        await updateDoc(prefsRef, {
          enabledSourceIds: [],
          updatedAt: serverTimestamp(),
        })
      } else {
        await setDoc(prefsRef, {
          ...DEFAULT_PREFERENCES,
          enabledSourceIds: [],
          updatedAt: serverTimestamp(),
        })
      }
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["userPreferences", user?.uid] })
    },
  })
}

/**
 * Hook to toggle notification preferences
 */
export function useToggleNotifications() {
  const { user } = useAuth()
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: async ({
      dailyBrief,
    }: {
      dailyBrief: boolean
    }) => {
      if (!user) throw new Error("Not authenticated")

      const prefsRef = doc(db, "users", user.uid, "prefs", "main")
      const prefsDoc = await getDoc(prefsRef)

      if (prefsDoc.exists()) {
        await updateDoc(prefsRef, {
          "notifications.dailyBrief": dailyBrief,
          updatedAt: serverTimestamp(),
        })
      } else {
        await setDoc(prefsRef, {
          ...DEFAULT_PREFERENCES,
          notifications: {
            ...DEFAULT_PREFERENCES.notifications,
            dailyBrief,
          },
          updatedAt: serverTimestamp(),
        })
      }
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["userPreferences", user?.uid] })
    },
  })
}



================================================================================
FILE: src/lib/push-notifications.ts
================================================================================
/**
 * Push Notifications Service
 *
 * Handles FCM registration for both web (Firebase Messaging) and iOS (Capacitor Push Notifications).
 * Stores device tokens under users/{uid}/pushTokens/{token}
 */

import { Capacitor } from "@capacitor/core"
import { PushNotifications, type Token } from "@capacitor/push-notifications"
import { getMessaging, getToken, onMessage, isSupported } from "firebase/messaging"
import { doc, setDoc, deleteDoc, serverTimestamp, Timestamp } from "firebase/firestore"
import { app, db } from "@/lib/firebase"

// VAPID key for web push (you need to generate this in Firebase Console > Cloud Messaging)
const VAPID_KEY = import.meta.env.VITE_FIREBASE_VAPID_KEY || ""

export interface PushToken {
  token: string
  platform: "ios" | "web"
  createdAt: Timestamp
  updatedAt: Timestamp
}

/**
 * Check if push notifications are supported on the current platform
 */
export async function isPushSupported(): Promise<boolean> {
  if (Capacitor.isNativePlatform()) {
    return true // iOS native always supports push
  }
  // Check web push support
  return await isSupported()
}

/**
 * Request push notification permission
 */
export async function requestPushPermission(): Promise<"granted" | "denied" | "default"> {
  if (Capacitor.isNativePlatform()) {
    const result = await PushNotifications.requestPermissions()
    return result.receive === "granted" ? "granted" : "denied"
  }

  // Web permission
  const permission = await Notification.requestPermission()
  return permission
}

/**
 * Register for push notifications and store the token
 */
export async function registerPushToken(uid: string): Promise<string | null> {
  try {
    const permission = await requestPushPermission()
    if (permission !== "granted") {
      console.log("[Push] Permission not granted")
      return null
    }

    if (Capacitor.isNativePlatform()) {
      return await registerNativePush(uid)
    } else {
      return await registerWebPush(uid)
    }
  } catch (error) {
    console.error("[Push] Failed to register:", error)
    return null
  }
}

/**
 * Register native (iOS) push notifications via Capacitor
 */
async function registerNativePush(uid: string): Promise<string | null> {
  return new Promise((resolve) => {
    // Listen for registration success
    PushNotifications.addListener("registration", async (token: Token) => {
      console.log("[Push] iOS token received:", token.value)
      await storePushToken(uid, token.value, "ios")
      resolve(token.value)
    })

    // Listen for registration errors
    PushNotifications.addListener("registrationError", (error) => {
      console.error("[Push] iOS registration error:", error)
      resolve(null)
    })

    // Register with APNS
    PushNotifications.register()
  })
}

/**
 * Register web push notifications via Firebase Messaging
 */
async function registerWebPush(uid: string): Promise<string | null> {
  try {
    const messaging = getMessaging(app)
    const token = await getToken(messaging, { vapidKey: VAPID_KEY })

    if (token) {
      console.log("[Push] Web token received:", token.substring(0, 20) + "...")
      await storePushToken(uid, token, "web")

      // Listen for foreground messages
      onMessage(messaging, (payload) => {
        console.log("[Push] Foreground message:", payload)
        // Show notification manually for foreground
        if (payload.notification) {
          new Notification(payload.notification.title || "P&C Brief", {
            body: payload.notification.body,
            icon: "/pwa-192x192.png",
          })
        }
      })

      return token
    }
    return null
  } catch (error) {
    console.error("[Push] Web registration error:", error)
    return null
  }
}

/**
 * Store push token in Firestore
 */
async function storePushToken(
  uid: string,
  token: string,
  platform: "ios" | "web"
): Promise<void> {
  const tokenRef = doc(db, "users", uid, "pushTokens", token)
  await setDoc(tokenRef, {
    token,
    platform,
    createdAt: serverTimestamp(),
    updatedAt: serverTimestamp(),
  })
  console.log(`[Push] Token stored for ${platform}`)
}

/**
 * Remove a push token from Firestore
 */
export async function removePushToken(uid: string, token: string): Promise<void> {
  const tokenRef = doc(db, "users", uid, "pushTokens", token)
  await deleteDoc(tokenRef)
  console.log("[Push] Token removed")
}

/**
 * Unregister from push notifications
 */
export async function unregisterPush(): Promise<void> {
  if (Capacitor.isNativePlatform()) {
    await PushNotifications.removeAllListeners()
  }
}



================================================================================
FILE: src/lib/query-client.ts
================================================================================
import { QueryClient } from "@tanstack/react-query"

export const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 1000 * 60 * 5, // 5 minutes
      gcTime: 1000 * 60 * 30, // 30 minutes (formerly cacheTime)
      retry: 1,
      refetchOnWindowFocus: false,
    },
  },
})



================================================================================
FILE: src/lib/utils.ts
================================================================================
import { type ClassValue, clsx } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}



================================================================================
FILE: src/main.tsx
================================================================================
import { StrictMode } from "react"
import { createRoot } from "react-dom/client"
import "./index.css"
import App from "./App"

createRoot(document.getElementById("root")!).render(
  <StrictMode>
    <App />
  </StrictMode>
)


================================================================================
FILE: src/pages/BookmarksPage.tsx
================================================================================
/**
 * Bookmarks Page - Saved articles list
 */

import { useState } from "react"
import { Bookmark as BookmarkIcon, Loader2, ExternalLink } from "lucide-react"
import { toast } from "sonner"
import { doc, getDoc } from "firebase/firestore"
import { useQuery } from "@tanstack/react-query"
import { Button } from "@/components/ui/button"
import {
  Sheet,
  SheetContent,
  SheetHeader,
  SheetTitle,
  SheetDescription,
} from "@/components/ui/sheet"
import { useBookmarks, useToggleBookmark } from "@/lib/hooks"
import { useAuth } from "@/lib/auth-context"
import { db } from "@/lib/firebase"
import { hapticMedium, hapticSuccess, hapticLight } from "@/lib/haptics"
import type { Bookmark, Article } from "@/types/firestore"

function formatDate(date: Date): string {
  return date.toLocaleDateString("en-US", {
    month: "short",
    day: "numeric",
  })
}

function BookmarkRowSkeleton() {
  return (
    <div className="flex min-h-[68px] items-center gap-[12px] px-[16px] py-[12px]">
      <div className="min-w-0 flex-1">
        <div className="mb-[6px] h-[16px] w-4/5 rounded-[4px] skeleton-shimmer" />
        <div className="h-[13px] w-2/5 rounded-[3px] skeleton-shimmer" />
      </div>
      <div className="h-[36px] w-[36px] shrink-0 rounded-full skeleton-shimmer" />
    </div>
  )
}

interface BookmarkRowProps {
  bookmark: Bookmark
  onSelect: (bookmark: Bookmark) => void
  onRemove: (bookmark: Bookmark) => void
  isRemoving: boolean
}

function BookmarkRow({ bookmark, onSelect, onRemove, isRemoving }: BookmarkRowProps) {
  return (
    <div
      role="button"
      tabIndex={0}
      onClick={() => onSelect(bookmark)}
      onKeyDown={(e) => {
        if (e.key === "Enter" || e.key === " ") {
          e.preventDefault()
          onSelect(bookmark)
        }
      }}
      className="flex w-full min-h-[64px] cursor-pointer items-center gap-[12px] px-[16px] py-[12px] text-left transition-colors duration-[var(--duration-instant)] active:bg-[var(--color-fill-quaternary)]"
    >
      <div className="min-w-0 flex-1">
        <h3 className="line-clamp-2 text-[16px] font-medium leading-[1.32] tracking-[-0.24px] text-[var(--color-text-primary)]">
          {bookmark.title}
        </h3>
        <p className="mt-[5px] text-[13px] tracking-[-0.08px] text-[var(--color-text-tertiary)]">
          <span className="font-medium text-[var(--color-text-secondary)]">{bookmark.sourceName}</span>
          <span className="mx-[5px]">·</span>
          <span>{formatDate(bookmark.bookmarkedAt.toDate())}</span>
        </p>
      </div>
      <button
        className="flex h-[36px] w-[36px] shrink-0 items-center justify-center rounded-full transition-all duration-[var(--duration-fast)] hover:bg-[var(--color-fill-tertiary)] active:scale-[0.88] active:bg-[var(--color-fill-secondary)] disabled:opacity-50"
        onClick={(e) => {
          e.stopPropagation()
          hapticLight()
          onRemove(bookmark)
        }}
        disabled={isRemoving}
      >
        {isRemoving ? (
          <Loader2 className="h-[17px] w-[17px] animate-spin text-[var(--color-accent)]" />
        ) : (
          <BookmarkIcon className="h-[17px] w-[17px] fill-[var(--color-accent)] text-[var(--color-accent)]" />
        )}
      </button>
    </div>
  )
}

export function BookmarksPage() {
  const { isLoading: authLoading } = useAuth()
  const { data: bookmarks, isLoading: bookmarksLoading } = useBookmarks()
  const toggleBookmark = useToggleBookmark()

  const [selectedBookmark, setSelectedBookmark] = useState<Bookmark | null>(null)
  const [sheetOpen, setSheetOpen] = useState(false)
  const [removingId, setRemovingId] = useState<string | null>(null)

  // Fetch full article when bookmark is selected
  const { data: selectedArticle } = useQuery({
    queryKey: ["article", selectedBookmark?.articleId],
    queryFn: async () => {
      if (!selectedBookmark) return null
      const articleDoc = await getDoc(doc(db, "articles", selectedBookmark.articleId))
      if (!articleDoc.exists()) return null
      return { id: articleDoc.id, ...articleDoc.data() } as Article
    },
    enabled: !!selectedBookmark,
  })

  const isLoading = authLoading || bookmarksLoading

  const handleSelectBookmark = (bookmark: Bookmark) => {
    hapticMedium()
    setSelectedBookmark(bookmark)
    setSheetOpen(true)
  }

  const handleRemoveBookmark = (bookmark: Bookmark) => {
    if (!selectedArticle && bookmark.articleId !== selectedBookmark?.articleId) {
      // Create a minimal article object for removal
      const minimalArticle: Article = {
        id: bookmark.articleId,
        title: bookmark.title,
        sourceName: bookmark.sourceName,
        url: bookmark.url,
        sourceId: "",
        snippet: "",
        canonicalUrl: bookmark.url,
        guid: null,
        imageUrl: null,
        categories: [],
        publishedAt: bookmark.bookmarkedAt,
        ingestedAt: bookmark.bookmarkedAt,
        relevanceScore: 0,
        isRelevant: true,
        ai: null,
      }

      setRemovingId(bookmark.articleId)
      toggleBookmark.mutate(
        { article: minimalArticle, isCurrentlyBookmarked: true },
        {
          onSuccess: () => {
            hapticSuccess()
            toast.success("Bookmark removed")
            setRemovingId(null)
          },
          onError: () => {
            toast.error("Failed to remove bookmark")
            setRemovingId(null)
          },
        }
      )
      return
    }

    if (selectedArticle) {
      setRemovingId(bookmark.articleId)
      toggleBookmark.mutate(
        { article: selectedArticle, isCurrentlyBookmarked: true },
        {
          onSuccess: () => {
            hapticSuccess()
            toast.success("Bookmark removed")
            setRemovingId(null)
            setSheetOpen(false)
          },
          onError: () => {
            toast.error("Failed to remove bookmark")
            setRemovingId(null)
          },
        }
      )
    }
  }

  const handleOpenArticle = () => {
    if (selectedBookmark) {
      window.open(selectedBookmark.url, "_blank", "noopener,noreferrer")
    }
  }

  return (
    <div className="space-y-[20px]">
      {/* Description */}
      <div className="-mt-[4px]">
        <p className="text-[15px] leading-[1.45] tracking-[-0.16px] text-[var(--color-text-secondary)]">
          Your reading list
        </p>
        {!isLoading && bookmarks && bookmarks.length > 0 && (
          <p className="mt-[8px] text-[13px] tracking-[-0.08px] text-[var(--color-text-tertiary)]">
            {bookmarks.length} article{bookmarks.length !== 1 ? "s" : ""} saved
          </p>
        )}
      </div>

      {/* Loading state */}
      {isLoading && (
        <div className="overflow-hidden rounded-[var(--radius-2xl)] bg-[var(--color-surface)]">
          {Array.from({ length: 4 }).map((_, i) => (
            <div key={i}>
              <BookmarkRowSkeleton />
              {i < 3 && (
                <div className="ml-[16px] h-[0.5px] bg-[var(--color-separator)]" />
              )}
            </div>
          ))}
        </div>
      )}

      {/* Empty state */}
      {!isLoading && (!bookmarks || bookmarks.length === 0) && (
        <div className="flex flex-col items-center justify-center py-[56px] text-center">
          {/* Icon with subtle animation hint */}
          <div className="mb-[18px] flex h-[64px] w-[64px] items-center justify-center rounded-[20px] bg-[var(--color-fill-tertiary)]">
            <BookmarkIcon className="h-[28px] w-[28px] text-[var(--color-text-tertiary)]" strokeWidth={1.5} />
          </div>

          {/* Title */}
          <h3 className="mb-[8px] text-[20px] font-semibold tracking-[-0.4px] text-[var(--color-text-primary)]">
            Save for later
          </h3>

          {/* Description with suggestion */}
          <p className="max-w-[260px] text-[15px] leading-[1.45] tracking-[-0.16px] text-[var(--color-text-tertiary)]">
            Tap the bookmark icon on any article to build your reading list.
          </p>

          {/* Subtle hint */}
          <p className="mt-[16px] text-[13px] tracking-[-0.08px] text-[var(--color-text-quaternary)]">
            Browse the Feed to discover articles
          </p>
        </div>
      )}

      {/* Bookmarks list */}
      {!isLoading && bookmarks && bookmarks.length > 0 && (
        <div className="overflow-hidden rounded-[var(--radius-2xl)] bg-[var(--color-surface)]">
          {bookmarks.map((bookmark, index) => (
            <div key={bookmark.articleId}>
              <BookmarkRow
                bookmark={bookmark}
                onSelect={handleSelectBookmark}
                onRemove={handleRemoveBookmark}
                isRemoving={removingId === bookmark.articleId}
              />
              {index < bookmarks.length - 1 && (
                <div className="ml-[16px] h-[0.5px] bg-[var(--color-separator)]" />
              )}
            </div>
          ))}
        </div>
      )}

      {/* Bookmark detail sheet */}
      <Sheet open={sheetOpen} onOpenChange={setSheetOpen}>
        <SheetContent
          side="bottom"
          hideCloseButton
          className="glass-sheet sheet-scroll h-[85vh] overflow-y-auto px-[20px] pb-[calc(52px+var(--safe-area-inset-bottom))] pt-[8px]"
        >
          {/* Drag indicator */}
          <div className="drag-indicator mb-[18px]" />

          {selectedBookmark && (
            <>
              <SheetHeader className="mb-[24px] text-left">
                <div className="mb-[10px] flex items-center gap-[8px]">
                  <span className="text-[12px] font-semibold uppercase tracking-[0.03em] text-[var(--color-accent)]">
                    {selectedBookmark.sourceName}
                  </span>
                  <span className="text-[12px] text-[var(--color-text-tertiary)]">
                    · Saved {formatDate(selectedBookmark.bookmarkedAt.toDate())}
                  </span>
                </div>
                <SheetTitle className="text-[26px] font-bold leading-[1.18] tracking-[-0.5px] text-[var(--color-text-primary)]">
                  {selectedBookmark.title}
                </SheetTitle>
                <SheetDescription className="sr-only">
                  Saved article from {selectedBookmark.sourceName}
                </SheetDescription>
              </SheetHeader>

              {/* AI Summary if available - cleaner presentation */}
              {selectedArticle?.ai && (
                <div className="mb-[24px] space-y-[16px]">
                  {/* TL;DR */}
                  <div>
                    <h4 className="mb-[6px] text-[11px] font-semibold uppercase tracking-[0.03em] text-[var(--color-text-tertiary)]">
                      TL;DR
                    </h4>
                    <p className="text-[15px] leading-[1.55] tracking-[-0.2px] text-[var(--color-text-primary)]">
                      {selectedArticle.ai.tldr}
                    </p>
                  </div>

                  {/* Why It Matters */}
                  <div>
                    <h4 className="mb-[6px] text-[11px] font-semibold uppercase tracking-[0.03em] text-[var(--color-text-tertiary)]">
                      Why It Matters
                    </h4>
                    <p className="text-[15px] leading-[1.55] tracking-[-0.2px] text-[var(--color-text-primary)]">
                      {selectedArticle.ai.whyItMatters}
                    </p>
                  </div>

                  {/* Topics */}
                  {selectedArticle.ai.topics.length > 0 && (
                    <div className="flex flex-wrap gap-[6px] pt-[4px]">
                      {selectedArticle.ai.topics.map((topic) => (
                        <span
                          key={topic}
                          className="rounded-full bg-[var(--color-fill-tertiary)] px-[12px] py-[6px] text-[12px] font-medium tracking-[-0.05px] text-[var(--color-text-secondary)]"
                        >
                          {topic}
                        </span>
                      ))}
                    </div>
                  )}

                  {/* AI Disclaimer */}
                  <p className="text-[11px] text-[var(--color-text-quaternary)]">
                    Summary generated by AI
                  </p>
                </div>
              )}

              {/* Snippet */}
              {selectedArticle?.snippet && (
                <div className="mb-[28px]">
                  <p className="text-[15px] leading-[1.6] tracking-[-0.2px] text-[var(--color-text-secondary)]">
                    {selectedArticle.snippet}
                  </p>
                </div>
              )}

              {/* Actions - consistent with ArticleDetailSheet */}
              <div className="flex gap-[12px]">
                <Button onClick={handleOpenArticle} className="flex-1 gap-[8px]" size="lg">
                  <span>Read Article</span>
                  <ExternalLink className="h-[17px] w-[17px]" />
                </Button>
                <Button
                  variant="outline"
                  size="lg"
                  onClick={() => handleRemoveBookmark(selectedBookmark)}
                  disabled={removingId === selectedBookmark.articleId}
                  className="h-[50px] w-[50px] shrink-0 p-0"
                >
                  {removingId === selectedBookmark.articleId ? (
                    <Loader2 className="h-5 w-5 animate-spin" />
                  ) : (
                    <BookmarkIcon className="h-5 w-5 fill-current" />
                  )}
                </Button>
              </div>
            </>
          )}
        </SheetContent>
      </Sheet>
    </div>
  )
}



================================================================================
FILE: src/pages/FeedPage.tsx
================================================================================
/**
 * Feed Page - Infinite scroll article list with filters
 */

import { useState, useMemo, useRef, useCallback } from "react"
import { Inbox, Search } from "lucide-react"
import { useArticles, useSources, type ArticleFilters } from "@/lib/hooks"
import {
  CategoryChips,
  TimeWindowToggle,
  SourceFilter,
  SearchBar,
  ArticleCard,
  ArticleCardSkeleton,
  ArticleDetailSheet,
} from "@/components/feed"
import { EmptyState, ErrorState } from "@/components/ui"
import { hapticMedium } from "@/lib/haptics"
import type { Article, SourceCategory } from "@/types/firestore"

export function FeedPage() {
  // Filter state
  const [category, setCategory] = useState<SourceCategory | "all">("all")
  const [timeWindow, setTimeWindow] = useState<"24h" | "7d" | "all">("7d")
  const [selectedSourceIds, setSelectedSourceIds] = useState<string[]>([])
  const [searchQuery, setSearchQuery] = useState("")

  // Article detail sheet state
  const [selectedArticle, setSelectedArticle] = useState<Article | null>(null)
  const [sheetOpen, setSheetOpen] = useState(false)

  // Build filters object
  const filters: ArticleFilters = useMemo(
    () => ({
      category,
      timeWindow,
      sourceIds: selectedSourceIds.length > 0 ? selectedSourceIds : undefined,
    }),
    [category, timeWindow, selectedSourceIds]
  )

  // Fetch articles with infinite scroll
  const {
    data,
    isLoading,
    isFetchingNextPage,
    hasNextPage,
    fetchNextPage,
    error,
  } = useArticles(filters)

  // Fetch sources for filter
  const { data: sources = [] } = useSources()

  // Flatten pages into single array
  const articles = useMemo(() => {
    if (!data?.pages) return []
    return data.pages.flatMap((page) => page.articles)
  }, [data])

  // Client-side search filter
  const filteredArticles = useMemo(() => {
    if (!searchQuery.trim()) return articles
    const query = searchQuery.toLowerCase()
    return articles.filter(
      (article) =>
        article.title.toLowerCase().includes(query) ||
        article.snippet.toLowerCase().includes(query) ||
        article.sourceName.toLowerCase().includes(query)
    )
  }, [articles, searchQuery])

  // Infinite scroll observer - triggers 200px before element comes into view
  const observerRef = useRef<IntersectionObserver | null>(null)
  const loadMoreRef = useCallback(
    (node: HTMLDivElement | null) => {
      if (isFetchingNextPage) return
      if (observerRef.current) observerRef.current.disconnect()

      observerRef.current = new IntersectionObserver(
        (entries) => {
          if (entries[0].isIntersecting && hasNextPage) {
            fetchNextPage()
          }
        },
        { rootMargin: '200px' }
      )

      if (node) observerRef.current.observe(node)
    },
    [isFetchingNextPage, hasNextPage, fetchNextPage]
  )

  const handleSelectArticle = (article: Article) => {
    hapticMedium()
    setSelectedArticle(article)
    setSheetOpen(true)
  }

  return (
    <>
      <div className="-mx-[var(--spacing-4)] -mt-[6px]">
        {/* Sticky filters header - positioned below TopNav (52px + safe-area-inset-top) */}
        <div
          className="glass-nav sticky z-30 border-b border-[var(--color-separator)] px-[var(--spacing-4)] pb-[10px] pt-[8px]"
          style={{ top: 'calc(52px + var(--safe-area-inset-top))' }}
        >
          {/* Search */}
          <div className="mb-[10px]">
            <SearchBar value={searchQuery} onChange={setSearchQuery} />
          </div>

          {/* Category pills - scrollable */}
          <CategoryChips value={category} onChange={setCategory} />

          {/* Time + Sources row - compact inline controls */}
          <div className="mt-[10px] flex items-center gap-[16px]">
            <TimeWindowToggle value={timeWindow} onChange={setTimeWindow} />
            <div className="h-[14px] w-[1px] bg-[var(--color-separator)]" />
            <SourceFilter
              sources={sources}
              selectedIds={selectedSourceIds}
              onChange={setSelectedSourceIds}
            />
          </div>
        </div>

        {/* Articles list */}
        <div className="min-h-[50vh] px-[var(--spacing-4)] py-[16px]">
          {/* Loading state */}
          {isLoading && (
            <div className="space-y-[12px]">
              {Array.from({ length: 5 }).map((_, i) => (
                <ArticleCardSkeleton key={i} />
              ))}
            </div>
          )}

          {/* Error state */}
          {error && !filteredArticles.length && (
            <div className="flex min-h-[40vh] items-center justify-center">
              <ErrorState
                title="Unable to load articles"
                description="We couldn't fetch the latest news. Please try again."
                onRetry={() => window.location.reload()}
              />
            </div>
          )}

          {/* Empty state */}
          {!isLoading && !error && filteredArticles.length === 0 && (
            <div className="flex min-h-[40vh] items-center justify-center">
              <EmptyState
                icon={searchQuery ? Search : Inbox}
                title={searchQuery ? "No results" : "No articles"}
                description={
                  searchQuery
                    ? "Try a different search term."
                    : "Adjust filters or check back later."
                }
              />
            </div>
          )}

          {/* Article cards - tighter spacing */}
          {!isLoading && filteredArticles.length > 0 && (
            <div className="space-y-[12px]">
              {filteredArticles.map((article) => (
                <ArticleCard
                  key={article.id}
                  article={article}
                  onSelect={handleSelectArticle}
                />
              ))}
            </div>
          )}

          {/* Load more trigger - positioned well ahead */}
          {hasNextPage && !searchQuery && (
            <div ref={loadMoreRef} className="py-[32px]">
              {isFetchingNextPage && (
                <div className="flex justify-center">
                  <div className="h-[18px] w-[18px] rounded-full border-[2px] border-[var(--color-accent)] border-t-transparent spinner" />
                </div>
              )}
            </div>
          )}

          {/* End of list */}
          {!hasNextPage && filteredArticles.length > 0 && !searchQuery && (
            <p className="py-[40px] text-center text-[13px] text-[var(--color-text-quaternary)]">
              You're all caught up
            </p>
          )}
        </div>
      </div>

      {/* Article detail sheet */}
      <ArticleDetailSheet
        article={selectedArticle}
        open={sheetOpen}
        onOpenChange={setSheetOpen}
      />
    </>
  )
}



================================================================================
FILE: src/pages/index.ts
================================================================================
export { TodayPage } from "./TodayPage"
export { FeedPage } from "./FeedPage"
export { SourcesPage } from "./SourcesPage"
export { BookmarksPage } from "./BookmarksPage"
export { SettingsPage } from "./SettingsPage"



================================================================================
FILE: src/pages/SettingsPage.tsx
================================================================================
import { Switch } from "@/components/ui/switch"
import { ChevronRight, Bell, Tag, TextCursor, Info, FileText, Shield } from "lucide-react"
import {
  useUserPreferences,
  useToggleNotifications,
  usePushNotifications,
} from "@/lib/hooks"
import { hapticLight, hapticSuccess } from "@/lib/haptics"

// iOS-style section header
function SectionHeader({ children }: { children: React.ReactNode }) {
  return (
    <h2 className="mb-[6px] pl-[16px] text-[13px] font-normal uppercase tracking-[0.02em] text-[var(--color-text-tertiary)]">
      {children}
    </h2>
  )
}

// iOS-style section footer
function SectionFooter({ children }: { children: React.ReactNode }) {
  return (
    <p className="mt-[6px] px-[16px] text-[13px] leading-[18px] text-[var(--color-text-tertiary)]">
      {children}
    </p>
  )
}

export function SettingsPage() {
  const { data: prefs, isLoading: prefsLoading } = useUserPreferences()
  const toggleNotifications = useToggleNotifications()
  const {
    isSupported: pushSupported,
    isLoading: pushLoading,
    permissionStatus,
    enableNotifications,
  } = usePushNotifications()

  const notificationsEnabled = prefs?.notifications?.dailyBrief ?? true
  const canEnableNotifications = pushSupported && permissionStatus !== "denied"

  const handleNotificationToggle = async (checked: boolean) => {
    hapticLight()

    if (checked && permissionStatus !== "granted") {
      const success = await enableNotifications()
      if (success) {
        hapticSuccess()
      }
      if (!success) return
    }
    toggleNotifications.mutate({ dailyBrief: checked })
  }

  return (
    <div className="space-y-[24px] pb-[20px]">
      {/* Notifications Section */}
      <section>
        <SectionHeader>Notifications</SectionHeader>
        <div className="overflow-hidden rounded-[10px] bg-[var(--color-surface)]">
          {/* Daily Brief row */}
          <div className="flex h-[44px] items-center px-[16px]">
            <div className="flex h-[29px] w-[29px] shrink-0 items-center justify-center rounded-[6px] bg-[#FF3B30]">
              <Bell className="h-[17px] w-[17px] text-white" strokeWidth={1.75} />
            </div>
            <span className="ml-[12px] flex-1 text-[17px] leading-[22px] text-[var(--color-text-primary)]">
              Daily Brief
            </span>
            <Switch
              checked={notificationsEnabled}
              onCheckedChange={handleNotificationToggle}
              disabled={
                prefsLoading ||
                pushLoading ||
                toggleNotifications.isPending ||
                !canEnableNotifications
              }
            />
          </div>
        </div>
        {permissionStatus === "denied" ? (
          <SectionFooter>
            Notifications are turned off. To enable, go to{" "}
            <span className="font-medium">Settings → P&C Brief → Notifications</span>.
          </SectionFooter>
        ) : !pushSupported && !pushLoading ? (
          <SectionFooter>
            Push notifications aren't available on this device.
          </SectionFooter>
        ) : (
          <SectionFooter>
            Get a notification each morning when your brief is ready.
          </SectionFooter>
        )}
      </section>

      {/* Preferences Section */}
      <section>
        <SectionHeader>Preferences</SectionHeader>
        <div className="overflow-hidden rounded-[10px] bg-[var(--color-surface)]">
          {/* Topics row - disabled */}
          <div className="flex h-[44px] items-center px-[16px]">
            <div className="flex h-[29px] w-[29px] shrink-0 items-center justify-center rounded-[6px] bg-[#5856D6] opacity-50">
              <Tag className="h-[17px] w-[17px] text-white" strokeWidth={1.75} />
            </div>
            <span className="ml-[12px] flex-1 text-[17px] leading-[22px] text-[var(--color-text-tertiary)]">
              Topics
            </span>
            <span className="mr-[6px] text-[15px] text-[var(--color-text-quaternary)]">
              Coming Soon
            </span>
            <ChevronRight className="h-[14px] w-[14px] text-[var(--color-text-quaternary)]" strokeWidth={2} />
          </div>
          {/* Separator */}
          <div className="ml-[57px] h-[0.5px] bg-[var(--color-separator)]" />
          {/* Reading row - disabled */}
          <div className="flex h-[44px] items-center px-[16px]">
            <div className="flex h-[29px] w-[29px] shrink-0 items-center justify-center rounded-[6px] bg-[#007AFF] opacity-50">
              <TextCursor className="h-[17px] w-[17px] text-white" strokeWidth={1.75} />
            </div>
            <span className="ml-[12px] flex-1 text-[17px] leading-[22px] text-[var(--color-text-tertiary)]">
              Reading
            </span>
            <span className="mr-[6px] text-[15px] text-[var(--color-text-quaternary)]">
              Coming Soon
            </span>
            <ChevronRight className="h-[14px] w-[14px] text-[var(--color-text-quaternary)]" strokeWidth={2} />
          </div>
        </div>
      </section>

      {/* About Section */}
      <section>
        <SectionHeader>About</SectionHeader>
        <div className="overflow-hidden rounded-[10px] bg-[var(--color-surface)]">
          {/* Version row */}
          <div className="flex h-[44px] items-center px-[16px]">
            <div className="flex h-[29px] w-[29px] shrink-0 items-center justify-center rounded-[6px] bg-[var(--color-fill-secondary)]">
              <Info className="h-[17px] w-[17px] text-[var(--color-text-secondary)]" strokeWidth={1.75} />
            </div>
            <span className="ml-[12px] flex-1 text-[17px] leading-[22px] text-[var(--color-text-primary)]">
              Version
            </span>
            <span className="text-[17px] text-[var(--color-text-tertiary)]">
              1.0.0
            </span>
          </div>
          {/* Separator */}
          <div className="ml-[57px] h-[0.5px] bg-[var(--color-separator)]" />
          {/* Terms of Service row */}
          <button
            className="flex h-[44px] w-full items-center px-[16px] text-left transition-colors active:bg-[var(--color-fill-quaternary)]"
            onClick={() => hapticLight()}
          >
            <div className="flex h-[29px] w-[29px] shrink-0 items-center justify-center rounded-[6px] bg-[var(--color-fill-secondary)]">
              <FileText className="h-[17px] w-[17px] text-[var(--color-text-secondary)]" strokeWidth={1.75} />
            </div>
            <span className="ml-[12px] flex-1 text-[17px] leading-[22px] text-[var(--color-text-primary)]">
              Terms of Service
            </span>
            <ChevronRight className="h-[14px] w-[14px] text-[var(--color-text-quaternary)]" strokeWidth={2} />
          </button>
          {/* Separator */}
          <div className="ml-[57px] h-[0.5px] bg-[var(--color-separator)]" />
          {/* Privacy Policy row */}
          <button
            className="flex h-[44px] w-full items-center px-[16px] text-left transition-colors active:bg-[var(--color-fill-quaternary)]"
            onClick={() => hapticLight()}
          >
            <div className="flex h-[29px] w-[29px] shrink-0 items-center justify-center rounded-[6px] bg-[var(--color-fill-secondary)]">
              <Shield className="h-[17px] w-[17px] text-[var(--color-text-secondary)]" strokeWidth={1.75} />
            </div>
            <span className="ml-[12px] flex-1 text-[17px] leading-[22px] text-[var(--color-text-primary)]">
              Privacy Policy
            </span>
            <ChevronRight className="h-[14px] w-[14px] text-[var(--color-text-quaternary)]" strokeWidth={2} />
          </button>
        </div>
      </section>

      {/* Sign Out */}
      <section className="pt-[12px]">
        <div className="overflow-hidden rounded-[10px] bg-[var(--color-surface)]">
          <button
            className="flex h-[44px] w-full items-center justify-center text-[17px] text-[#FF3B30] transition-colors active:bg-[var(--color-fill-quaternary)]"
            onClick={() => hapticLight()}
          >
            Sign Out
          </button>
        </div>
      </section>

      {/* Footer */}
      <footer className="pt-[8px] text-center">
        <p className="text-[13px] text-[var(--color-text-quaternary)]">
          P&C Brief
        </p>
      </footer>
    </div>
  )
}



================================================================================
FILE: src/pages/SourcesPage.tsx
================================================================================
/**
 * Sources Page - Manage followed news sources
 */

import { useMemo } from "react"
import { Globe } from "lucide-react"
import { toast } from "sonner"
import {
  useAllSources,
  useUserPreferences,
  useToggleSource,
  useResetSourcePreferences,
} from "@/lib/hooks"
import { useAuth } from "@/lib/auth-context"
import { SourceRow, SourceRowSkeleton } from "@/components/sources"
import { Card, Separator, EmptyState, ErrorState } from "@/components/ui"
import { hapticLight, hapticSuccess } from "@/lib/haptics"

export function SourcesPage() {
  const { isLoading: authLoading } = useAuth()
  const { data: sources, isLoading: sourcesLoading, error: sourcesError } = useAllSources()
  const { data: preferences, isLoading: prefsLoading } = useUserPreferences()
  const toggleSource = useToggleSource()
  const resetPreferences = useResetSourcePreferences()

  // Determine which sources the user is following
  // Empty enabledSourceIds means "follow all"
  const followedSourceIds = useMemo(() => {
    if (!preferences?.enabledSourceIds || preferences.enabledSourceIds.length === 0) {
      // Following all sources
      return sources?.map((s) => s.id) ?? []
    }
    return preferences.enabledSourceIds
  }, [preferences, sources])

  const isFollowingAll =
    !preferences?.enabledSourceIds || preferences.enabledSourceIds.length === 0

  const followingCount = isFollowingAll
    ? sources?.length ?? 0
    : followedSourceIds.length

  const isLoading = authLoading || sourcesLoading || prefsLoading

  const handleToggle = (sourceId: string, enabled: boolean) => {
    hapticLight()

    // If currently following all and toggling off, we need to set explicit list
    let currentIds: string[]
    if (isFollowingAll) {
      // Start with all sources, then remove the one being toggled off
      currentIds = sources?.map((s) => s.id) ?? []
    } else {
      currentIds = [...followedSourceIds]
    }

    toggleSource.mutate(
      { sourceId, enabled, currentEnabledIds: currentIds },
      {
        onError: (error) => {
          console.error("Failed to toggle source:", error)
          toast.error("Failed to update preference", {
            description: "Please try again",
          })
        },
      }
    )
  }

  const handleFollowAll = () => {
    resetPreferences.mutate(undefined, {
      onSuccess: () => {
        hapticSuccess()
        toast.success("Following all sources")
      },
      onError: (error) => {
        console.error("Failed to reset preferences:", error)
        toast.error("Failed to update preferences")
      },
    })
  }

  return (
    <div className="space-y-[24px]">
      {/* Description */}
      <p className="-mt-[6px] text-[14px] leading-[1.5] tracking-[-0.14px] text-[var(--color-text-secondary)]">
        Choose which sources appear in your feed. Changes only affect your personal view.
      </p>

      {/* Stats and actions bar */}
      {!isLoading && sources && (
        <div className="flex min-h-[44px] items-center justify-between py-[2px]">
          <p className="text-[13px] tracking-[-0.08px] text-[var(--color-text-tertiary)]">
            Following{" "}
            <span className="font-medium tabular-nums text-[var(--color-text-secondary)]">
              {followingCount}
            </span>{" "}
            of {sources.length}
          </p>
          {!isFollowingAll && (
            <button
              onClick={handleFollowAll}
              disabled={resetPreferences.isPending}
              className="min-h-[34px] min-w-[44px] px-[var(--spacing-2)] text-[15px] font-normal tracking-[-0.2px] text-[var(--color-accent)] transition-opacity active:opacity-50 disabled:opacity-38"
            >
              Follow All
            </button>
          )}
        </div>
      )}

      {/* Sources list */}
      <div className="min-h-[40vh]">
        {/* Loading state */}
        {isLoading && (
          <Card variant="grouped">
            {Array.from({ length: 6 }).map((_, i) => (
              <div key={i}>
                <SourceRowSkeleton />
                {i < 5 && <Separator variant="inset" />}
              </div>
            ))}
          </Card>
        )}

        {/* Error state */}
        {sourcesError && (
          <ErrorState
            title="Unable to load sources"
            description="We couldn't fetch the sources list. Please try again."
            onRetry={() => window.location.reload()}
          />
        )}

        {/* Empty state */}
        {!isLoading && !sourcesError && sources?.length === 0 && (
          <EmptyState
            icon={Globe}
            title="No sources available"
            description="News sources will appear here once configured."
          />
        )}

        {/* Sources grouped list - iOS Settings style */}
        {!isLoading && sources && sources.length > 0 && (
          <Card variant="grouped">
            {sources.map((source, index) => (
              <div key={source.id}>
                <SourceRow
                  source={source}
                  isFollowing={followedSourceIds.includes(source.id)}
                  onToggle={(enabled) => handleToggle(source.id, enabled)}
                  isLoading={toggleSource.isPending}
                />
                {index < sources.length - 1 && <Separator variant="inset" />}
              </div>
            ))}
          </Card>
        )}
      </div>
    </div>
  )
}



================================================================================
FILE: src/pages/TodayPage.tsx
================================================================================
/**
 * Today Screen - Premium Daily Brief View
 *
 * Apple-inspired design with refined hierarchy:
 * - Date header with AI badge
 * - Executive summary with accent bullets
 * - Top stories carousel with gradient overlays
 * - Category sections with muted icon chips
 * - Topics and sources footer
 */

import { useState } from "react"
import { Newspaper, Sparkles } from "lucide-react"
import { useTodayBrief, type TopStoryWithArticle } from "@/lib/hooks/use-today-brief"
import {
  TodayScreenSkeleton,
  TopStoriesCarousel,
  BriefSections,
  ArticleSheet,
} from "@/components/brief"
import { EmptyState, ErrorState } from "@/components/ui"
import { hapticMedium } from "@/lib/haptics"

function formatDate(dateString: string): string {
  const date = new Date(dateString + "T12:00:00")
  return date.toLocaleDateString("en-US", {
    weekday: "long",
    month: "long",
    day: "numeric",
  })
}

function formatUpdateTime(createdAt: { toDate?: () => Date } | null): string {
  if (!createdAt || !createdAt.toDate) {
    return "Updated this morning"
  }
  try {
    const date = createdAt.toDate()
    const hours = date.getHours()
    const minutes = date.getMinutes()
    const ampm = hours >= 12 ? "PM" : "AM"
    const displayHours = hours % 12 || 12
    const displayMinutes = minutes.toString().padStart(2, "0")
    return `Updated ${displayHours}:${displayMinutes} ${ampm} ET`
  } catch {
    return "Updated this morning"
  }
}

export function TodayPage() {
  const { data, isLoading, error, refetch } = useTodayBrief()
  const [selectedStory, setSelectedStory] = useState<TopStoryWithArticle | null>(null)
  const [sheetOpen, setSheetOpen] = useState(false)

  const handleSelectStory = (story: TopStoryWithArticle) => {
    hapticMedium()
    setSelectedStory(story)
    setSheetOpen(true)
  }

  // Loading state (only show skeleton if no cached data)
  if (isLoading && !data) {
    return <TodayScreenSkeleton />
  }

  // Error state
  if (error && !data) {
    return (
      <ErrorState
        title="Unable to load brief"
        description="We couldn't fetch today's briefing. Please try again."
        onRetry={() => refetch()}
      />
    )
  }

  // No brief found
  if (!data?.found || !data.brief) {
    return (
      <EmptyState
        icon={Newspaper}
        title="No brief available yet"
        description="Check back soon for today's industry briefing."
      />
    )
  }

  const { brief, topStoriesWithArticles } = data

  return (
    <>
      <div className="space-y-[28px]">
        {/* Date Header */}
        <header className="-mt-[4px] space-y-[2px]">
          <p className="text-[15px] font-medium tracking-[-0.2px] text-[var(--color-text-secondary)]">
            {formatDate(brief.date)}
          </p>
        </header>

        {/* Executive Summary Card */}
        <section className="overflow-hidden rounded-[16px] bg-[var(--color-surface)] shadow-[0_1px_3px_rgba(0,0,0,0.04),0_0_0_0.5px_rgba(0,0,0,0.02)]">
          {/* Card Header with AI Badge */}
          <div className="flex items-center justify-between border-b border-[var(--color-separator)] px-[18px] py-[12px]">
            <div className="flex items-center gap-[8px]">
              <div className="flex h-[22px] items-center gap-[5px] rounded-full bg-gradient-to-r from-[#007AFF]/10 to-[#5856D6]/10 px-[10px]">
                <Sparkles className="h-[12px] w-[12px] text-[#007AFF]" strokeWidth={2} />
                <span className="text-[11px] font-semibold tracking-[0.2px] text-[#007AFF]">
                  AI Daily Brief
                </span>
              </div>
            </div>
            <span className="text-[11px] font-medium tracking-[-0.1px] text-[var(--color-text-quaternary)]">
              {formatUpdateTime(brief.createdAt)}
            </span>
          </div>

          {/* Executive Summary Bullets */}
          <div className="px-[18px] py-[18px]">
            <ul className="space-y-[12px]">
              {brief.executiveSummary.map((bullet, index) => (
                <li
                  key={index}
                  className="flex gap-[12px] text-[15px] leading-[1.5] tracking-[-0.2px] text-[var(--color-text-primary)]"
                >
                  <span className="mt-[8px] h-[6px] w-[6px] shrink-0 rounded-full bg-gradient-to-br from-[#007AFF] to-[#5856D6]" />
                  <span>{bullet}</span>
                </li>
              ))}
            </ul>
          </div>
        </section>

        {/* Top Stories */}
        {topStoriesWithArticles.length > 0 && (
          <section className="space-y-[10px]">
            <h2 className="text-[12px] font-semibold uppercase tracking-[0.5px] text-[var(--color-text-tertiary)]">
              Top Stories
            </h2>
            <TopStoriesCarousel
              stories={topStoriesWithArticles}
              onSelectStory={handleSelectStory}
            />
          </section>
        )}

        {/* Category Sections */}
        <section className="space-y-[10px]">
          <h2 className="text-[12px] font-semibold uppercase tracking-[0.5px] text-[var(--color-text-tertiary)]">
            By Category
          </h2>
          <BriefSections sections={brief.sections} />
        </section>

        {/* Topics */}
        {brief.topics.length > 0 && (
          <section className="space-y-[10px]">
            <h2 className="text-[12px] font-semibold uppercase tracking-[0.5px] text-[var(--color-text-tertiary)]">
              Topics Covered
            </h2>
            <div className="flex flex-wrap gap-[6px]">
              {brief.topics.map((topic, index) => (
                <span
                  key={index}
                  className="rounded-full bg-[var(--color-fill-tertiary)] px-[12px] py-[6px] text-[13px] font-medium tracking-[-0.1px] text-[var(--color-text-secondary)] transition-colors duration-[var(--duration-fast)] active:bg-[var(--color-fill-secondary)]"
                >
                  {topic}
                </span>
              ))}
            </div>
          </section>
        )}

        {/* Sources Footer */}
        <footer className="border-t border-[var(--color-separator)] pt-[16px]">
          <p className="text-[12px] font-medium leading-[1.6] tracking-[-0.06px] text-[var(--color-text-tertiary)]">
            Compiled from {brief.sourcesUsed.length} sources:{" "}
            <span className="font-normal">
              {brief.sourcesUsed.map((s) => s.name).join(" · ")}
            </span>
          </p>
        </footer>
      </div>

      {/* Article Sheet */}
      <ArticleSheet
        story={selectedStory}
        open={sheetOpen}
        onOpenChange={setSheetOpen}
      />
    </>
  )
}



================================================================================
FILE: src/types/firestore.ts
================================================================================
/**
 * Firestore Document Types for P&C Insurance News AI
 *
 * Collections:
 * - sources/{sourceId}
 * - articles/{articleId}
 * - briefs/{yyyy-mm-dd}
 * - users/{uid}
 *   - bookmarks/{articleId}
 *   - prefs/main
 */

import type { Timestamp } from "firebase/firestore";

// ============================================================================
// Sources Collection: sources/{sourceId}
// ============================================================================

export type SourceCategory =
  | "property_cat"
  | "casualty_liability"
  | "regulation"
  | "claims"
  | "reinsurance"
  | "insurtech";

/** Source tier indicating trustworthiness/quality */
export type SourceTier = "reputable" | "community" | "user-submitted";

/** Fetch state for conditional RSS requests */
export interface SourceFetchState {
  /** ETag from last fetch (for conditional requests) */
  etag: string | null;
  /** Last-Modified header from last fetch */
  lastModified: string | null;
  /** Last successful fetch timestamp */
  lastFetchedAt: Timestamp | null;
  /** Last fetch error message (null if successful) */
  lastError: string | null;
}

export interface Source {
  /** Unique identifier (slug-style, e.g., "insurance-journal") */
  id: string;
  /** Display name */
  name: string;
  /** Publisher website URL */
  siteUrl: string;
  /** RSS feed URL (legacy single-feed) */
  rssUrl: string;
  /** RSS feed URLs (supports multiple feeds per source) */
  rssUrls?: string[];
  /** Whether this source is enabled for ingestion */
  enabled: boolean;
  /** Whether this source is enabled by default for new users */
  enabledByDefault?: boolean;
  /** Source tier indicating trustworthiness */
  tier: SourceTier;
  /** Tags for categorization and filtering */
  tags: SourceCategory[];
  /** Region/geography focus (optional) */
  region?: string;
  /** Created timestamp */
  createdAt: Timestamp;
  /** Updated timestamp */
  updatedAt: Timestamp;
  /** Fetch state for conditional requests (keyed by rssUrl for multi-feed) */
  fetchState: SourceFetchState;
  /** Fetch states per RSS URL (for multi-feed sources) */
  fetchStates?: Record<string, SourceFetchState>;
}

// ============================================================================
// Articles Collection: articles/{articleId}
// ============================================================================

export interface Article {
  /** Unique identifier (SHA256 hash of canonical URL or GUID) */
  id: string;
  /** Source ID reference */
  sourceId: string;
  /** Source display name (denormalized for display) */
  sourceName: string;
  /** Article headline/title */
  title: string;
  /** Short snippet/excerpt (≤200 chars, respecting publisher policies) */
  snippet: string;
  /** Original article URL */
  url: string;
  /** Normalized canonical URL (for deduplication) */
  canonicalUrl: string;
  /** RSS GUID if available (fallback for deduplication) */
  guid: string | null;
  /** Article image URL if present in RSS */
  imageUrl: string | null;
  /** Article categories */
  categories: SourceCategory[];
  /** Publication timestamp */
  publishedAt: Timestamp;
  /** When we ingested this article */
  ingestedAt: Timestamp;
  /** P&C relevance score (0-1) from heuristic filter */
  relevanceScore: number;
  /** Whether article passes P&C relevance filter */
  isRelevant: boolean;
  /** AI-generated content (cached, generated on first request) */
  ai: ArticleAI | null;
}

/**
 * AI-generated article content
 */
export interface ArticleAI {
  /** 2-3 sentence executive summary */
  tldr: string;
  /** Why this matters for P&C professionals */
  whyItMatters: string;
  /** 2-4 relevant topic tags */
  topics: string[];
  /** Primary category */
  category: "property" | "casualty" | "reinsurance" | "regulation" | "claims" | "insurtech" | "market" | "litigation";
  /** When AI content was generated */
  generatedAt: Timestamp;
  /** Model used for generation */
  model: string;
}

// ============================================================================
// Briefs Collection: briefs/{yyyy-mm-dd}
// ============================================================================

export interface BriefTopStory {
  /** Article ID reference */
  articleId: string;
  /** Article headline (synthesized, not copied) */
  headline: string;
  /** Why this story matters for P&C professionals */
  whyItMatters: string;
}

export interface BriefSection {
  /** Section bullets (2-4 items) */
  bullets: string[];
  /** Related article IDs */
  articleIds: string[];
}

export interface BriefSourceUsed {
  /** Source ID */
  sourceId: string;
  /** Source display name */
  name: string;
}

export interface Brief {
  /** Date in yyyy-mm-dd format */
  date: string;
  /** When this brief was created */
  createdAt: Timestamp;
  /** Executive summary bullets (3-5 items) */
  executiveSummary: string[];
  /** Top stories with "why it matters" */
  topStories: BriefTopStory[];
  /** Category sections */
  sections: {
    propertyCat: BriefSection;
    casualtyLiability: BriefSection;
    regulation: BriefSection;
    claims: BriefSection;
    reinsurance: BriefSection;
    insurtech: BriefSection;
    market: BriefSection;
  };
  /** Key topics covered */
  topics: string[];
  /** Sources used to generate this brief */
  sourcesUsed: BriefSourceUsed[];
  /** Article IDs used to generate this brief (for grounded chat) */
  sourceArticleIds: string[];
  /** Model used for generation */
  model: string;
}

// ============================================================================
// Users Collection: users/{uid}
// ============================================================================

export interface UserProfile {
  /** User's Firebase UID */
  uid: string;
  /** Email address */
  email: string | null;
  /** Display name */
  displayName: string | null;
  /** Account created timestamp */
  createdAt: Timestamp;
  /** Last login timestamp */
  lastLoginAt: Timestamp;
}

// ============================================================================
// User Bookmarks Subcollection: users/{uid}/bookmarks/{articleId}
// ============================================================================

export interface Bookmark {
  /** Article ID (same as document ID) */
  articleId: string;
  /** Article title (denormalized for display) */
  title: string;
  /** Source name (denormalized) */
  sourceName: string;
  /** Article URL */
  url: string;
  /** When bookmarked */
  bookmarkedAt: Timestamp;
}

// ============================================================================
// User Preferences Subcollection: users/{uid}/prefs/main
// ============================================================================

export interface UserPreferences {
  /** Source IDs the user has enabled */
  enabledSourceIds: string[];
  /** Categories the user wants to see */
  enabledCategories: SourceCategory[];
  /** Notification preferences */
  notifications: {
    dailyBrief: boolean;
    breakingNews: boolean;
  };
  /** Last updated timestamp */
  updatedAt: Timestamp;
}



================================================================================
FILE: src/types/index.ts
================================================================================
/**
 * Type exports for P&C Insurance News AI
 */

export type {
  // Source types
  Source,
  SourceCategory,
  SourceTier,
  SourceFetchState,
  // Article types
  Article,
  ArticleAI,
  // Brief types
  Brief,
  BriefTopStory,
  BriefSection,
  BriefSourceUsed,
  // User types
  UserProfile,
  Bookmark,
  UserPreferences,
} from "./firestore";




################################################################################
# PUBLIC FILES
################################################################################

================================================================================
FILE: public/manifest.json
================================================================================
{
  "name": "P&C Brief",
  "short_name": "P&C Brief",
  "description": "Insurance industry news and insights powered by AI",
  "start_url": "/",
  "display": "standalone",
  "background_color": "#ffffff",
  "theme_color": "#FFFFFF",
  "orientation": "portrait",
  "icons": [
    {
      "src": "/logo.svg",
      "sizes": "any",
      "type": "image/svg+xml",
      "purpose": "any"
    },
    {
      "src": "/icons/icon-192.png",
      "sizes": "192x192",
      "type": "image/png",
      "purpose": "any maskable"
    },
    {
      "src": "/icons/icon-512.png",
      "sizes": "512x512",
      "type": "image/png",
      "purpose": "any maskable"
    }
  ]
}



================================================================================
FILE: public/firebase-messaging-sw.js
================================================================================
/**
 * Firebase Cloud Messaging Service Worker
 *
 * This service worker handles background push notifications for the web app.
 * It must be placed in the public directory to be served from the root.
 */

// Import Firebase scripts for service worker
importScripts('https://www.gstatic.com/firebasejs/10.7.0/firebase-app-compat.js');
importScripts('https://www.gstatic.com/firebasejs/10.7.0/firebase-messaging-compat.js');

// Firebase configuration (must match the main app config)
const firebaseConfig = {
  apiKey: "AIzaSyC55lowlixG6V8KI-bWV4T-x6MiuNp38-g",
  projectId: "insurance-news-ai",
  authDomain: "insurance-news-ai.firebaseapp.com",
  storageBucket: "insurance-news-ai.firebasestorage.app",
  messagingSenderId: "695640024145",
  appId: "1:695640024145:web:ab17c496e14b3d915ac470",
};

// Initialize Firebase in the service worker
firebase.initializeApp(firebaseConfig);

// Get messaging instance
const messaging = firebase.messaging();

/**
 * Handle background messages
 * This is called when the app is in the background or closed
 */
messaging.onBackgroundMessage((payload) => {
  console.log('[firebase-messaging-sw.js] Received background message:', payload);

  // Extract notification data
  const notificationTitle = payload.notification?.title || 'P&C Brief';
  const notificationOptions = {
    body: payload.notification?.body || 'You have a new update',
    icon: '/pwa-192x192.png',
    badge: '/pwa-192x192.png',
    tag: payload.data?.type || 'default',
    data: payload.data,
    // iOS-style notification options
    vibrate: [100, 50, 100],
    requireInteraction: false,
    actions: [
      {
        action: 'open',
        title: 'Open',
      },
    ],
  };

  // Show the notification
  self.registration.showNotification(notificationTitle, notificationOptions);
});

/**
 * Handle notification click
 */
self.addEventListener('notificationclick', (event) => {
  console.log('[firebase-messaging-sw.js] Notification clicked:', event);

  event.notification.close();

  // Determine the URL to open based on notification data
  let urlToOpen = '/';
  
  if (event.notification.data?.type === 'daily_brief') {
    urlToOpen = '/'; // Daily brief is on the home page
  }

  // Focus existing window or open new one
  event.waitUntil(
    clients.matchAll({ type: 'window', includeUncontrolled: true }).then((windowClients) => {
      // Check if there's already a window open
      for (const client of windowClients) {
        if (client.url.includes(self.location.origin) && 'focus' in client) {
          client.focus();
          if (urlToOpen !== '/') {
            client.navigate(urlToOpen);
          }
          return;
        }
      }
      // Open new window if none exists
      if (clients.openWindow) {
        return clients.openWindow(urlToOpen);
      }
    })
  );
});

/**
 * Handle service worker installation
 */
self.addEventListener('install', (event) => {
  console.log('[firebase-messaging-sw.js] Service worker installed');
  self.skipWaiting();
});

/**
 * Handle service worker activation
 */
self.addEventListener('activate', (event) => {
  console.log('[firebase-messaging-sw.js] Service worker activated');
  event.waitUntil(clients.claim());
});




################################################################################
# BACKEND FIREBASE FUNCTIONS (functions/src/)
################################################################################

================================================================================
FILE: functions/package.json
================================================================================
{
  "name": "functions",
  "scripts": {
    "lint": "eslint --ext .js,.ts .",
    "build": "tsc",
    "build:watch": "tsc --watch",
    "serve": "npm run build && firebase emulators:start --only functions",
    "shell": "npm run build && firebase functions:shell",
    "start": "npm run shell",
    "deploy": "firebase deploy --only functions",
    "logs": "firebase functions:log",
    "seed-sources": "npm run build && node lib/scripts/seed-sources.js",
    "backfill": "npm run build && node lib/scripts/backfill-and-brief.js",
    "check-data": "npm run build && node lib/scripts/check-data.js",
    "show-brief": "npm run build && node lib/scripts/show-brief.js",
    "regenerate-brief": "npm run build && node lib/scripts/regenerate-brief.js"
  },
  "engines": {
    "node": "22"
  },
  "main": "lib/index.js",
  "dependencies": {
    "firebase-admin": "^13.0.2",
    "firebase-functions": "^6.3.0",
    "openai": "^6.18.0",
    "rss-parser": "^3.13.0"
  },
  "devDependencies": {
    "@typescript-eslint/eslint-plugin": "^8.20.0",
    "@typescript-eslint/parser": "^8.20.0",
    "eslint": "^9.18.0",
    "firebase-functions-test": "^3.4.0",
    "globals": "^17.3.0",
    "typescript": "^5.7.3"
  },
  "private": true
}


================================================================================
FILE: functions/tsconfig.json
================================================================================
{
  "compilerOptions": {
    "module": "NodeNext",
    "moduleResolution": "NodeNext",
    "noImplicitReturns": true,
    "noUnusedLocals": true,
    "outDir": "lib",
    "sourceMap": true,
    "strict": true,
    "target": "ES2022",
    "skipLibCheck": true
  },
  "compileOnSave": true,
  "include": [
    "src"
  ]
}



================================================================================
FILE: functions/src/config/admin.ts
================================================================================
/**
 * Admin Configuration
 *
 * Hardcoded allowlist of admin emails for MVP.
 * In production, consider using Firebase custom claims instead.
 */

/** List of email addresses with admin privileges */
export const ADMIN_EMAILS: readonly string[] = [
  "sal.scrudato@gmail.com",
] as const;

/**
 * Check if an email is in the admin allowlist
 */
export function isAdminEmail(email: string | undefined | null): boolean {
  if (!email) return false;
  return ADMIN_EMAILS.includes(email.toLowerCase());
}



================================================================================
FILE: functions/src/index.ts
================================================================================
/**
 * Firebase Cloud Functions (v2)
 */

import { onRequest, onCall, HttpsError } from "firebase-functions/v2/https";
import { onSchedule } from "firebase-functions/v2/scheduler";
import { initializeApp, getApps } from "firebase-admin/app";
import { getFirestore, FieldValue, Timestamp } from "firebase-admin/firestore";
import { isAdminEmail } from "./config/admin.js";
import { ingestAllEnabledSources } from "./lib/ingestion/index.js";
import {
  getOpenAIClient,
  openaiApiKey,
  AI_MODEL,
  AI_MODEL_PREMIUM,
  ARTICLE_AI_SCHEMA,
  DAILY_BRIEF_SCHEMA,
  ARTICLE_SUMMARIZE_SYSTEM,
  DAILY_BRIEF_SYSTEM,
  buildArticleSummarizePrompt,
  buildDailyBriefPrompt,
  checkRateLimit,
  selectArticlesForBrief,
  logSelectionMetrics,
  type ArticleAIResponse,
  type DailyBriefResponse,
} from "./lib/ai/index.js";
import {
  sendNotificationToOptedInUsers,
  formatDateForNotification,
} from "./lib/notifications/index.js";
import type { Article, Brief } from "./types/firestore.js";

// Initialize Firebase Admin
if (getApps().length === 0) {
  initializeApp();
}

const db = getFirestore();

/**
 * Health check endpoint
 * Returns { ok: true, ts: <ISO timestamp> }
 */
export const apiHealth = onRequest((req, res) => {
  res.json({
    ok: true,
    ts: new Date().toISOString(),
  });
});

// ============================================================================
// Admin Functions
// ============================================================================

interface AdminSetSourceEnabledData {
  sourceId: string;
  enabled: boolean;
}

/**
 * Admin-only callable function to enable/disable a source
 *
 * Requires:
 * - Authenticated user
 * - User email in admin allowlist
 *
 * @param sourceId - The source document ID
 * @param enabled - Whether to enable or disable the source
 */
export const adminSetSourceEnabled = onCall<AdminSetSourceEnabledData>(
  async (request) => {
    // Check authentication
    if (!request.auth) {
      throw new HttpsError(
        "unauthenticated",
        "You must be logged in to perform this action."
      );
    }

    // Check admin privileges
    const userEmail = request.auth.token.email;
    if (!isAdminEmail(userEmail)) {
      throw new HttpsError(
        "permission-denied",
        "You do not have permission to perform this action."
      );
    }

    // Validate input
    const { sourceId, enabled } = request.data;

    if (typeof sourceId !== "string" || sourceId.trim() === "") {
      throw new HttpsError(
        "invalid-argument",
        "sourceId must be a non-empty string."
      );
    }

    if (typeof enabled !== "boolean") {
      throw new HttpsError("invalid-argument", "enabled must be a boolean.");
    }

    // Check if source exists
    const sourceRef = db.collection("sources").doc(sourceId);
    const sourceDoc = await sourceRef.get();

    if (!sourceDoc.exists) {
      throw new HttpsError("not-found", `Source "${sourceId}" not found.`);
    }

    // Update the source
    await sourceRef.update({
      enabled,
      updatedAt: FieldValue.serverTimestamp(),
    });

    console.log(
      `[Admin] ${userEmail} set source "${sourceId}" enabled=${enabled}`
    );

    return {
      success: true,
      sourceId,
      enabled,
      updatedBy: userEmail,
    };
  }
);

// ============================================================================
// Scheduled RSS Ingestion
// ============================================================================

/**
 * Scheduled function that runs every 60 minutes to ingest RSS feeds.
 *
 * - Fetches all enabled sources
 * - Uses conditional GET (ETag/Last-Modified) to minimize bandwidth
 * - Parses items, filters for P&C relevance, deduplicates
 * - Stores articles in Firestore
 */
export const ingestRssFeeds = onSchedule(
  {
    schedule: "every 60 minutes",
    timeZone: "America/New_York",
    memory: "512MiB",
    timeoutSeconds: 540, // 9 minutes max
  },
  async () => {
    console.log("[ingestRssFeeds] Starting scheduled ingestion...");

    const summary = await ingestAllEnabledSources();

    console.log(
      `[ingestRssFeeds] Completed in ${summary.durationMs}ms. ` +
        `Sources: ${summary.sourcesProcessed}, ` +
        `Fetched: ${summary.totalItemsFetched}, ` +
        `Ingested: ${summary.totalItemsIngested}`
    );

    // Log individual source results
    for (const result of summary.results) {
      if (!result.success) {
        console.error(
          `[ingestRssFeeds] Source "${result.sourceName}" failed: ${result.error}`
        );
      }
    }
  }
);

/**
 * Admin-only callable function to backfill articles from the last 7 days.
 *
 * This is intended for one-time use after initial deployment to populate
 * the database with recent articles from all enabled sources.
 */
export const adminBackfillLast7Days = onCall(
  {
    memory: "512MiB",
    timeoutSeconds: 540,
  },
  async (request) => {
    // Check authentication
    if (!request.auth) {
      throw new HttpsError(
        "unauthenticated",
        "You must be logged in to perform this action."
      );
    }

    // Check admin privileges
    const userEmail = request.auth.token.email;
    if (!isAdminEmail(userEmail)) {
      throw new HttpsError(
        "permission-denied",
        "You do not have permission to perform this action."
      );
    }

    console.log(`[adminBackfillLast7Days] Started by ${userEmail}`);

    // Run ingestion with 7-day lookback
    const summary = await ingestAllEnabledSources({
      maxAgeDays: 7,
      forceRefresh: true,
    });

    console.log(
      `[adminBackfillLast7Days] Completed in ${summary.durationMs}ms. ` +
        `Sources: ${summary.sourcesProcessed}, ` +
        `Ingested: ${summary.totalItemsIngested}`
    );

    return {
      success: true,
      startedAt: summary.startedAt.toISOString(),
      completedAt: summary.completedAt.toISOString(),
      durationMs: summary.durationMs,
      sourcesProcessed: summary.sourcesProcessed,
      totalItemsFetched: summary.totalItemsFetched,
      totalItemsIngested: summary.totalItemsIngested,
      results: summary.results.map((r) => ({
        sourceId: r.sourceId,
        sourceName: r.sourceName,
        success: r.success,
        itemsIngested: r.itemsIngested,
        itemsSkipped: r.itemsSkipped,
        itemsDuplicate: r.itemsDuplicate,
        error: r.error,
      })),
      triggeredBy: userEmail,
    };
  }
);

/**
 * HTTP endpoint to manually trigger ingestion (for testing).
 * Requires admin authentication via query parameter.
 */
export const triggerIngestion = onRequest(
  {
    memory: "512MiB",
    timeoutSeconds: 540,
  },
  async (req, res) => {
    // Simple API key check for manual triggers
    const apiKey = req.query.key;
    if (apiKey !== process.env.INGESTION_API_KEY && !process.env.FUNCTIONS_EMULATOR) {
      res.status(401).json({ error: "Unauthorized" });
      return;
    }

    console.log("[triggerIngestion] Manual ingestion triggered");

    const maxAgeDays = parseInt(req.query.days as string) || 7;

    const summary = await ingestAllEnabledSources({ maxAgeDays });

    res.json({
      success: true,
      durationMs: summary.durationMs,
      sourcesProcessed: summary.sourcesProcessed,
      totalItemsFetched: summary.totalItemsFetched,
      totalItemsIngested: summary.totalItemsIngested,
      results: summary.results,
    });
  }
);

// ============================================================================
// AI Functions
// ============================================================================

interface GetOrCreateArticleAIData {
  articleId: string;
}

/**
 * Generate or retrieve cached AI summary for an article.
 *
 * Requires authentication. Rate limited per user.
 * Uses OpenAI gpt-4o-mini with structured output.
 *
 * @param articleId - The article document ID
 * @returns AI-generated content (tldr, whyItMatters, topics, category)
 */
export const getOrCreateArticleAI = onCall<GetOrCreateArticleAIData>(
  {
    secrets: [openaiApiKey],
    memory: "256MiB",
    timeoutSeconds: 60,
  },
  async (request) => {
    // Require authentication
    if (!request.auth) {
      throw new HttpsError(
        "unauthenticated",
        "You must be logged in to use this feature."
      );
    }

    const uid = request.auth.uid;
    const { articleId } = request.data;

    // Validate input
    if (typeof articleId !== "string" || articleId.trim() === "") {
      throw new HttpsError(
        "invalid-argument",
        "articleId must be a non-empty string."
      );
    }

    // Check rate limit
    const rateLimit = await checkRateLimit(uid, "articleAI");
    if (!rateLimit.isAllowed) {
      throw new HttpsError(
        "resource-exhausted",
        `Daily limit reached. Try again tomorrow. (${rateLimit.limit} requests/day)`
      );
    }

    // Fetch article
    const articleDoc = await db.collection("articles").doc(articleId).get();
    if (!articleDoc.exists) {
      throw new HttpsError("not-found", `Article "${articleId}" not found.`);
    }

    const article = articleDoc.data() as Article;

    // Return cached AI if exists
    if (article.ai) {
      console.log(`[getOrCreateArticleAI] Returning cached AI for ${articleId}`);
      return {
        cached: true,
        ai: {
          tldr: article.ai.tldr,
          whyItMatters: article.ai.whyItMatters,
          topics: article.ai.topics,
          category: article.ai.category,
          generatedAt: article.ai.generatedAt.toDate().toISOString(),
          model: article.ai.model,
        },
        remaining: rateLimit.remaining,
      };
    }

    // Generate AI summary
    console.log(`[getOrCreateArticleAI] Generating AI for ${articleId}`);

    const openai = getOpenAIClient();

    const prompt = buildArticleSummarizePrompt({
      title: article.title,
      snippet: article.snippet,
      sourceName: article.sourceName,
      publishedAt: article.publishedAt.toDate().toISOString().split("T")[0],
      url: article.url,
    });

    const response = await openai.responses.create({
      model: AI_MODEL,
      input: [
        { role: "system", content: ARTICLE_SUMMARIZE_SYSTEM },
        { role: "user", content: prompt },
      ],
      text: {
        format: {
          type: "json_schema",
          name: "article_ai",
          schema: ARTICLE_AI_SCHEMA,
          strict: true,
        },
      },
    });

    // Parse structured output
    const outputText = response.output_text;
    let aiResult: ArticleAIResponse;
    try {
      aiResult = JSON.parse(outputText) as ArticleAIResponse;
    } catch {
      console.error("[getOrCreateArticleAI] Failed to parse AI response:", outputText);
      throw new HttpsError("internal", "Failed to parse AI response");
    }

    // Save to Firestore
    const now = Timestamp.now();
    await articleDoc.ref.update({
      ai: {
        tldr: aiResult.tldr,
        whyItMatters: aiResult.whyItMatters,
        topics: aiResult.topics,
        category: aiResult.category,
        generatedAt: now,
        model: AI_MODEL,
      },
    });

    console.log(`[getOrCreateArticleAI] Saved AI for ${articleId}`);

    return {
      cached: false,
      ai: {
        tldr: aiResult.tldr,
        whyItMatters: aiResult.whyItMatters,
        topics: aiResult.topics,
        category: aiResult.category,
        generatedAt: now.toDate().toISOString(),
        model: AI_MODEL,
      },
      remaining: rateLimit.remaining,
    };
  }
);

// ============================================================================
// Daily Brief Functions
// ============================================================================

/**
 * Get today's date in America/New_York timezone formatted as yyyy-mm-dd
 */
function getTodayDateET(): string {
  const now = new Date();
  const formatter = new Intl.DateTimeFormat("en-CA", {
    timeZone: "America/New_York",
    year: "numeric",
    month: "2-digit",
    day: "2-digit",
  });
  return formatter.format(now); // returns yyyy-mm-dd
}

/**
 * Scheduled function to generate daily brief at 6:00 AM ET
 *
 * - Fetches articles from last 24-36 hours
 * - Uses OpenAI to synthesize a brief
 * - Stores in briefs/{yyyy-mm-dd}
 * - Safe regeneration: skips if brief already exists
 */
export const generateDailyBrief = onSchedule(
  {
    schedule: "0 6 * * *", // 6:00 AM daily
    timeZone: "America/New_York",
    secrets: [openaiApiKey],
  },
  async () => {
    const dateKey = getTodayDateET();
    console.log(`[generateDailyBrief] Starting brief generation for ${dateKey}`);

    // Check if brief already exists
    const briefRef = db.collection("briefs").doc(dateKey);
    const existingBrief = await briefRef.get();

    if (existingBrief.exists) {
      console.log(`[generateDailyBrief] Brief already exists for ${dateKey}, skipping`);
      return;
    }

    // Fetch articles from last 36 hours (get more candidates for filtering)
    const cutoffTime = new Date(Date.now() - 36 * 60 * 60 * 1000);
    const articlesSnap = await db
      .collection("articles")
      .where("isRelevant", "==", true)
      .where("publishedAt", ">=", Timestamp.fromDate(cutoffTime))
      .orderBy("publishedAt", "desc")
      .limit(100) // Fetch more to allow relevance gate filtering
      .get();

    if (articlesSnap.empty) {
      console.log(`[generateDailyBrief] No relevant articles found for ${dateKey}`);
      return;
    }

    console.log(`[generateDailyBrief] Found ${articlesSnap.size} candidate articles`);

    // Apply relevance gate: prioritize by score, ensure diversity
    const rawArticles = articlesSnap.docs.map((doc) => {
      const data = doc.data() as Article;
      return { ...data, id: doc.id };
    });

    const { articles: selectedArticles, metrics } = selectArticlesForBrief(rawArticles);
    logSelectionMetrics("generateDailyBrief", metrics);

    if (selectedArticles.length === 0) {
      console.log(`[generateDailyBrief] No articles passed relevance gate for ${dateKey}`);
      return;
    }

    // Prepare article data for prompt
    const articles = selectedArticles.map((a) => ({
      id: a.id,
      title: a.title,
      sourceName: a.sourceName,
      sourceId: a.sourceId,
      snippet: a.snippet,
    }));

    // Build sources used map
    const sourceMap = new Map<string, string>();
    articles.forEach((a) => {
      if (!sourceMap.has(a.sourceId)) {
        sourceMap.set(a.sourceId, a.sourceName);
      }
    });

    // Generate brief using OpenAI
    const openai = getOpenAIClient();
    const prompt = buildDailyBriefPrompt(dateKey, articles);

    console.log("[generateDailyBrief] Calling OpenAI with premium model...");

    const response = await openai.responses.create({
      model: AI_MODEL_PREMIUM,
      input: [
        { role: "system", content: DAILY_BRIEF_SYSTEM },
        { role: "user", content: prompt },
      ],
      text: {
        format: {
          type: "json_schema",
          name: "daily_brief",
          schema: DAILY_BRIEF_SCHEMA,
          strict: true,
        },
      },
    });

    // Parse structured output
    const outputText = response.output_text;
    let briefData: DailyBriefResponse;
    try {
      briefData = JSON.parse(outputText) as DailyBriefResponse;
    } catch {
      console.error("[generateDailyBrief] Failed to parse AI response:", outputText);
      throw new Error("Failed to parse AI response for daily brief");
    }

    // Build the brief document
    const brief: Brief = {
      date: dateKey,
      createdAt: Timestamp.now(),
      executiveSummary: briefData.executiveSummary,
      topStories: briefData.topStories,
      sections: briefData.sections,
      topics: briefData.topics,
      sourcesUsed: Array.from(sourceMap.entries()).map(([sourceId, name]) => ({
        sourceId,
        name,
      })),
      sourceArticleIds: articles.map((a) => a.id),
      model: AI_MODEL_PREMIUM,
    };

    // Save to Firestore
    await briefRef.set(brief);

    console.log(
      `[generateDailyBrief] Brief created for ${dateKey}: ` +
        `${brief.executiveSummary.length} summary items, ` +
        `${brief.topStories.length} top stories, ` +
        `${brief.topics.length} topics`
    );

    // Send push notifications to opted-in users
    try {
      const formattedDate = formatDateForNotification(dateKey);
      const notificationResult = await sendNotificationToOptedInUsers({
        title: "Morning Brief",
        body: `Top P&C updates for ${formattedDate}`,
        data: {
          type: "daily_brief",
          date: dateKey,
        },
      });
      console.log(
        `[generateDailyBrief] Notifications: ${notificationResult.sent} sent, ` +
          `${notificationResult.failed} failed, ${notificationResult.cleaned} cleaned`
      );
    } catch (error) {
      // Don't fail the function if notifications fail
      console.error("[generateDailyBrief] Notification send error:", error);
    }
  }
);

/**
 * HTTP trigger to manually generate daily brief (for testing)
 */
export const triggerDailyBrief = onRequest(
  { secrets: [openaiApiKey] },
  async (req, res) => {
    const dateKey = (req.query.date as string) || getTodayDateET();
    console.log(`[triggerDailyBrief] Manual trigger for ${dateKey}`);

    // Check if brief already exists
    const briefRef = db.collection("briefs").doc(dateKey);
    const existingBrief = await briefRef.get();

    if (existingBrief.exists) {
      res.json({
        ok: false,
        message: `Brief already exists for ${dateKey}`,
        date: dateKey,
      });
      return;
    }

    // Fetch articles from last 36 hours (get more candidates for filtering)
    const cutoffTime = new Date(Date.now() - 36 * 60 * 60 * 1000);
    const articlesSnap = await db
      .collection("articles")
      .where("isRelevant", "==", true)
      .where("publishedAt", ">=", Timestamp.fromDate(cutoffTime))
      .orderBy("publishedAt", "desc")
      .limit(100) // Fetch more to allow relevance gate filtering
      .get();

    if (articlesSnap.empty) {
      res.json({
        ok: false,
        message: `No relevant articles found for ${dateKey}`,
        date: dateKey,
      });
      return;
    }

    console.log(`[triggerDailyBrief] Found ${articlesSnap.size} candidate articles`);

    // Apply relevance gate: prioritize by score, ensure diversity
    const rawArticles = articlesSnap.docs.map((doc) => {
      const data = doc.data() as Article;
      return { ...data, id: doc.id };
    });

    const { articles: selectedArticles, metrics } = selectArticlesForBrief(rawArticles);
    logSelectionMetrics("triggerDailyBrief", metrics);

    if (selectedArticles.length === 0) {
      res.json({
        ok: false,
        message: `No articles passed relevance gate for ${dateKey}`,
        date: dateKey,
        metrics,
      });
      return;
    }

    // Prepare article data for prompt
    const articles = selectedArticles.map((a) => ({
      id: a.id,
      title: a.title,
      sourceName: a.sourceName,
      sourceId: a.sourceId,
      snippet: a.snippet,
    }));

    // Build sources used map
    const sourceMap = new Map<string, string>();
    articles.forEach((a) => {
      if (!sourceMap.has(a.sourceId)) {
        sourceMap.set(a.sourceId, a.sourceName);
      }
    });

    // Generate brief using OpenAI with premium model
    const openai = getOpenAIClient();
    const prompt = buildDailyBriefPrompt(dateKey, articles);

    const response = await openai.responses.create({
      model: AI_MODEL_PREMIUM,
      input: [
        { role: "system", content: DAILY_BRIEF_SYSTEM },
        { role: "user", content: prompt },
      ],
      text: {
        format: {
          type: "json_schema",
          name: "daily_brief",
          schema: DAILY_BRIEF_SCHEMA,
          strict: true,
        },
      },
    });

    // Parse structured output
    const outputText = response.output_text;
    let briefData: DailyBriefResponse;
    try {
      briefData = JSON.parse(outputText) as DailyBriefResponse;
    } catch {
      res.status(500).json({
        ok: false,
        message: "Failed to parse AI response",
        date: dateKey,
      });
      return;
    }

    // Build the brief document
    const brief: Brief = {
      date: dateKey,
      createdAt: Timestamp.now(),
      executiveSummary: briefData.executiveSummary,
      topStories: briefData.topStories,
      sections: briefData.sections,
      topics: briefData.topics,
      sourcesUsed: Array.from(sourceMap.entries()).map(([sourceId, name]) => ({
        sourceId,
        name,
      })),
      sourceArticleIds: articles.map((a) => a.id),
      model: AI_MODEL_PREMIUM,
    };

    // Save to Firestore
    await briefRef.set(brief);

    res.json({
      ok: true,
      message: `Brief created for ${dateKey}`,
      date: dateKey,
      stats: {
        summaryItems: brief.executiveSummary.length,
        topStories: brief.topStories.length,
        topics: brief.topics.length,
        articlesUsed: brief.sourceArticleIds.length,
      },
      selectionMetrics: metrics,
    });
  }
);

interface GetTodayBriefData {
  date?: string;
}

/**
 * Callable function to get today's brief with article cards
 *
 * @param date - Optional date in yyyy-mm-dd format (defaults to today ET)
 * @returns Brief with topStories populated with full article data
 */
export const getTodayBrief = onCall<GetTodayBriefData>(async (request) => {
  const { date } = request.data || {};

  // Get date key (default to today in ET)
  const dateKey = date || getTodayDateET();

  console.log(`[getTodayBrief] Fetching brief for ${dateKey}`);

  // Fetch brief
  const briefDoc = await db.collection("briefs").doc(dateKey).get();

  if (!briefDoc.exists) {
    return {
      found: false,
      date: dateKey,
      brief: null,
      topStoriesWithArticles: [],
    };
  }

  const brief = briefDoc.data() as Brief;

  // Fetch full article data for top stories
  const topStoryIds = brief.topStories.map((s) => s.articleId);
  const articleDocs = await Promise.all(
    topStoryIds.map((id) => db.collection("articles").doc(id).get())
  );

  const topStoriesWithArticles = brief.topStories.map((story, index) => {
    const articleDoc = articleDocs[index];
    if (!articleDoc.exists) {
      return {
        ...story,
        article: null,
      };
    }

    const article = articleDoc.data() as Article;
    return {
      ...story,
      article: {
        id: articleDoc.id,
        title: article.title,
        url: article.url,
        sourceName: article.sourceName,
        sourceId: article.sourceId,
        publishedAt: article.publishedAt.toDate().toISOString(),
        snippet: article.snippet,
        imageUrl: article.imageUrl || null,
      },
    };
  });

  return {
    found: true,
    date: dateKey,
    brief: {
      ...brief,
      createdAt: brief.createdAt.toDate().toISOString(),
    },
    topStoriesWithArticles,
  };
});


================================================================================
FILE: functions/src/lib/ai/article-selection.ts
================================================================================
/**
 * Article Selection for Daily Brief Generation
 * 
 * Implements a "relevance gate" that prioritizes articles by:
 * 1. Relevance score (higher = more relevant to P&C)
 * 2. Category diversity (ensure coverage across P&C topics)
 * 3. Source diversity (avoid over-representation from one source)
 * 
 * Also provides logging/metrics for debugging relevance drift.
 */

import type { Article, SourceCategory } from "../../types/firestore.js";

// Minimum relevance score for inclusion in daily brief
// Articles below this threshold are filtered out even if isRelevant=true
const MIN_BRIEF_RELEVANCE_SCORE = 0.4;

// Maximum articles from a single source (prevents source over-representation)
const MAX_PER_SOURCE = 8;

// Maximum total articles to send to AI
const MAX_TOTAL_ARTICLES = 40;

/**
 * Article with selection metadata
 */
interface ArticleWithMeta {
  id: string;
  title: string;
  sourceName: string;
  sourceId: string;
  snippet: string;
  relevanceScore: number;
  categories: SourceCategory[];
}

/**
 * Selection metrics for logging
 */
export interface SelectionMetrics {
  totalCandidates: number;
  filteredByScore: number;
  selectedCount: number;
  categoryDistribution: Record<string, number>;
  sourceDistribution: Record<string, number>;
  avgRelevanceScore: number;
  minRelevanceScore: number;
  maxRelevanceScore: number;
}

/**
 * Select and prioritize articles for daily brief generation.
 * 
 * Applies relevance gate and ensures diversity across categories and sources.
 * 
 * @param rawArticles - Articles fetched from Firestore
 * @returns Selected articles for brief generation and metrics for logging
 */
export function selectArticlesForBrief(
  rawArticles: Article[]
): { articles: ArticleWithMeta[]; metrics: SelectionMetrics } {
  // Convert to selection format
  const candidates: ArticleWithMeta[] = rawArticles.map((a) => ({
    id: a.id,
    title: a.title,
    sourceName: a.sourceName,
    sourceId: a.sourceId,
    snippet: a.snippet,
    relevanceScore: a.relevanceScore,
    categories: a.categories,
  }));

  const totalCandidates = candidates.length;

  // Step 1: Filter by minimum relevance score (relevance gate)
  const highRelevance = candidates.filter(
    (a) => a.relevanceScore >= MIN_BRIEF_RELEVANCE_SCORE
  );
  const filteredByScore = totalCandidates - highRelevance.length;

  // Step 2: Sort by relevance score (descending)
  highRelevance.sort((a, b) => b.relevanceScore - a.relevanceScore);

  // Step 3: Apply diversity constraints
  const selected: ArticleWithMeta[] = [];
  const categoryCount: Record<string, number> = {};
  const sourceCount: Record<string, number> = {};

  for (const article of highRelevance) {
    if (selected.length >= MAX_TOTAL_ARTICLES) break;

    // Check source limit
    const srcCount = sourceCount[article.sourceId] || 0;
    if (srcCount >= MAX_PER_SOURCE) continue;

    // Add article
    selected.push(article);
    sourceCount[article.sourceId] = srcCount + 1;

    // Track category distribution
    for (const cat of article.categories) {
      categoryCount[cat] = (categoryCount[cat] || 0) + 1;
    }
  }

  // Step 4: Compute metrics
  const relevanceScores = selected.map((a) => a.relevanceScore);
  const avgScore = relevanceScores.length > 0
    ? relevanceScores.reduce((sum, s) => sum + s, 0) / relevanceScores.length
    : 0;

  const metrics: SelectionMetrics = {
    totalCandidates,
    filteredByScore,
    selectedCount: selected.length,
    categoryDistribution: categoryCount,
    sourceDistribution: sourceCount,
    avgRelevanceScore: Math.round(avgScore * 100) / 100,
    minRelevanceScore: relevanceScores.length > 0 ? Math.min(...relevanceScores) : 0,
    maxRelevanceScore: relevanceScores.length > 0 ? Math.max(...relevanceScores) : 0,
  };

  return { articles: selected, metrics };
}

/**
 * Log selection metrics for debugging relevance drift
 */
export function logSelectionMetrics(prefix: string, metrics: SelectionMetrics): void {
  console.log(`[${prefix}] Article selection metrics:`);
  console.log(`  Candidates: ${metrics.totalCandidates}, Filtered (low score): ${metrics.filteredByScore}, Selected: ${metrics.selectedCount}`);
  console.log(`  Relevance scores - Avg: ${metrics.avgRelevanceScore}, Min: ${metrics.minRelevanceScore}, Max: ${metrics.maxRelevanceScore}`);
  console.log(`  Category distribution: ${JSON.stringify(metrics.categoryDistribution)}`);
  console.log(`  Source distribution: ${JSON.stringify(metrics.sourceDistribution)}`);
}



================================================================================
FILE: functions/src/lib/ai/index.ts
================================================================================
/**
 * AI Module Exports
 */

export {
  getOpenAIClient,
  openaiApiKey,
  AI_MODEL,
  AI_MODEL_PREMIUM,
  ARTICLE_AI_SCHEMA,
  DAILY_BRIEF_SCHEMA,
  type ArticleAIResponse,
  type DailyBriefResponse,
} from "./openai-client.js";

export {
  ARTICLE_SUMMARIZE_SYSTEM,
  DAILY_BRIEF_SYSTEM,
  buildArticleSummarizePrompt,
  buildDailyBriefPrompt,
} from "./prompts.js";

export {
  RATE_LIMITS,
  checkRateLimit,
  getRateLimitStatus,
} from "./rate-limit.js";

export {
  selectArticlesForBrief,
  logSelectionMetrics,
  type SelectionMetrics,
} from "./article-selection.js";


================================================================================
FILE: functions/src/lib/ai/openai-client.ts
================================================================================
/**
 * OpenAI Client Wrapper
 *
 * Uses the official OpenAI SDK with Responses API for:
 * - Article summarization and classification
 * - Grounded Q&A using daily brief context
 */

import OpenAI from "openai";
import { defineSecret } from "firebase-functions/params";

// Define the secret (accessed at runtime)
export const openaiApiKey = defineSecret("OPENAI_API_KEY");

// Lazy-initialized client
let _client: OpenAI | null = null;

/**
 * Get the OpenAI client instance.
 * Must be called within a function that has access to the secret.
 */
export function getOpenAIClient(): OpenAI {
  if (!_client) {
    const apiKey = openaiApiKey.value();
    if (!apiKey) {
      throw new Error("OPENAI_API_KEY secret is not configured");
    }
    _client = new OpenAI({ apiKey });
  }
  return _client;
}

/**
 * Model configuration for AI operations.
 * - gpt-4o: Higher quality for critical content (daily briefs)
 * - gpt-4o-mini: Cost-efficient for high-volume operations (article summaries)
 */
export const AI_MODEL = "gpt-4o-mini";
export const AI_MODEL_PREMIUM = "gpt-4o";

/**
 * Article AI response structure
 */
export interface ArticleAIResponse {
  tldr: string;
  whyItMatters: string;
  topics: string[];
  category: string;
}

/**
 * JSON schema for article AI structured output
 */
export const ARTICLE_AI_SCHEMA = {
  type: "object" as const,
  properties: {
    tldr: {
      type: "string",
      description: "2-3 sentence executive summary of the article",
    },
    whyItMatters: {
      type: "string",
      description: "1-2 sentences on why this matters for P&C insurance professionals",
    },
    topics: {
      type: "array",
      items: { type: "string" },
      description: "2-4 relevant topics (e.g., 'auto insurance', 'catastrophe losses', 'rate increases')",
    },
    category: {
      type: "string",
      enum: ["property", "casualty", "reinsurance", "regulation", "claims", "insurtech", "market", "litigation"],
      description: "Primary category for the article",
    },
  },
  required: ["tldr", "whyItMatters", "topics", "category"],
  additionalProperties: false,
};

/**
 * Daily brief response structure
 */
export interface DailyBriefResponse {
  executiveSummary: string[];
  topStories: Array<{
    articleId: string;
    headline: string;
    whyItMatters: string;
  }>;
  sections: {
    propertyCat: { bullets: string[]; articleIds: string[] };
    casualtyLiability: { bullets: string[]; articleIds: string[] };
    regulation: { bullets: string[]; articleIds: string[] };
    claims: { bullets: string[]; articleIds: string[] };
    reinsurance: { bullets: string[]; articleIds: string[] };
    insurtech: { bullets: string[]; articleIds: string[] };
    market: { bullets: string[]; articleIds: string[] };
  };
  topics: string[];
}

const SECTION_SCHEMA = {
  type: "object" as const,
  properties: {
    bullets: {
      type: "array",
      items: { type: "string" },
      description: "2-4 bullet points for this section",
    },
    articleIds: {
      type: "array",
      items: { type: "string" },
      description: "Article IDs related to this section",
    },
  },
  required: ["bullets", "articleIds"],
  additionalProperties: false,
};

/**
 * JSON schema for daily brief structured output
 */
export const DAILY_BRIEF_SCHEMA = {
  type: "object" as const,
  properties: {
    executiveSummary: {
      type: "array",
      items: { type: "string" },
      description: "3-5 bullet points summarizing the most important developments",
    },
    topStories: {
      type: "array",
      items: {
        type: "object",
        properties: {
          articleId: { type: "string", description: "The article ID" },
          headline: { type: "string", description: "Synthesized headline (not copied)" },
          whyItMatters: { type: "string", description: "1-2 sentences on implications" },
        },
        required: ["articleId", "headline", "whyItMatters"],
        additionalProperties: false,
      },
      description: "3-5 top stories",
    },
    sections: {
      type: "object",
      properties: {
        propertyCat: SECTION_SCHEMA,
        casualtyLiability: SECTION_SCHEMA,
        regulation: SECTION_SCHEMA,
        claims: SECTION_SCHEMA,
        reinsurance: SECTION_SCHEMA,
        insurtech: SECTION_SCHEMA,
        market: SECTION_SCHEMA,
      },
      required: ["propertyCat", "casualtyLiability", "regulation", "claims", "reinsurance", "insurtech", "market"],
      additionalProperties: false,
    },
    topics: {
      type: "array",
      items: { type: "string" },
      description: "5-10 key topics covered",
    },
  },
  required: ["executiveSummary", "topStories", "sections", "topics"],
  additionalProperties: false,
};



================================================================================
FILE: functions/src/lib/ai/prompts.ts
================================================================================
/**
 * Prompt Templates for AI Operations
 *
 * Executive brief style: concise, deterministic, P&C-focused.
 * Optimized for P&C insurance professionals including underwriters,
 * claims managers, actuaries, and C-suite executives.
 */

/**
 * System prompt for article summarization
 */
export const ARTICLE_SUMMARIZE_SYSTEM = `You are an expert P&C (Property & Casualty) insurance analyst providing executive-level intelligence to industry professionals.

Your audience includes:
- Chief Underwriting Officers and underwriters evaluating risk appetite
- Claims executives monitoring litigation trends and loss developments
- Actuaries tracking loss cost trends and reserve adequacy
- C-suite executives making strategic portfolio decisions
- Reinsurance professionals assessing capacity and pricing

CRITICAL REQUIREMENTS:

1. P&C Insurance Angle (MANDATORY):
   Every summary MUST explicitly connect to one or more P&C disciplines:
   - UNDERWRITING: Risk selection, pricing, appetite, portfolio management, loss trends
   - CLAIMS: Litigation exposure, settlement trends, reserve implications, social inflation
   - REINSURANCE: Capacity, treaty pricing, retrocession, cat bond implications
   - REGULATION: Compliance requirements, rate filing impacts, market access
   - DISTRIBUTION: Broker/MGA dynamics, channel strategy, commission structures

2. Relevance Assessment:
   - If the article is DIRECTLY relevant (core P&C topic): Provide full analysis
   - If the article is INDIRECTLY relevant (tangential impact): State clearly "Limited direct P&C relevance, but..." then explain the specific connection
   - If relevance is WEAK: whyItMatters should explicitly state "Peripheral relevance to P&C. Monitor if [specific condition]."

3. Quality Standards:
   - Be concise, precise, and actionable. Every sentence must add value.
   - Use P&C terminology correctly: combined ratio, loss ratio, rate adequacy, social inflation, nuclear verdicts, cat losses, treaty renewals, etc.
   - Quantify impacts when possible (rate changes, loss amounts, market share).
   - Identify implications for underwriting strategy, claims management, or capital allocation.
   - Note regulatory, legal, or market signals that could affect future performance.
   - Maintain professional, objective tone - no speculation without basis.

4. Exclusions:
   - Do NOT summarize generic tech/politics/business news unless there is a SPECIFIC, CLEAR P&C insurance implication.
   - General economic news requires explicit P&C linkage (e.g., interest rate → investment income → combined ratio).`;

/**
 * Build user prompt for article summarization
 */
export function buildArticleSummarizePrompt(article: {
  title: string;
  snippet: string;
  sourceName: string;
  publishedAt: string;
  url: string;
}): string {
  return `Analyze this P&C insurance news article for executive consumption:

ARTICLE:
Title: ${article.title}
Source: ${article.sourceName}
Published: ${article.publishedAt}
URL: ${article.url}

Content:
${article.snippet}

REQUIRED OUTPUT:

1. tldr: Executive summary (2-3 sentences). Lead with the key fact or development. Include specific numbers, names, or dates when available. End with the strategic implication for P&C insurers.

2. whyItMatters: Business impact statement (1-2 sentences). MUST explicitly address P&C impact:
   - STRONG relevance: Explain specific impact on underwriting, claims, reinsurance, regulation, or distribution
   - WEAK/INDIRECT relevance: Begin with "Limited direct P&C impact. " then state what to monitor and under what conditions this could become material

   Examples of weak relevance handling:
   - "Limited direct P&C impact. Monitor if proposed tariffs affect auto parts costs, which could increase claims severity in commercial auto."
   - "Limited direct P&C impact. General tech news; relevant only if carriers adopt this specific platform."

3. topics: 2-4 specific topic tags. Use industry-standard terms like:
   - Lines of business: "commercial auto", "D&O", "cyber liability", "workers comp"
   - Perils: "hurricane", "wildfire", "social inflation", "nuclear verdicts"
   - Market dynamics: "rate hardening", "capacity constraints", "M&A"
   - Regulatory: "NAIC", "state regulation", "climate disclosure"

4. category: Primary category - choose the single best fit:
   - property: Property insurance, catastrophe, nat cat, homeowners
   - casualty: Liability, auto, workers comp, professional liability
   - reinsurance: Treaty, facultative, ILS, retrocession
   - regulation: Regulatory actions, compliance, legislation
   - claims: Litigation, settlements, loss trends, reserves
   - insurtech: Technology, innovation, digital transformation
   - market: M&A, financials, earnings, market trends
   - litigation: Legal developments, court decisions, class actions`;
}

/**
 * Format brief for context
 */
export function formatBriefContext(brief: {
  executiveSummary: string[];
  topStories: Array<{ headline: string; whyItMatters: string }>;
}): string {
  const summary = brief.executiveSummary.map((s, i) => `${i + 1}. ${s}`).join("\n");
  const stories = brief.topStories
    .map((s) => `- ${s.headline}: ${s.whyItMatters}`)
    .join("\n");

  return `Executive Summary:
${summary}

Top Stories:
${stories}`;
}

/**
 * Format articles for context
 */
export function formatArticlesContext(
  articles: Array<{
    id: string;
    title: string;
    sourceName: string;
    snippet: string;
    ai?: { tldr?: string } | null;
  }>
): string {
  return articles
    .map((a) => {
      const summary = a.ai?.tldr || a.snippet;
      return `[${a.id}] ${a.title} (${a.sourceName})
${summary}`;
    })
    .join("\n\n");
}

// ============================================================================
// Daily Brief Generation
// ============================================================================

/**
 * System prompt for daily brief generation
 */
export const DAILY_BRIEF_SYSTEM = `You are a senior P&C insurance industry analyst creating the definitive daily executive brief for insurance professionals.

Your audience includes CUOs, claims executives, actuaries, reinsurance professionals, and C-suite leaders who need to stay informed on industry developments that affect their business decisions.

CRITICAL GUIDELINES:

P&C Relevance Gate (MANDATORY):
- ONLY include stories with CLEAR, DIRECT P&C insurance relevance
- Every story MUST connect to: underwriting, claims, reinsurance, regulation, or distribution
- EXCLUDE generic business/tech/political news unless there is an EXPLICIT insurance angle
- If an article discusses general economic trends, it must specify impact on: loss costs, investment income, premium growth, or reserve adequacy
- When in doubt, OMIT the story rather than stretch relevance

Insurance Angle Framing:
- Frame every development through P&C lens: "What does this mean for carriers/MGAs/brokers/reinsurers?"
- Identify which lines of business are affected (commercial auto, D&O, homeowners, etc.)
- Note implications for specific functions: underwriting appetite, claims reserves, treaty pricing

Content Quality:
- Synthesize and analyze - NEVER copy article text verbatim
- Lead with impact: What happened? Why does it matter? What should leaders consider?
- Include specific numbers, percentages, dollar amounts, and names when available
- Connect dots between related developments across articles
- Identify emerging patterns and trends

Industry Expertise:
- Use correct P&C terminology: combined ratio, loss ratio, rate adequacy, social inflation, nuclear verdicts, cat losses, treaty renewals, capacity, etc.
- Understand the difference between admitted/E&S markets, primary/excess layers, treaty/facultative reinsurance
- Recognize implications for different stakeholders (carriers, MGAs, brokers, reinsurers)

Prioritization:
- Lead with highest-impact P&C stories: major losses, significant rate actions, regulatory changes, carrier M&A
- Consider materiality: large carriers, significant market share, precedent-setting decisions
- Balance coverage across property, casualty, and specialty lines
- DEPRIORITIZE: general tech announcements, political news without insurance legislation, macroeconomic commentary

Tone:
- Executive-level professionalism
- Objective and factual - no speculation without basis
- Actionable insights over passive reporting`;

/**
 * Build user prompt for daily brief generation
 */
export function buildDailyBriefPrompt(
  date: string,
  articles: Array<{
    id: string;
    title: string;
    sourceName: string;
    snippet: string;
  }>
): string {
  const articlesText = articles
    .map((a) => `[${a.id}] ${a.title} (${a.sourceName})\n${a.snippet}`)
    .join("\n\n");

  return `Create the daily P&C insurance executive brief for ${date}.

=== SOURCE ARTICLES ===
${articlesText}

=== BRIEF STRUCTURE ===

1. executiveSummary (3-5 bullets):
   - Lead with the single most important development
   - Each bullet should be self-contained and actionable
   - Include specific details: company names, dollar amounts, percentages
   - Cover different aspects of the market (don't cluster on one topic)
   - Format: "[Key development] — [Implication for the industry]"

2. topStories (3-5 stories):
   - articleId: The source article ID (from brackets above)
   - headline: Synthesized headline that captures the strategic significance (NOT copied from article)
   - whyItMatters: 1-2 sentences explaining business impact for P&C professionals. Be specific about who is affected and how.

3. sections (2-4 bullets each, with articleIds):
   - propertyCat: Property insurance, catastrophe losses, nat cat events, homeowners, commercial property
   - casualtyLiability: Auto, GL, professional liability, workers comp, umbrella/excess
   - regulation: State/federal regulatory actions, NAIC developments, compliance requirements
   - claims: Litigation trends, settlements, reserve developments, loss cost inflation
   - reinsurance: Treaty renewals, capacity, pricing, ILS/cat bonds, retrocession
   - insurtech: Technology adoption, digital transformation, AI/ML applications, startups
   - market: M&A activity, earnings, market share, competitive dynamics, financial performance

4. topics (5-10 tags):
   - Use specific, searchable industry terms
   - Include company names for major stories
   - Include geographic regions for localized events
   - Examples: "Florida homeowners", "cyber liability", "social inflation", "1/1 renewals", "Allstate", "nuclear verdicts"

IMPORTANT: If a section has no relevant articles, return empty bullets array. Do not force content.`;
}



================================================================================
FILE: functions/src/lib/ai/rate-limit.ts
================================================================================
/**
 * Rate Limiting Utility
 *
 * Per-UID daily rate limiting using Firestore counters.
 * Relatively loose limits for MVP.
 */

import { getFirestore, FieldValue, Timestamp } from "firebase-admin/firestore";

/**
 * Rate limit configuration
 */
export const RATE_LIMITS = {
  /** Max article AI requests per user per day */
  articleAI: 50,
  /** Max askToday requests per user per day */
  askToday: 30,
} as const;

type RateLimitType = keyof typeof RATE_LIMITS;

/**
 * Get the current date key in yyyy-mm-dd format
 */
function getDateKey(): string {
  return new Date().toISOString().split("T")[0];
}

/**
 * Check and increment rate limit for a user.
 *
 * @param uid - User ID
 * @param type - Rate limit type
 * @returns Object with isAllowed and remaining count
 */
export async function checkRateLimit(
  uid: string,
  type: RateLimitType
): Promise<{ isAllowed: boolean; remaining: number; limit: number }> {
  const db = getFirestore();
  const dateKey = getDateKey();
  const limit = RATE_LIMITS[type];

  // Rate limit doc: users/{uid}/rateLimits/{date}
  const rateLimitRef = db
    .collection("users")
    .doc(uid)
    .collection("rateLimits")
    .doc(dateKey);

  // Use transaction to atomically check and increment
  const result = await db.runTransaction(async (transaction) => {
    const doc = await transaction.get(rateLimitRef);

    let counts: Record<string, number> = {};

    if (doc.exists) {
      counts = doc.data() as Record<string, number>;
    }

    const currentCount = counts[type] || 0;

    if (currentCount >= limit) {
      return {
        isAllowed: false,
        remaining: 0,
        limit,
      };
    }

    // Increment the counter
    transaction.set(
      rateLimitRef,
      {
        [type]: FieldValue.increment(1),
        updatedAt: Timestamp.now(),
      },
      { merge: true }
    );

    return {
      isAllowed: true,
      remaining: limit - currentCount - 1,
      limit,
    };
  });

  return result;
}

/**
 * Get current rate limit status without incrementing.
 *
 * @param uid - User ID
 * @param type - Rate limit type
 * @returns Object with current count and limit
 */
export async function getRateLimitStatus(
  uid: string,
  type: RateLimitType
): Promise<{ current: number; limit: number; remaining: number }> {
  const db = getFirestore();
  const dateKey = getDateKey();
  const limit = RATE_LIMITS[type];

  const rateLimitRef = db
    .collection("users")
    .doc(uid)
    .collection("rateLimits")
    .doc(dateKey);

  const doc = await rateLimitRef.get();

  if (!doc.exists) {
    return { current: 0, limit, remaining: limit };
  }

  const counts = doc.data() as Record<string, number>;
  const current = counts[type] || 0;

  return {
    current,
    limit,
    remaining: Math.max(0, limit - current),
  };
}



================================================================================
FILE: functions/src/lib/ingestion/index.ts
================================================================================
/**
 * RSS Ingestion Module Exports
 */

export {
  ingestAllEnabledSources,
  ingestSource,
  type IngestionResult,
  type IngestionSummary,
} from "./ingest.js";

export { calculateRelevance, classifyCategories } from "./relevance.js";

export { fetchRssFeed, extractImageUrl, type RssItem } from "./rss-fetcher.js";

export {
  normalizeUrl,
  sha256Hash,
  generateArticleId,
  truncateText,
  stripHtml,
} from "./url-utils.js";



================================================================================
FILE: functions/src/lib/ingestion/ingest.ts
================================================================================
/**
 * RSS Feed Ingestion Engine
 *
 * Main ingestion logic for processing RSS feeds and storing articles.
 */

import { getFirestore, Timestamp, FieldValue } from "firebase-admin/firestore";
import * as logger from "firebase-functions/logger";
import type { Source, Article, SourceFetchState } from "../../types/firestore.js";
import { fetchRssFeed, extractImageUrl, type RssItem } from "./rss-fetcher.js";
import {
  normalizeUrl,
  generateArticleId,
  truncateText,
  stripHtml,
} from "./url-utils.js";
import { calculateRelevance, classifyCategories } from "./relevance.js";

// ============================================================================
// Types
// ============================================================================

export interface IngestionResult {
  sourceId: string;
  sourceName: string;
  success: boolean;
  notModified: boolean;
  itemsFetched: number;
  itemsIngested: number;
  itemsSkipped: number;
  itemsDuplicate: number;
  /** Duration in milliseconds for this source */
  durationMs?: number;
  /** Number of feeds processed (for multi-feed sources) */
  feedsProcessed?: number;
  /** Whether results came from cache */
  cached?: boolean;
  error?: string;
}

export interface IngestionSummary {
  startedAt: Date;
  completedAt: Date;
  durationMs: number;
  sourcesProcessed: number;
  totalItemsFetched: number;
  totalItemsIngested: number;
  results: IngestionResult[];
}

// ============================================================================
// Constants
// ============================================================================

const SNIPPET_MAX_LENGTH = 200;
const MAX_ARTICLE_AGE_DAYS = 30; // Don't ingest articles older than 30 days

// ============================================================================
// Main Ingestion Function
// ============================================================================

/**
 * Ingest articles from all enabled sources.
 *
 * @param options - Ingestion options
 * @returns Summary of ingestion results
 */
export async function ingestAllEnabledSources(options?: {
  maxAgeDays?: number;
  forceRefresh?: boolean;
}): Promise<IngestionSummary> {
  const startedAt = new Date();
  const db = getFirestore();
  const maxAgeDays = options?.maxAgeDays ?? MAX_ARTICLE_AGE_DAYS;

  // Fetch all enabled sources
  const sourcesSnap = await db
    .collection("sources")
    .where("enabled", "==", true)
    .get();

  const sources = sourcesSnap.docs.map(
    (doc) => ({ id: doc.id, ...doc.data() }) as Source
  );

  logger.info("Starting RSS ingestion", {
    sourcesCount: sources.length,
    maxAgeDays,
    forceRefresh: options?.forceRefresh ?? false,
  });

  const results: IngestionResult[] = [];

  for (const source of sources) {
    const sourceStartTime = Date.now();
    const result = await ingestSource(source, { maxAgeDays });
    result.durationMs = Date.now() - sourceStartTime;
    results.push(result);

    // Log progress with structured data
    if (result.success) {
      if (result.notModified) {
        logger.debug("Source not modified", {
          sourceId: source.id,
          sourceName: source.name,
        });
      } else {
        logger.info("Source ingested", {
          sourceId: source.id,
          sourceName: source.name,
          itemsFetched: result.itemsFetched,
          itemsIngested: result.itemsIngested,
          itemsSkipped: result.itemsSkipped,
          itemsDuplicate: result.itemsDuplicate,
          feedsProcessed: result.feedsProcessed,
          cached: result.cached,
          durationMs: result.durationMs,
        });
      }
    } else {
      logger.error("Source ingestion failed", {
        sourceId: source.id,
        sourceName: source.name,
        error: result.error,
      });
    }
  }

  const completedAt = new Date();
  const totalDurationMs = completedAt.getTime() - startedAt.getTime();

  // Log final summary
  const summary: IngestionSummary = {
    startedAt,
    completedAt,
    durationMs: totalDurationMs,
    sourcesProcessed: sources.length,
    totalItemsFetched: results.reduce((sum, r) => sum + r.itemsFetched, 0),
    totalItemsIngested: results.reduce((sum, r) => sum + r.itemsIngested, 0),
    results,
  };

  logger.info("Ingestion completed", {
    durationMs: totalDurationMs,
    sourcesProcessed: sources.length,
    totalItemsFetched: summary.totalItemsFetched,
    totalItemsIngested: summary.totalItemsIngested,
    successCount: results.filter((r) => r.success).length,
    failureCount: results.filter((r) => !r.success).length,
  });

  return summary;
}

/**
 * Ingest articles from a single source.
 * Supports multiple RSS URLs per source.
 */
export async function ingestSource(
  source: Source,
  options?: { maxAgeDays?: number }
): Promise<IngestionResult> {
  const maxAgeDays = options?.maxAgeDays ?? MAX_ARTICLE_AGE_DAYS;
  const cutoffDate = new Date();
  cutoffDate.setDate(cutoffDate.getDate() - maxAgeDays);

  const result: IngestionResult = {
    sourceId: source.id,
    sourceName: source.name,
    success: false,
    notModified: false,
    itemsFetched: 0,
    itemsIngested: 0,
    itemsSkipped: 0,
    itemsDuplicate: 0,
    feedsProcessed: 0,
    cached: false,
  };

  // Get all RSS URLs for this source (support both single and multiple)
  const rssUrls = source.rssUrls?.length ? source.rssUrls : [source.rssUrl];
  const isMultiFeed = rssUrls.length > 1;

  let allNotModified = true;
  let anySuccess = false;
  let anyCached = false;
  const feedErrors: string[] = [];

  try {
    for (const rssUrl of rssUrls) {
      // Get the fetch state for this specific URL
      const fetchState = isMultiFeed
        ? source.fetchStates?.[rssUrl] ?? getDefaultFetchState()
        : source.fetchState;

      // Fetch the RSS feed
      const fetchResult = await fetchRssFeed(rssUrl, fetchState);

      if (!fetchResult.success) {
        feedErrors.push(`${rssUrl}: ${fetchResult.error}`);
        // Update fetch state for this URL
        if (isMultiFeed) {
          await updateSourceFetchStateForUrl(source.id, rssUrl, fetchResult.newFetchState);
        } else {
          await updateSourceFetchState(source.id, fetchResult.newFetchState);
        }
        continue;
      }

      // Track metadata
      result.feedsProcessed = (result.feedsProcessed ?? 0) + 1;
      if (fetchResult.cached) {
        anyCached = true;
      }

      // Track if any feed was not "not modified"
      if (!fetchResult.notModified) {
        allNotModified = false;
      }

      anySuccess = true;
      result.itemsFetched += fetchResult.items.length;

      // Process each item
      for (const item of fetchResult.items) {
        const itemResult = await processRssItem(item, source, cutoffDate);

        if (itemResult === "ingested") result.itemsIngested++;
        else if (itemResult === "skipped") result.itemsSkipped++;
        else if (itemResult === "duplicate") result.itemsDuplicate++;
      }

      // Update fetch state for this URL (skip for cached results)
      if (!fetchResult.cached) {
        if (isMultiFeed) {
          await updateSourceFetchStateForUrl(source.id, rssUrl, fetchResult.newFetchState);
        } else {
          await updateSourceFetchState(source.id, fetchResult.newFetchState);
        }
      }
    }

    // Determine overall result
    result.success = anySuccess;
    result.notModified = allNotModified && anySuccess;
    result.cached = anyCached;

    if (feedErrors.length > 0 && feedErrors.length < rssUrls.length) {
      // Partial failure
      result.error = `Partial failure: ${feedErrors.join("; ")}`;
    } else if (feedErrors.length === rssUrls.length) {
      // Complete failure
      result.success = false;
      result.error = feedErrors.join("; ");
    }

    return result;
  } catch (error) {
    result.error = error instanceof Error ? error.message : "Unknown error";
    return result;
  }
}

/**
 * Get default fetch state for new feeds
 */
function getDefaultFetchState(): SourceFetchState {
  return {
    etag: null,
    lastModified: null,
    lastFetchedAt: null,
    lastError: null,
  };
}

// ============================================================================
// Helper Functions
// ============================================================================

type ProcessResult = "ingested" | "skipped" | "duplicate";

/**
 * Process a single RSS item and store if relevant.
 */
async function processRssItem(
  item: RssItem,
  source: Source,
  cutoffDate: Date
): Promise<ProcessResult> {
  const db = getFirestore();

  // Skip items without required fields
  if (!item.link || !item.title) {
    return "skipped";
  }

  // Parse publication date
  const pubDateStr = item.isoDate || item.pubDate;
  if (!pubDateStr) {
    return "skipped";
  }

  const pubDate = new Date(pubDateStr);
  if (isNaN(pubDate.getTime())) {
    return "skipped";
  }

  // Skip articles older than cutoff
  if (pubDate < cutoffDate) {
    return "skipped";
  }

  // Generate article ID from canonical URL
  const canonicalUrl = normalizeUrl(item.link);
  const articleId = generateArticleId(item.link);

  // Check if article already exists
  const existingDoc = await db.collection("articles").doc(articleId).get();
  if (existingDoc.exists) {
    return "duplicate";
  }

  // Extract and clean snippet
  const rawSnippet =
    item.contentSnippet || item.summary || item.description || item.content || "";
  const snippet = truncateText(stripHtml(rawSnippet), SNIPPET_MAX_LENGTH);

  // Calculate relevance
  const relevance = calculateRelevance(item.title, snippet, source.tags);

  // Classify into categories (uses keyword matching, falls back to source tags)
  const categories = classifyCategories(item.title, snippet, source.tags);

  // Extract image URL
  const imageUrl = extractImageUrl(item);

  // Build article document
  const article: Omit<Article, "id"> = {
    sourceId: source.id,
    sourceName: source.name,
    title: item.title.trim(),
    snippet,
    url: item.link,
    canonicalUrl,
    guid: item.guid || null,
    imageUrl,
    categories,
    publishedAt: Timestamp.fromDate(pubDate),
    ingestedAt: Timestamp.now(),
    relevanceScore: relevance.score,
    isRelevant: relevance.isRelevant,
    ai: null,
  };

  // Store in Firestore
  await db.collection("articles").doc(articleId).set({
    id: articleId,
    ...article,
  });

  return "ingested";
}

/**
 * Update source fetch state in Firestore (single feed).
 */
async function updateSourceFetchState(
  sourceId: string,
  newFetchState: Record<string, unknown>
): Promise<void> {
  const db = getFirestore();

  // Replace null lastFetchedAt with server timestamp
  const updates: Record<string, unknown> = {
    "fetchState.lastError": newFetchState.lastError ?? null,
    "fetchState.lastFetchedAt": FieldValue.serverTimestamp(),
    updatedAt: FieldValue.serverTimestamp(),
  };

  if (newFetchState.etag !== undefined) {
    updates["fetchState.etag"] = newFetchState.etag;
  }
  if (newFetchState.lastModified !== undefined) {
    updates["fetchState.lastModified"] = newFetchState.lastModified;
  }

  await db.collection("sources").doc(sourceId).update(updates);
}

/**
 * Create a safe key for a URL to use in Firestore field paths.
 * Uses a simple hash to avoid special characters.
 */
function urlToSafeKey(url: string): string {
  // Create a simple hash from the URL
  let hash = 0;
  for (let i = 0; i < url.length; i++) {
    const char = url.charCodeAt(i);
    hash = ((hash << 5) - hash) + char;
    hash = hash & hash; // Convert to 32bit integer
  }
  // Return a safe alphanumeric key
  return `feed_${Math.abs(hash).toString(36)}`;
}

/**
 * Update fetch state for a specific RSS URL in a multi-feed source.
 * Uses a hash of the URL as the key to avoid Firestore field path issues.
 */
async function updateSourceFetchStateForUrl(
  sourceId: string,
  rssUrl: string,
  newFetchState: Record<string, unknown>
): Promise<void> {
  const db = getFirestore();

  // Use a safe key derived from the URL
  const safeKey = urlToSafeKey(rssUrl);

  const updates: Record<string, unknown> = {
    [`fetchStates.${safeKey}.url`]: rssUrl,
    [`fetchStates.${safeKey}.lastError`]: newFetchState.lastError ?? null,
    [`fetchStates.${safeKey}.lastFetchedAt`]: FieldValue.serverTimestamp(),
    [`fetchStates.${safeKey}.etag`]: newFetchState.etag ?? null,
    [`fetchStates.${safeKey}.lastModified`]: newFetchState.lastModified ?? null,
    updatedAt: FieldValue.serverTimestamp(),
  };

  await db.collection("sources").doc(sourceId).update(updates);
}



================================================================================
FILE: functions/src/lib/ingestion/relevance.ts
================================================================================
/**
 * P&C Insurance Relevance Filtering & Category Classification
 *
 * Keyword-based heuristic filter and classifier.
 * Excludes life/health insurance content.
 * Maps articles to P&C categories: Property, Casualty, Regulation, Claims, Reinsurance, Technology
 */

import type { SourceCategory } from "../../types/firestore.js";

// ============================================================================
// Category-Specific Keywords (for classification)
// ============================================================================

const CATEGORY_KEYWORDS: Record<SourceCategory, string[]> = {
  property_cat: [
    "property insurance", "homeowners", "commercial property", "fire insurance",
    "flood insurance", "hurricane", "catastrophe", "cat loss", "nat cat",
    "wildfire", "earthquake", "windstorm", "hail damage", "property damage",
    "builders risk", "inland marine", "ocean marine", "cargo insurance",
    "boiler and machinery", "equipment breakdown", "habitational", "dwelling",
    "commercial real estate", "building coverage", "business interruption",
    "parametric", "named storm", "wind damage", "water damage", "fire loss",
  ],
  casualty_liability: [
    "casualty", "liability", "general liability", "professional liability",
    "errors and omissions", "e&o", "d&o", "directors and officers",
    "workers compensation", "workers comp", "auto insurance", "commercial auto",
    "motor insurance", "product liability", "umbrella", "excess liability",
    "cyber insurance", "cyber liability", "data breach", "ransomware",
    "epli", "employment practices", "fiduciary liability", "crime insurance",
    "fidelity bond", "kidnap and ransom", "personal injury", "bodily injury",
    "third party", "vicarious liability", "negligence", "tort",
  ],
  regulation: [
    "regulation", "regulatory", "naic", "state insurance", "insurance regulation",
    "insurance commissioner", "surplus lines", "admitted", "non-admitted",
    "rate adequacy", "rate filing", "residual market", "fair plan",
    "citizens property", "legislation", "compliance", "mandate", "statute",
    "regulatory approval", "department of insurance", "insurance department",
    "market conduct", "consumer protection", "licensing", "solvency regulation",
  ],
  claims: [
    "claims", "claim management", "loss adjustment", "adjuster", "subrogation",
    "settlement", "reserve", "loss ratio", "loss development",
    "incurred but not reported", "ibnr", "case reserves", "adverse development",
    "reserve strengthening", "claims handling", "litigation", "lawsuit",
    "verdict", "claimant", "first notice of loss", "fnol",
  ],
  reinsurance: [
    "reinsurance", "retrocession", "treaty", "facultative", "cat bond",
    "catastrophe bond", "ils", "insurance-linked securities", "sidecar",
    "collateralized reinsurance", "quota share", "excess of loss",
    "aggregate cover", "1/1 renewals", "monte carlo", "risk transfer",
    "ceding", "ceded", "assumed", "retro", "reinstatement",
  ],
  insurtech: [
    "insurtech", "technology", "artificial intelligence", "ai", "machine learning",
    "automation", "digital transformation", "telematics", "iot", "blockchain",
    "smart contract", "digital claims", "api", "platform", "startup",
    "innovation", "tech", "software", "saas", "data analytics",
    "predictive analytics", "modeling", "parametric", "embedded insurance",
  ],
};

// ============================================================================
// P&C Positive Keywords (boost relevance) - Combined from all categories
// ============================================================================

const PC_KEYWORDS = [
  // Property
  "property insurance",
  "homeowners",
  "commercial property",
  "fire insurance",
  "flood insurance",
  "hurricane",
  "catastrophe",
  "cat loss",
  "nat cat",
  "wildfire",
  "earthquake",
  "windstorm",
  "hail damage",
  "property damage",
  "builders risk",
  "inland marine",
  "ocean marine",
  "cargo insurance",
  "boiler and machinery",
  "equipment breakdown",

  // Casualty / Liability
  "casualty",
  "liability",
  "general liability",
  "professional liability",
  "errors and omissions",
  "e&o",
  "d&o",
  "directors and officers",
  "workers compensation",
  "workers comp",
  "auto insurance",
  "commercial auto",
  "motor insurance",
  "product liability",
  "umbrella",
  "excess liability",
  "cyber insurance",
  "cyber liability",
  "data breach",
  "ransomware",
  "epli",
  "employment practices",
  "fiduciary liability",
  "crime insurance",
  "fidelity bond",
  "kidnap and ransom",

  // Social Inflation / Litigation Trends
  "social inflation",
  "nuclear verdict",
  "litigation funding",
  "third-party litigation",
  "class action",
  "mass tort",
  "mdl",
  "reptile theory",
  "punitive damages",
  "jury verdict",
  "bellwether trial",

  // Climate / ESG
  "climate risk",
  "climate change",
  "transition risk",
  "physical risk",
  "esg",
  "sustainability",
  "carbon footprint",
  "greenwashing",
  "climate disclosure",
  "adaptation",
  "resilience",

  // Reinsurance
  "reinsurance",
  "retrocession",
  "treaty",
  "facultative",
  "cat bond",
  "catastrophe bond",
  "ils",
  "insurance-linked securities",
  "sidecar",
  "collateralized reinsurance",
  "quota share",
  "excess of loss",
  "aggregate cover",
  "1/1 renewals",
  "monte carlo",
  "risk transfer",

  // Claims
  "claims",
  "loss adjustment",
  "subrogation",
  "litigation",
  "settlement",
  "reserve",
  "loss ratio",
  "combined ratio",
  "loss development",
  "incurred but not reported",
  "ibnr",
  "case reserves",
  "adverse development",
  "reserve strengthening",

  // Market / Regulation
  "underwriting",
  "premium",
  "rate increase",
  "hard market",
  "soft market",
  "capacity",
  "naic",
  "state insurance",
  "insurance regulation",
  "insurance commissioner",
  "surplus lines",
  "admitted",
  "non-admitted",
  "mga",
  "managing general agent",
  "rate adequacy",
  "loss cost",
  "rate filing",
  "residual market",
  "fair plan",
  "citizens property",

  // Industry / Market
  "p&c",
  "property and casualty",
  "commercial lines",
  "personal lines",
  "insurance carrier",
  "insurer",
  "policyholder",
  "m&a",
  "merger",
  "acquisition",
  "ipo",
  "earnings",
  "combined ratio",
  "return on equity",
  "book value",
  "statutory surplus",
  "am best",
  "s&p rating",
  "moody's rating",
  "fitch rating",
  "solvency",
  "rbc",
  "risk-based capital",

  // Major Carriers (high signal)
  "state farm",
  "allstate",
  "liberty mutual",
  "travelers",
  "chubb",
  "aig",
  "hartford",
  "progressive",
  "geico",
  "nationwide",
  "farmers",
  "usaa",
  "erie insurance",
  "cincinnati financial",
  "hanover",
  "cna",
  "zurich",
  "axa xl",
  "swiss re",
  "munich re",
  "berkshire hathaway",
  "markel",
  "w. r. berkley",
  "arch capital",
  "renaissancere",
  "everest re",
  "lloyd's",
];

// ============================================================================
// Exclusion Keywords (reduce relevance - life/health focus)
// ============================================================================

const EXCLUSION_KEYWORDS = [
  "life insurance",
  "term life",
  "whole life",
  "universal life",
  "health insurance",
  "health plan",
  "medicare",
  "medicaid",
  "obamacare",
  "aca",
  "affordable care act",
  "dental insurance",
  "vision insurance",
  "disability insurance",
  "long-term care",
  "annuity",
  "annuities",
  "retirement plan",
  "401k",
  "pension",
];

// ============================================================================
// Relevance Scoring
// ============================================================================

interface RelevanceResult {
  score: number;
  isRelevant: boolean;
  matchedKeywords: string[];
  excludedKeywords: string[];
}

/**
 * Calculate P&C relevance score for an article.
 *
 * @param title - Article title
 * @param snippet - Article snippet/description
 * @param sourceCategories - Categories from the source
 * @returns Relevance result with score (0-1) and isRelevant flag
 */
export function calculateRelevance(
  title: string,
  snippet: string,
  sourceCategories: SourceCategory[] = []
): RelevanceResult {
  const text = `${title} ${snippet}`.toLowerCase();

  // Check for exclusion keywords
  const excludedKeywords = EXCLUSION_KEYWORDS.filter((kw) =>
    text.includes(kw.toLowerCase())
  );

  // Check for P&C keywords
  const matchedKeywords = PC_KEYWORDS.filter((kw) =>
    text.includes(kw.toLowerCase())
  );

  // Calculate base score
  let score = 0;

  // Start with source category boost (reputable P&C sources)
  if (sourceCategories.length > 0) {
    score += 0.3;
  }

  // Add points for matched P&C keywords (diminishing returns)
  const keywordBoost = Math.min(matchedKeywords.length * 0.15, 0.6);
  score += keywordBoost;

  // Penalty for exclusion keywords
  const exclusionPenalty = Math.min(excludedKeywords.length * 0.3, 0.8);
  score -= exclusionPenalty;

  // Clamp score between 0 and 1
  score = Math.max(0, Math.min(1, score));

  // Threshold for relevance
  const isRelevant = score >= 0.25 && excludedKeywords.length === 0;

  return {
    score: Math.round(score * 100) / 100,
    isRelevant,
    matchedKeywords,
    excludedKeywords,
  };
}

// ============================================================================
// Category Classification
// ============================================================================

interface CategoryScore {
  category: SourceCategory;
  score: number;
  matchedKeywords: string[];
}

/**
 * Classify article into P&C categories based on keyword matching.
 * Returns categories sorted by relevance score.
 *
 * @param title - Article title
 * @param snippet - Article snippet/description
 * @param sourceCategories - Categories from the source (used as fallback)
 * @returns Array of matched categories sorted by score
 */
export function classifyCategories(
  title: string,
  snippet: string,
  sourceCategories: SourceCategory[] = []
): SourceCategory[] {
  const text = `${title} ${snippet}`.toLowerCase();
  const scores: CategoryScore[] = [];

  // Score each category
  for (const [category, keywords] of Object.entries(CATEGORY_KEYWORDS)) {
    const matched = keywords.filter((kw) => text.includes(kw.toLowerCase()));
    if (matched.length > 0) {
      scores.push({
        category: category as SourceCategory,
        score: matched.length,
        matchedKeywords: matched,
      });
    }
  }

  // Sort by score descending
  scores.sort((a, b) => b.score - a.score);

  // Get top categories (at least 1 match)
  const inferredCategories = scores.map((s) => s.category);

  // If no categories matched, fall back to source categories
  if (inferredCategories.length === 0) {
    return sourceCategories;
  }

  // Merge with source categories, prioritizing inferred
  const mergedCategories = [...new Set([...inferredCategories, ...sourceCategories])];

  // Limit to top 3 categories
  return mergedCategories.slice(0, 3);
}



================================================================================
FILE: functions/src/lib/ingestion/rss-fetcher.ts
================================================================================
/**
 * RSS Feed Fetcher with Conditional GET Support and Caching
 *
 * Uses ETag/Last-Modified headers to minimize bandwidth.
 * Implements in-memory caching to avoid redundant fetches.
 */

import Parser from "rss-parser";
import type { SourceFetchState } from "../../types/firestore.js";

// ============================================================================
// Types
// ============================================================================

export interface RssItem {
  title: string;
  link: string;
  guid?: string;
  pubDate?: string;
  isoDate?: string;
  contentSnippet?: string;
  content?: string;
  summary?: string;
  description?: string;
  creator?: string;
  categories?: string[];
  enclosure?: {
    url?: string;
    type?: string;
  };
  "media:content"?: {
    $?: { url?: string };
  };
  "media:thumbnail"?: {
    $?: { url?: string };
  };
}

export interface FetchResult {
  success: boolean;
  notModified: boolean;
  items: RssItem[];
  newFetchState: Partial<SourceFetchState>;
  error?: string;
  cached?: boolean;
}

// ============================================================================
// Feed Cache (in-memory, per-function-invocation)
// ============================================================================

interface CachedFeed {
  items: RssItem[];
  fetchState: Partial<SourceFetchState>;
  cachedAt: number;
}

// Cache TTL: 15 minutes (reduces redundant fetches within same ingestion run)
const CACHE_TTL_MS = 15 * 60 * 1000;
const feedCache = new Map<string, CachedFeed>();

/**
 * Clear expired entries from the cache
 */
function cleanExpiredCache(): void {
  const now = Date.now();
  for (const [url, cached] of feedCache.entries()) {
    if (now - cached.cachedAt > CACHE_TTL_MS) {
      feedCache.delete(url);
    }
  }
}

/**
 * Get cached feed if available and not expired
 */
function getCachedFeed(url: string): CachedFeed | null {
  const cached = feedCache.get(url);
  if (!cached) return null;

  const age = Date.now() - cached.cachedAt;
  if (age > CACHE_TTL_MS) {
    feedCache.delete(url);
    return null;
  }

  return cached;
}

/**
 * Store feed in cache
 */
function setCachedFeed(url: string, items: RssItem[], fetchState: Partial<SourceFetchState>): void {
  // Clean up old entries periodically
  if (feedCache.size > 50) {
    cleanExpiredCache();
  }

  feedCache.set(url, {
    items,
    fetchState,
    cachedAt: Date.now(),
  });
}

// ============================================================================
// RSS Parser Instance
// ============================================================================

const parser = new Parser({
  timeout: 30000, // 30 second timeout
  headers: {
    "User-Agent": "InsuranceNewsAI/1.0 (+https://insurance-news-ai.web.app)",
    Accept: "application/rss+xml, application/xml, text/xml",
  },
  customFields: {
    item: [
      ["media:content", "media:content"],
      ["media:thumbnail", "media:thumbnail"],
    ],
  },
});

// ============================================================================
// Fetch Functions
// ============================================================================

/**
 * Fetch RSS feed with conditional GET support and caching.
 *
 * @param feedUrl - The RSS feed URL
 * @param fetchState - Previous fetch state with ETag/Last-Modified
 * @param options - Fetch options
 * @returns FetchResult with items and new fetch state
 */
export async function fetchRssFeed(
  feedUrl: string,
  fetchState: SourceFetchState,
  options?: { skipCache?: boolean }
): Promise<FetchResult> {
  try {
    // Check cache first (unless explicitly skipped)
    if (!options?.skipCache) {
      const cached = getCachedFeed(feedUrl);
      if (cached) {
        return {
          success: true,
          notModified: false,
          items: cached.items,
          newFetchState: cached.fetchState,
          cached: true,
        };
      }
    }

    // Build conditional request headers
    const headers: Record<string, string> = {
      "User-Agent": "InsuranceNewsAI/1.0 (+https://insurance-news-ai.web.app)",
      Accept: "application/rss+xml, application/xml, text/xml",
    };

    if (fetchState.etag) {
      headers["If-None-Match"] = fetchState.etag;
    }
    if (fetchState.lastModified) {
      headers["If-Modified-Since"] = fetchState.lastModified;
    }

    // Fetch the feed
    const response = await fetch(feedUrl, {
      method: "GET",
      headers,
    });

    // Handle 304 Not Modified
    if (response.status === 304) {
      return {
        success: true,
        notModified: true,
        items: [],
        newFetchState: {
          lastFetchedAt: null, // Will be set to serverTimestamp by caller
          lastError: null,
        },
      };
    }

    // Handle non-success status
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    }

    // Parse the feed
    const feedText = await response.text();
    const feed = await parser.parseString(feedText);

    // Extract new fetch state from headers
    const newEtag = response.headers.get("etag");
    const newLastModified = response.headers.get("last-modified");

    const newFetchState = {
      etag: newEtag || fetchState.etag,
      lastModified: newLastModified || fetchState.lastModified,
      lastFetchedAt: null, // Will be set to serverTimestamp by caller
      lastError: null,
    };

    const items = feed.items as RssItem[];

    // Cache the result
    setCachedFeed(feedUrl, items, newFetchState);

    return {
      success: true,
      notModified: false,
      items,
      newFetchState,
    };
  } catch (error) {
    const errorMessage =
      error instanceof Error ? error.message : "Unknown error";

    return {
      success: false,
      notModified: false,
      items: [],
      newFetchState: {
        lastFetchedAt: null,
        lastError: errorMessage,
      },
      error: errorMessage,
    };
  }
}

/**
 * Extract image URL from RSS item.
 * Checks multiple possible locations for image.
 */
export function extractImageUrl(item: RssItem): string | null {
  // Check enclosure (common for images)
  if (item.enclosure?.url && item.enclosure.type?.startsWith("image/")) {
    return item.enclosure.url;
  }

  // Check media:content
  if (item["media:content"]?.$?.url) {
    return item["media:content"].$.url;
  }

  // Check media:thumbnail
  if (item["media:thumbnail"]?.$?.url) {
    return item["media:thumbnail"].$.url;
  }

  return null;
}



================================================================================
FILE: functions/src/lib/ingestion/url-utils.ts
================================================================================
/**
 * URL Normalization and Hashing Utilities
 *
 * Used for article deduplication via canonical URL hashing.
 */

import { createHash } from "crypto";

/**
 * Normalize a URL for deduplication.
 * - Lowercase hostname
 * - Remove tracking parameters (utm_*, fbclid, etc.)
 * - Remove trailing slashes
 * - Sort query parameters
 * - Remove fragments
 */
export function normalizeUrl(url: string): string {
  try {
    const parsed = new URL(url);

    // Lowercase hostname
    parsed.hostname = parsed.hostname.toLowerCase();

    // Remove common tracking parameters
    const trackingParams = [
      "utm_source",
      "utm_medium",
      "utm_campaign",
      "utm_term",
      "utm_content",
      "fbclid",
      "gclid",
      "ref",
      "source",
    ];

    trackingParams.forEach((param) => {
      parsed.searchParams.delete(param);
    });

    // Sort query params for consistency
    parsed.searchParams.sort();

    // Remove fragment
    parsed.hash = "";

    // Build normalized URL
    let normalized = `${parsed.protocol}//${parsed.hostname}`;

    // Add port if non-standard
    if (
      parsed.port &&
      !(parsed.protocol === "https:" && parsed.port === "443") &&
      !(parsed.protocol === "http:" && parsed.port === "80")
    ) {
      normalized += `:${parsed.port}`;
    }

    // Add path (remove trailing slash unless root)
    let path = parsed.pathname;
    if (path.length > 1 && path.endsWith("/")) {
      path = path.slice(0, -1);
    }
    normalized += path;

    // Add query string if present
    const queryString = parsed.searchParams.toString();
    if (queryString) {
      normalized += `?${queryString}`;
    }

    return normalized;
  } catch {
    // If URL parsing fails, return original trimmed
    return url.trim().toLowerCase();
  }
}

/**
 * Generate SHA256 hash of a string.
 * Returns first 16 characters for compact storage.
 */
export function sha256Hash(input: string): string {
  return createHash("sha256").update(input).digest("hex").substring(0, 16);
}

/**
 * Generate article ID from URL.
 * Uses SHA256 hash of normalized URL for deduplication.
 */
export function generateArticleId(url: string): string {
  const normalizedUrl = normalizeUrl(url);
  return sha256Hash(normalizedUrl);
}

/**
 * Generate fallback article ID from GUID.
 */
export function generateArticleIdFromGuid(guid: string): string {
  return sha256Hash(guid);
}

/**
 * Truncate text to a maximum length, respecting word boundaries.
 */
export function truncateText(
  text: string,
  maxLength: number,
  suffix = "..."
): string {
  if (!text) return "";

  const trimmed = text.trim();
  if (trimmed.length <= maxLength) return trimmed;

  // Find last space before maxLength
  const truncated = trimmed.substring(0, maxLength - suffix.length);
  const lastSpace = truncated.lastIndexOf(" ");

  if (lastSpace > maxLength * 0.6) {
    return truncated.substring(0, lastSpace) + suffix;
  }

  return truncated + suffix;
}

/**
 * Extract clean text from potentially HTML content.
 * Removes HTML tags and decodes entities.
 */
export function stripHtml(html: string): string {
  if (!html) return "";

  return html
    .replace(/<[^>]*>/g, "") // Remove HTML tags
    .replace(/&nbsp;/gi, " ")
    .replace(/&amp;/gi, "&")
    .replace(/&lt;/gi, "<")
    .replace(/&gt;/gi, ">")
    .replace(/&quot;/gi, "\"")
    .replace(/&#39;/gi, "'")
    .replace(/\s+/g, " ") // Normalize whitespace
    .trim();
}



================================================================================
FILE: functions/src/lib/notifications/index.ts
================================================================================
/**
 * Push Notifications Service
 *
 * Handles sending FCM notifications to users with registered push tokens.
 * Batches notifications for efficiency and handles token cleanup.
 */

import { getMessaging, type Messaging } from "firebase-admin/messaging";
import { getFirestore, type Firestore } from "firebase-admin/firestore";

// Lazy initialization to avoid calling before Firebase is initialized
let _db: Firestore | null = null;
let _messaging: Messaging | null = null;

function getDb(): Firestore {
  if (!_db) {
    _db = getFirestore();
  }
  return _db;
}

function getMessagingInstance(): Messaging {
  if (!_messaging) {
    _messaging = getMessaging();
  }
  return _messaging;
}

// Maximum tokens per multicast message (FCM limit is 500)
const BATCH_SIZE = 500;

interface PushToken {
  token: string;
  platform: "ios" | "web";
}

interface NotificationPayload {
  title: string;
  body: string;
  data?: Record<string, string>;
}

/**
 * Get all push tokens for users who have daily brief notifications enabled
 */
async function getOptedInTokens(): Promise<{ uid: string; tokens: PushToken[] }[]> {
  const usersWithTokens: { uid: string; tokens: PushToken[] }[] = [];

  // Get all users who have dailyBrief notifications enabled
  const usersSnap = await getDb().collectionGroup("prefs").get();

  for (const prefDoc of usersSnap.docs) {
    const prefs = prefDoc.data();

    // Check if daily brief notifications are enabled (default is true)
    const dailyBriefEnabled = prefs.notifications?.dailyBrief !== false;

    if (!dailyBriefEnabled) {
      continue;
    }

    // Get the user ID from the path: users/{uid}/prefs/main
    const uid = prefDoc.ref.parent.parent?.id;
    if (!uid) continue;

    // Get all push tokens for this user
    const tokensSnap = await getDb().collection(`users/${uid}/pushTokens`).get();

    if (!tokensSnap.empty) {
      const tokens = tokensSnap.docs.map((doc) => ({
        token: doc.data().token as string,
        platform: doc.data().platform as "ios" | "web",
      }));
      usersWithTokens.push({ uid, tokens });
    }
  }

  return usersWithTokens;
}

/**
 * Send a notification to all opted-in users
 * Batches tokens for efficient sending and cleans up invalid tokens
 */
export async function sendNotificationToOptedInUsers(
  payload: NotificationPayload
): Promise<{ sent: number; failed: number; cleaned: number }> {
  console.log("[notifications] Starting notification send...");

  const usersWithTokens = await getOptedInTokens();
  const allTokens: { token: string; uid: string }[] = [];

  // Flatten all tokens with their user IDs
  for (const user of usersWithTokens) {
    for (const t of user.tokens) {
      allTokens.push({ token: t.token, uid: user.uid });
    }
  }

  console.log(`[notifications] Found ${allTokens.length} tokens from ${usersWithTokens.length} users`);

  if (allTokens.length === 0) {
    return { sent: 0, failed: 0, cleaned: 0 };
  }

  let sent = 0;
  let failed = 0;
  let cleaned = 0;

  // Process in batches
  for (let i = 0; i < allTokens.length; i += BATCH_SIZE) {
    const batch = allTokens.slice(i, i + BATCH_SIZE);
    const tokens = batch.map((t) => t.token);

    try {
      const response = await getMessagingInstance().sendEachForMulticast({
        tokens,
        notification: {
          title: payload.title,
          body: payload.body,
        },
        data: payload.data,
        apns: {
          payload: {
            aps: {
              sound: "default",
              badge: 1,
            },
          },
        },
        webpush: {
          notification: {
            icon: "/pwa-192x192.png",
          },
        },
      });

      sent += response.successCount;
      failed += response.failureCount;

      // Clean up invalid tokens
      for (let j = 0; j < response.responses.length; j++) {
        if (!response.responses[j].success) {
          const error = response.responses[j].error;
          // Remove invalid tokens (unregistered, invalid, etc.)
          if (
            error?.code === "messaging/invalid-registration-token" ||
            error?.code === "messaging/registration-token-not-registered"
          ) {
            const { token, uid } = batch[j];
            await getDb().doc(`users/${uid}/pushTokens/${token}`).delete();
            cleaned++;
            console.log(`[notifications] Cleaned invalid token for user ${uid}`);
          }
        }
      }
    } catch (error) {
      console.error("[notifications] Batch send error:", error);
      failed += batch.length;
    }
  }

  console.log(`[notifications] Complete: ${sent} sent, ${failed} failed, ${cleaned} cleaned`);
  return { sent, failed, cleaned };
}

/**
 * Format date for notification body (e.g., "February 8")
 */
export function formatDateForNotification(dateKey: string): string {
  const [year, month, day] = dateKey.split("-").map(Number);
  const date = new Date(year, month - 1, day);
  return date.toLocaleDateString("en-US", { month: "long", day: "numeric" });
}



================================================================================
FILE: functions/src/scripts/backfill-and-brief.ts
================================================================================
/**
 * Backfill and Generate Brief Script
 *
 * One-time admin command to:
 * 1. Backfill articles from the last 7 days
 * 2. Generate today's daily brief
 *
 * Run with:
 *   cd functions
 *   npm run build
 *   GOOGLE_APPLICATION_CREDENTIALS=/path/to/service-account.json node lib/scripts/backfill-and-brief.js
 *
 * Or with default credentials (if running on GCP or with gcloud auth):
 *   node lib/scripts/backfill-and-brief.js
 *
 * Safety:
 * - Articles are deduplicated by canonical URL hash (safe to re-run)
 * - Brief generation skips if brief already exists for today
 */

import { initializeApp, getApps } from "firebase-admin/app";
import { getFirestore, Timestamp } from "firebase-admin/firestore";
import OpenAI from "openai";
import { ingestAllEnabledSources } from "../lib/ingestion/index.js";
import {
  AI_MODEL,
  DAILY_BRIEF_SCHEMA,
  DAILY_BRIEF_SYSTEM,
  buildDailyBriefPrompt,
  type DailyBriefResponse,
} from "../lib/ai/index.js";
import type { Article, Brief } from "../types/firestore.js";

// Initialize Firebase Admin if not already initialized
if (getApps().length === 0) {
  initializeApp();
}

const db = getFirestore();

// ============================================================================
// Helper Functions
// ============================================================================

function getTodayDateET(): string {
  const now = new Date();
  const formatter = new Intl.DateTimeFormat("en-CA", {
    timeZone: "America/New_York",
    year: "numeric",
    month: "2-digit",
    day: "2-digit",
  });
  return formatter.format(now);
}

// ============================================================================
// Main Script
// ============================================================================

async function main(): Promise<void> {
  console.log("🚀 Starting backfill and brief generation...\n");

  // Step 1: Backfill last 7 days
  console.log("📥 Step 1: Backfilling articles from last 7 days...\n");

  const ingestionSummary = await ingestAllEnabledSources({
    maxAgeDays: 7,
    forceRefresh: true,
  });

  console.log("\n=== Ingestion Summary ===");
  console.log(`Duration: ${ingestionSummary.durationMs}ms`);
  console.log(`Sources processed: ${ingestionSummary.sourcesProcessed}`);
  console.log(`Total items fetched: ${ingestionSummary.totalItemsFetched}`);
  console.log(`Total items ingested: ${ingestionSummary.totalItemsIngested}`);

  for (const r of ingestionSummary.results) {
    const status = r.success ? "✅" : "❌";
    console.log(
      `  ${status} ${r.sourceName}: ${r.itemsIngested} new, ${r.itemsDuplicate} duplicates`
    );
    if (r.error) console.log(`     Error: ${r.error}`);
  }

  // Step 2: Generate today's brief
  console.log("\n📝 Step 2: Generating today's brief...\n");

  const dateKey = getTodayDateET();
  const briefRef = db.collection("briefs").doc(dateKey);
  const existingBrief = await briefRef.get();

  if (existingBrief.exists) {
    console.log(`⏭️  Brief already exists for ${dateKey}, skipping generation.`);
    console.log("\n✅ Backfill complete! Brief was already generated.");
    return;
  }

  // Check for OpenAI API key
  const openaiApiKey = process.env.OPENAI_API_KEY;
  if (!openaiApiKey) {
    console.log("⚠️  OPENAI_API_KEY not set. Skipping brief generation.");
    console.log("   Set it with: export OPENAI_API_KEY=your-key");
    console.log("\n✅ Backfill complete! Run brief generation separately.");
    return;
  }

  // Fetch articles from last 36 hours
  const cutoffTime = new Date(Date.now() - 36 * 60 * 60 * 1000);
  const articlesSnap = await db
    .collection("articles")
    .where("isRelevant", "==", true)
    .where("publishedAt", ">=", Timestamp.fromDate(cutoffTime))
    .orderBy("publishedAt", "desc")
    .limit(60)
    .get();

  if (articlesSnap.empty) {
    console.log(`⚠️  No relevant articles found for ${dateKey}`);
    console.log("\n✅ Backfill complete! No articles to generate brief from.");
    return;
  }

  console.log(`Found ${articlesSnap.size} articles for brief generation`);

  // Prepare article data
  const articles = articlesSnap.docs.map((doc) => {
    const data = doc.data() as Article;
    return {
      id: doc.id,
      title: data.title,
      sourceName: data.sourceName,
      sourceId: data.sourceId,
      snippet: data.snippet,
    };
  });

  // Build sources map
  const sourceMap = new Map<string, string>();
  articles.forEach((a) => {
    if (!sourceMap.has(a.sourceId)) {
      sourceMap.set(a.sourceId, a.sourceName);
    }
  });

  // Generate brief using OpenAI
  console.log("Calling OpenAI to generate brief...");

  const openai = new OpenAI({ apiKey: openaiApiKey });
  const prompt = buildDailyBriefPrompt(dateKey, articles);

  const response = await openai.responses.create({
    model: AI_MODEL,
    input: [
      { role: "system", content: DAILY_BRIEF_SYSTEM },
      { role: "user", content: prompt },
    ],
    text: {
      format: {
        type: "json_schema",
        name: "daily_brief",
        schema: DAILY_BRIEF_SCHEMA,
        strict: true,
      },
    },
  });

  const briefData = JSON.parse(response.output_text) as DailyBriefResponse;

  // Build the brief document
  const brief: Brief = {
    date: dateKey,
    createdAt: Timestamp.now(),
    executiveSummary: briefData.executiveSummary,
    topStories: briefData.topStories,
    sections: briefData.sections,
    topics: briefData.topics,
    sourcesUsed: Array.from(sourceMap.entries()).map(([sourceId, name]) => ({
      sourceId,
      name,
    })),
    sourceArticleIds: articles.map((a) => a.id),
    model: AI_MODEL,
  };

  // Save to Firestore
  await briefRef.set(brief);

  console.log(`\n✅ Brief created for ${dateKey}!`);
  console.log(`   - ${brief.executiveSummary.length} summary items`);
  console.log(`   - ${brief.topStories.length} top stories`);
  console.log(`   - ${brief.topics.length} topics`);
  console.log(`   - ${brief.sourceArticleIds.length} source articles`);

  console.log("\n🎉 Backfill and brief generation complete!");
}

// ============================================================================
// Run
// ============================================================================

main()
  .then(() => {
    process.exit(0);
  })
  .catch((error) => {
    console.error("\n❌ Error:", error);
    process.exit(1);
  });



================================================================================
FILE: functions/src/scripts/check-data.ts
================================================================================
/**
 * Check Data Script
 * Verifies the production data is ready
 */

import { initializeApp, getApps } from "firebase-admin/app";
import { getFirestore } from "firebase-admin/firestore";

if (getApps().length === 0) {
  initializeApp();
}

const db = getFirestore();

async function main(): Promise<void> {
  console.log("🔍 Checking production data...\n");

  // Check sources
  const sources = await db.collection("sources").get();
  console.log("=== SOURCES ===");
  let enabledCount = 0;
  sources.forEach((doc) => {
    const d = doc.data();
    if (d.enabled) enabledCount++;
    const lastFetched = d.lastFetchedAt?.toDate?.()?.toISOString() || "never";
    console.log(`  ${d.enabled ? "✅" : "⏸️ "} ${d.name} (lastFetched: ${lastFetched})`);
  });
  console.log(`  Total: ${sources.size} sources (${enabledCount} enabled)\n`);

  // Check articles count
  const articlesCount = await db.collection("articles").count().get();
  console.log(`=== ARTICLES: ${articlesCount.data().count} total ===`);

  // Check recent articles
  const recentArticles = await db
    .collection("articles")
    .orderBy("publishedAt", "desc")
    .limit(5)
    .get();
  console.log("Recent articles:");
  recentArticles.forEach((doc) => {
    const d = doc.data();
    const title = d.title?.substring(0, 55) || "No title";
    const date = d.publishedAt?.toDate?.()?.toISOString()?.split("T")[0] || "unknown";
    console.log(`  - ${title}... (${date})`);
  });

  // Check briefs
  const briefs = await db.collection("briefs").orderBy("date", "desc").limit(5).get();
  console.log(`\n=== BRIEFS: ${briefs.size} found ===`);
  briefs.forEach((doc) => {
    const d = doc.data();
    console.log(
      `  - ${doc.id}: ${d.topStories?.length || 0} top stories, ${d.executiveSummary?.length || 0} summary items`
    );
  });

  // Summary
  console.log("\n=== PRODUCTION READINESS ===");
  const issues: string[] = [];

  if (sources.size === 0) issues.push("❌ No sources configured");
  else if (enabledCount === 0) issues.push("❌ No sources enabled");

  if (articlesCount.data().count === 0) issues.push("❌ No articles ingested");
  else if (articlesCount.data().count < 10) issues.push("⚠️  Only " + articlesCount.data().count + " articles");

  if (briefs.size === 0) issues.push("❌ No briefs generated");

  if (issues.length === 0) {
    console.log("✅ All systems ready for production!");
  } else {
    issues.forEach((i) => console.log(i));
  }
}

main()
  .then(() => process.exit(0))
  .catch((e) => {
    console.error("Error:", e);
    process.exit(1);
  });



================================================================================
FILE: functions/src/scripts/regenerate-brief.ts
================================================================================
/**
 * Regenerate Brief Script
 * Deletes existing brief and regenerates with current articles
 */

import { initializeApp, getApps } from "firebase-admin/app";
import { getFirestore, Timestamp } from "firebase-admin/firestore";
import OpenAI from "openai";
import {
  AI_MODEL,
  DAILY_BRIEF_SCHEMA,
  DAILY_BRIEF_SYSTEM,
  buildDailyBriefPrompt,
  type DailyBriefResponse,
} from "../lib/ai/index.js";
import type { Article, Brief } from "../types/firestore.js";

if (getApps().length === 0) {
  initializeApp();
}

const db = getFirestore();

function getTodayDateET(): string {
  const now = new Date();
  const formatter = new Intl.DateTimeFormat("en-CA", {
    timeZone: "America/New_York",
    year: "numeric",
    month: "2-digit",
    day: "2-digit",
  });
  return formatter.format(now);
}

async function main(): Promise<void> {
  const dateKey = process.argv[2] || getTodayDateET();
  console.log(`🔄 Regenerating brief for ${dateKey}...\n`);

  const openaiApiKey = process.env.OPENAI_API_KEY;
  if (!openaiApiKey) {
    console.error("❌ OPENAI_API_KEY not set");
    process.exit(1);
  }

  // Delete existing brief
  const briefRef = db.collection("briefs").doc(dateKey);
  const existing = await briefRef.get();
  if (existing.exists) {
    console.log("🗑️  Deleting existing brief...");
    await briefRef.delete();
  }

  // Fetch articles from last 7 days (more generous window)
  const cutoffTime = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000);
  
  // First try with isRelevant filter
  let articlesSnap = await db
    .collection("articles")
    .where("isRelevant", "==", true)
    .where("publishedAt", ">=", Timestamp.fromDate(cutoffTime))
    .orderBy("publishedAt", "desc")
    .limit(60)
    .get();

  // If not enough relevant articles, get all articles
  if (articlesSnap.size < 10) {
    console.log(`⚠️  Only ${articlesSnap.size} relevant articles, fetching all articles...`);
    articlesSnap = await db
      .collection("articles")
      .where("publishedAt", ">=", Timestamp.fromDate(cutoffTime))
      .orderBy("publishedAt", "desc")
      .limit(60)
      .get();
  }

  console.log(`📰 Found ${articlesSnap.size} articles for brief generation`);

  if (articlesSnap.empty) {
    console.log("❌ No articles found");
    return;
  }

  // Prepare article data
  const articles = articlesSnap.docs.map((doc) => {
    const data = doc.data() as Article;
    return {
      id: doc.id,
      title: data.title,
      sourceName: data.sourceName,
      sourceId: data.sourceId,
      snippet: data.snippet,
    };
  });

  // Build sources map
  const sourceMap = new Map<string, string>();
  articles.forEach((a) => {
    if (!sourceMap.has(a.sourceId)) {
      sourceMap.set(a.sourceId, a.sourceName);
    }
  });

  // Generate brief using OpenAI
  console.log("🤖 Calling OpenAI to generate brief...");

  const openai = new OpenAI({ apiKey: openaiApiKey });
  const prompt = buildDailyBriefPrompt(dateKey, articles);

  const response = await openai.responses.create({
    model: AI_MODEL,
    input: [
      { role: "system", content: DAILY_BRIEF_SYSTEM },
      { role: "user", content: prompt },
    ],
    text: {
      format: {
        type: "json_schema",
        name: "daily_brief",
        schema: DAILY_BRIEF_SCHEMA,
        strict: true,
      },
    },
  });

  const briefData = JSON.parse(response.output_text) as DailyBriefResponse;

  // Build the brief document
  const brief: Brief = {
    date: dateKey,
    createdAt: Timestamp.now(),
    executiveSummary: briefData.executiveSummary,
    topStories: briefData.topStories,
    sections: briefData.sections,
    topics: briefData.topics,
    sourcesUsed: Array.from(sourceMap.entries()).map(([sourceId, name]) => ({
      sourceId,
      name,
    })),
    sourceArticleIds: articles.map((a) => a.id),
    model: AI_MODEL,
  };

  // Save to Firestore
  await briefRef.set(brief);

  console.log(`\n✅ Brief regenerated for ${dateKey}!`);
  console.log(`   - ${brief.executiveSummary.length} summary items`);
  console.log(`   - ${brief.topStories.length} top stories`);
  console.log(`   - ${brief.topics.length} topics`);
  console.log(`   - ${brief.sourceArticleIds.length} source articles`);
}

main()
  .then(() => process.exit(0))
  .catch((e) => {
    console.error("Error:", e);
    process.exit(1);
  });



================================================================================
FILE: functions/src/scripts/seed-sources.ts
================================================================================
/**
 * Seed Initial Sources Script
 *
 * Run with: npx ts-node src/scripts/seed-sources.ts
 * Or after build: node lib/scripts/seed-sources.js
 *
 * This script upserts the initial reputable sources into Firestore.
 * It uses the Firebase Admin SDK and requires GOOGLE_APPLICATION_CREDENTIALS
 * or running in a Firebase environment.
 */

import { initializeApp, getApps } from "firebase-admin/app";
import { getFirestore, Timestamp } from "firebase-admin/firestore";
import type { SourceCategory } from "../types/firestore.js";

// Initialize Firebase Admin if not already initialized
if (getApps().length === 0) {
  // In production, uses GOOGLE_APPLICATION_CREDENTIALS or default credentials
  // For local dev, you can set GOOGLE_APPLICATION_CREDENTIALS to a service account key
  initializeApp();
}

const db = getFirestore();

// ============================================================================
// Source Definitions
// ============================================================================

interface SourceSeed {
  id: string;
  name: string;
  siteUrl: string;
  rssUrl: string;
  rssUrls?: string[];
  enabled: boolean;
  enabledByDefault: boolean;
  tags: SourceCategory[];
  region?: string;
}

const REPUTABLE_SOURCES: SourceSeed[] = [
  // === ORIGINAL SOURCES ===
  {
    id: "insurance-journal",
    name: "Insurance Journal",
    siteUrl: "https://www.insurancejournal.com",
    rssUrl: "https://www.insurancejournal.com/rss/news/",
    enabled: true,
    enabledByDefault: true,
    tags: ["property_cat", "casualty_liability", "regulation", "claims"],
  },
  {
    id: "claims-journal",
    name: "Claims Journal",
    siteUrl: "https://www.claimsjournal.com",
    rssUrl: "https://www.claimsjournal.com/rss/news/",
    enabled: true,
    enabledByDefault: true,
    tags: ["claims", "casualty_liability"],
  },
  {
    id: "artemis",
    name: "Artemis",
    siteUrl: "https://www.artemis.bm",
    rssUrl: "https://www.artemis.bm/feed/",
    enabled: true,
    enabledByDefault: true,
    tags: ["reinsurance", "property_cat"],
  },
  // === NEW SOURCES ===
  {
    id: "carrier-management",
    name: "Carrier Management",
    siteUrl: "https://www.carriermanagement.com",
    rssUrl: "https://www.carriermanagement.com/feed",
    enabled: true,
    enabledByDefault: true,
    tags: ["property_cat", "claims", "insurtech", "reinsurance"],
  },
  {
    id: "business-insurance",
    name: "Business Insurance",
    siteUrl: "https://www.businessinsurance.com",
    rssUrl: "https://www.businessinsurance.com/section/rss?feed=NEWS",
    rssUrls: [
      "https://www.businessinsurance.com/section/rss?feed=NEWS",
      "https://www.businessinsurance.com/section/rss?feed=NEWS06",
      "https://www.businessinsurance.com/section/rss?feed=NEWS08",
      "https://www.businessinsurance.com/section/rss?feed=GLOBAL",
    ],
    enabled: false, // Disabled: RSS feeds return 403 Forbidden
    enabledByDefault: false,
    tags: ["property_cat", "casualty_liability", "regulation"],
  },
  {
    id: "insurance-business-us",
    name: "Insurance Business (US)",
    siteUrl: "https://www.insurancebusinessmag.com/us/",
    rssUrl: "https://www.insurancebusinessmag.com/us/rss",
    enabled: true,
    enabledByDefault: true,
    tags: ["property_cat", "casualty_liability", "regulation"],
  },
  {
    id: "risk-and-insurance",
    name: "Risk & Insurance",
    siteUrl: "https://riskandinsurance.com",
    rssUrl: "https://riskandinsurance.com/feed",
    enabled: true,
    enabledByDefault: true,
    tags: ["claims", "insurtech"],
  },
];

// Optional sources - disabled by default
const OPTIONAL_SOURCES: SourceSeed[] = [
  {
    id: "canadian-underwriter",
    name: "Canadian Underwriter",
    siteUrl: "https://www.canadianunderwriter.ca",
    rssUrl: "https://www.canadianunderwriter.ca/news/feed",
    rssUrls: [
      "https://www.canadianunderwriter.ca/news/feed",
      "https://www.canadianunderwriter.ca/global-category/property/feed",
    ],
    enabled: false,
    enabledByDefault: false,
    tags: ["property_cat", "claims"],
    region: "Canada",
  },
  {
    id: "leaders-edge",
    name: "Leader's Edge",
    siteUrl: "https://www.leadersedge.com",
    rssUrl: "https://www.leadersedge.com/category/p-c/feed",
    enabled: false,
    enabledByDefault: false,
    tags: ["property_cat", "casualty_liability"],
  },
];

// ============================================================================
// Seed Function
// ============================================================================

async function seedSources(): Promise<void> {
  console.log("🌱 Starting source seeding...\n");

  const now = Timestamp.now();
  const allSources = [...REPUTABLE_SOURCES, ...OPTIONAL_SOURCES];

  const defaultFetchState = {
    etag: null,
    lastModified: null,
    lastFetchedAt: null,
    lastError: null,
  };

  for (const seed of allSources) {
    const docRef = db.collection("sources").doc(seed.id);
    const existing = await docRef.get();
    const existingData = existing.exists ? existing.data() : null;

    // Build fetchStates for multi-feed sources
    const rssUrlsToUse = seed.rssUrls ?? [seed.rssUrl];
    let fetchStates: Record<string, typeof defaultFetchState> | undefined;
    if (rssUrlsToUse.length > 1) {
      fetchStates = (existingData?.fetchStates as Record<string, typeof defaultFetchState>) ?? {};
      for (const url of rssUrlsToUse) {
        if (!fetchStates![url]) {
          fetchStates![url] = { ...defaultFetchState };
        }
      }
    }

    // Build source data, omitting undefined fields
    const sourceData: Record<string, unknown> = {
      name: seed.name,
      siteUrl: seed.siteUrl,
      rssUrl: seed.rssUrl,
      enabled: seed.enabled,
      enabledByDefault: seed.enabledByDefault,
      tier: "reputable",
      tags: seed.tags,
      createdAt: existingData?.createdAt ?? now,
      updatedAt: now,
      fetchState: existingData?.fetchState ?? defaultFetchState,
    };

    // Only add optional fields if they have values
    if (seed.rssUrls) {
      sourceData.rssUrls = seed.rssUrls;
    }
    if (seed.region) {
      sourceData.region = seed.region;
    }
    if (fetchStates) {
      sourceData.fetchStates = fetchStates;
    }

    await docRef.set({ id: seed.id, ...sourceData }, { merge: true });

    const status = existing.exists ? "updated" : "created";
    const enabledStatus = seed.enabled ? "✅ enabled" : "⏸️  disabled";
    const feedCount = rssUrlsToUse.length > 1 ? ` (${rssUrlsToUse.length} feeds)` : "";
    console.log(`  ${enabledStatus} ${seed.name}${feedCount} (${status})`);
  }

  console.log(`\n✨ Seeded ${allSources.length} sources successfully!`);
}

// ============================================================================
// Main
// ============================================================================

seedSources()
  .then(() => {
    console.log("\n🎉 Done!");
    process.exit(0);
  })
  .catch((error) => {
    console.error("\n❌ Error seeding sources:", error);
    process.exit(1);
  });



================================================================================
FILE: functions/src/scripts/show-brief.ts
================================================================================
/**
 * Show Brief Script
 * Displays the current brief content
 */

import { initializeApp, getApps } from "firebase-admin/app";
import { getFirestore } from "firebase-admin/firestore";

if (getApps().length === 0) {
  initializeApp();
}

const db = getFirestore();

function getTodayDateET(): string {
  const now = new Date();
  const formatter = new Intl.DateTimeFormat("en-CA", {
    timeZone: "America/New_York",
    year: "numeric",
    month: "2-digit",
    day: "2-digit",
  });
  return formatter.format(now);
}

async function main(): Promise<void> {
  const dateKey = process.argv[2] || getTodayDateET();
  console.log(`📋 Brief for ${dateKey}\n`);

  const briefDoc = await db.collection("briefs").doc(dateKey).get();

  if (!briefDoc.exists) {
    console.log("❌ No brief found for this date");
    return;
  }

  const brief = briefDoc.data()!;

  console.log("=== EXECUTIVE SUMMARY ===");
  brief.executiveSummary?.forEach((item: string, i: number) => {
    console.log(`  ${i + 1}. ${item}`);
  });

  console.log("\n=== TOP STORIES ===");
  brief.topStories?.forEach((story: { headline: string; whyItMatters: string }, i: number) => {
    console.log(`  ${i + 1}. ${story.headline}`);
    console.log(`     → ${story.whyItMatters}`);
  });

  console.log("\n=== SECTIONS ===");
  const sections = brief.sections || {};
  for (const [key, section] of Object.entries(sections)) {
    const s = section as { bullets: string[]; articleIds: string[] };
    if (s.bullets?.length > 0) {
      console.log(`  ${key}: ${s.bullets.length} bullets, ${s.articleIds?.length || 0} articles`);
    }
  }

  console.log("\n=== TOPICS ===");
  console.log(`  ${brief.topics?.join(", ") || "None"}`);

  console.log("\n=== METADATA ===");
  console.log(`  Model: ${brief.model}`);
  console.log(`  Sources used: ${brief.sourcesUsed?.length || 0}`);
  console.log(`  Source articles: ${brief.sourceArticleIds?.length || 0}`);
}

main()
  .then(() => process.exit(0))
  .catch((e) => {
    console.error("Error:", e);
    process.exit(1);
  });



================================================================================
FILE: functions/src/scripts/test-ingestion.ts
================================================================================
/**
 * Test Ingestion Script
 *
 * Run with: npx ts-node src/scripts/test-ingestion.ts
 * Or after build: node lib/scripts/test-ingestion.js
 */

import { initializeApp, getApps } from "firebase-admin/app";
import { ingestAllEnabledSources } from "../lib/ingestion/index.js";

// Initialize Firebase Admin if not already initialized
if (getApps().length === 0) {
  initializeApp();
}

async function testIngestion(): Promise<void> {
  console.log("🚀 Testing ingestion with 7-day lookback...\n");

  const summary = await ingestAllEnabledSources({ maxAgeDays: 7 });

  console.log("\n=== Ingestion Summary ===");
  console.log("Duration:", summary.durationMs, "ms");
  console.log("Sources processed:", summary.sourcesProcessed);
  console.log("Total items fetched:", summary.totalItemsFetched);
  console.log("Total items ingested:", summary.totalItemsIngested);

  console.log("\n=== Per-Source Results ===");
  for (const r of summary.results) {
    console.log(`\n${r.sourceName}:`);
    console.log("  Success:", r.success);
    if (r.notModified) {
      console.log("  Status: Not Modified (304)");
    } else {
      console.log("  Items fetched:", r.itemsFetched);
      console.log("  Items ingested:", r.itemsIngested);
      console.log("  Items skipped:", r.itemsSkipped);
      console.log("  Duplicates:", r.itemsDuplicate);
    }
    if (r.error) console.log("  Error:", r.error);
  }

  console.log("\n✅ Ingestion test complete!");
}

testIngestion()
  .then(() => process.exit(0))
  .catch((e) => {
    console.error("❌ Error:", e);
    process.exit(1);
  });



================================================================================
FILE: functions/src/types/firestore.ts
================================================================================
/**
 * Firestore Document Types for P&C Insurance News AI (Cloud Functions)
 *
 * Collections:
 * - sources/{sourceId}
 * - articles/{articleId}
 * - briefs/{yyyy-mm-dd}
 * - users/{uid}
 *   - bookmarks/{articleId}
 *   - prefs/main
 */

import type { Timestamp } from "firebase-admin/firestore";

// ============================================================================
// Sources Collection: sources/{sourceId}
// ============================================================================

export type SourceCategory =
  | "property_cat"
  | "casualty_liability"
  | "regulation"
  | "claims"
  | "reinsurance"
  | "insurtech";

/** Source tier indicating trustworthiness/quality */
export type SourceTier = "reputable" | "community" | "user-submitted";

/** Fetch state for conditional RSS requests */
export interface SourceFetchState {
  /** ETag from last fetch (for conditional requests) */
  etag: string | null;
  /** Last-Modified header from last fetch */
  lastModified: string | null;
  /** Last successful fetch timestamp */
  lastFetchedAt: Timestamp | null;
  /** Last fetch error message (null if successful) */
  lastError: string | null;
}

export interface Source {
  /** Unique identifier (slug-style, e.g., "insurance-journal") */
  id: string;
  /** Display name */
  name: string;
  /** Publisher website URL */
  siteUrl: string;
  /** RSS feed URL (legacy single-feed) */
  rssUrl: string;
  /** RSS feed URLs (supports multiple feeds per source) */
  rssUrls?: string[];
  /** Whether this source is enabled for ingestion */
  enabled: boolean;
  /** Whether this source is enabled by default for new users */
  enabledByDefault?: boolean;
  /** Source tier indicating trustworthiness */
  tier: SourceTier;
  /** Tags for categorization and filtering */
  tags: SourceCategory[];
  /** Region/geography focus (optional) */
  region?: string;
  /** Created timestamp */
  createdAt: Timestamp;
  /** Updated timestamp */
  updatedAt: Timestamp;
  /** Fetch state for conditional requests (keyed by rssUrl for multi-feed) */
  fetchState: SourceFetchState;
  /** Fetch states per RSS URL (for multi-feed sources) */
  fetchStates?: Record<string, SourceFetchState>;
}

// ============================================================================
// Articles Collection: articles/{articleId}
// ============================================================================

export interface Article {
  /** Unique identifier (SHA256 hash of canonical URL or GUID) */
  id: string;
  /** Source ID reference */
  sourceId: string;
  /** Source display name (denormalized for display) */
  sourceName: string;
  /** Article headline/title */
  title: string;
  /** Short snippet/excerpt (≤200 chars, respecting publisher policies) */
  snippet: string;
  /** Original article URL */
  url: string;
  /** Normalized canonical URL (for deduplication) */
  canonicalUrl: string;
  /** RSS GUID if available (fallback for deduplication) */
  guid: string | null;
  /** Article image URL if present in RSS */
  imageUrl: string | null;
  /** Article categories */
  categories: SourceCategory[];
  /** Publication timestamp */
  publishedAt: Timestamp;
  /** When we ingested this article */
  ingestedAt: Timestamp;
  /** P&C relevance score (0-1) from heuristic filter */
  relevanceScore: number;
  /** Whether article passes P&C relevance filter */
  isRelevant: boolean;
  /** AI-generated content (cached, generated on first request) */
  ai: ArticleAI | null;
}

/**
 * AI-generated article content
 */
export interface ArticleAI {
  /** 2-3 sentence executive summary */
  tldr: string;
  /** Why this matters for P&C professionals */
  whyItMatters: string;
  /** 2-4 relevant topic tags */
  topics: string[];
  /** Primary category */
  category: "property" | "casualty" | "reinsurance" | "regulation" | "claims" | "insurtech" | "market" | "litigation";
  /** When AI content was generated */
  generatedAt: Timestamp;
  /** Model used for generation */
  model: string;
}

// ============================================================================
// Briefs Collection: briefs/{yyyy-mm-dd}
// ============================================================================

export interface BriefTopStory {
  /** Article ID reference */
  articleId: string;
  /** Article headline (synthesized, not copied) */
  headline: string;
  /** Why this story matters for P&C professionals */
  whyItMatters: string;
}

export interface BriefSection {
  /** Section bullets (2-4 items) */
  bullets: string[];
  /** Related article IDs */
  articleIds: string[];
}

export interface BriefSourceUsed {
  /** Source ID */
  sourceId: string;
  /** Source display name */
  name: string;
}

export interface Brief {
  /** Date in yyyy-mm-dd format */
  date: string;
  /** When this brief was created */
  createdAt: Timestamp;
  /** Executive summary bullets (3-5 items) */
  executiveSummary: string[];
  /** Top stories with "why it matters" */
  topStories: BriefTopStory[];
  /** Category sections */
  sections: {
    propertyCat: BriefSection;
    casualtyLiability: BriefSection;
    regulation: BriefSection;
    claims: BriefSection;
    reinsurance: BriefSection;
    insurtech: BriefSection;
    market: BriefSection;
  };
  /** Key topics covered */
  topics: string[];
  /** Sources used to generate this brief */
  sourcesUsed: BriefSourceUsed[];
  /** Article IDs used to generate this brief (for grounded chat) */
  sourceArticleIds: string[];
  /** Model used for generation */
  model: string;
}

// ============================================================================
// Users Collection: users/{uid}
// ============================================================================

export interface UserProfile {
  /** User's Firebase UID */
  uid: string;
  /** Email address */
  email: string | null;
  /** Display name */
  displayName: string | null;
  /** Account created timestamp */
  createdAt: Timestamp;
  /** Last login timestamp */
  lastLoginAt: Timestamp;
}

// ============================================================================
// User Bookmarks Subcollection: users/{uid}/bookmarks/{articleId}
// ============================================================================

export interface Bookmark {
  /** Article ID (same as document ID) */
  articleId: string;
  /** Article title (denormalized for display) */
  title: string;
  /** Source name (denormalized) */
  sourceName: string;
  /** Article URL */
  url: string;
  /** When bookmarked */
  bookmarkedAt: Timestamp;
}

// ============================================================================
// User Preferences Subcollection: users/{uid}/prefs/main
// ============================================================================

export interface UserPreferences {
  /** Source IDs the user has enabled */
  enabledSourceIds: string[];
  /** Categories the user wants to see */
  enabledCategories: SourceCategory[];
  /** Notification preferences */
  notifications: {
    dailyBrief: boolean;
    breakingNews: boolean;
  };
  /** Last updated timestamp */
  updatedAt: Timestamp;
}



================================================================================
FILE: functions/src/types/index.ts
================================================================================
/**
 * Type exports for P&C Insurance News AI (Cloud Functions)
 */

export type {
  // Source types
  Source,
  SourceCategory,
  SourceTier,
  SourceFetchState,
  // Article types
  Article,
  ArticleAI,
  // Brief types
  Brief,
  BriefTopStory,
  BriefSection,
  BriefSourceUsed,
  // User types
  UserProfile,
  Bookmark,
  UserPreferences,
} from "./firestore.js";




################################################################################
# UTILITY SCRIPTS (scripts/)
################################################################################

================================================================================
FILE: scripts/generate-code-review.sh
================================================================================
#!/bin/bash
# Generate a single file containing all frontend and backend code for AI code review
# Output: code-review.txt in the project root

OUTPUT_FILE="code-review.txt"
PROJECT_ROOT="$(cd "$(dirname "$0")/.." && pwd)"

cd "$PROJECT_ROOT"

# Clear/create output file
echo "# P&C Insurance News AI - Full Codebase for Review" > "$OUTPUT_FILE"
echo "# Generated: $(date)" >> "$OUTPUT_FILE"
echo "# =============================================" >> "$OUTPUT_FILE"
echo "" >> "$OUTPUT_FILE"

# Function to add a file to the output
add_file() {
    local filepath="$1"
    if [ -f "$filepath" ]; then
        echo "" >> "$OUTPUT_FILE"
        echo "=================================================================================" >> "$OUTPUT_FILE"
        echo "FILE: $filepath" >> "$OUTPUT_FILE"
        echo "=================================================================================" >> "$OUTPUT_FILE"
        echo "" >> "$OUTPUT_FILE"
        cat "$filepath" >> "$OUTPUT_FILE"
        echo "" >> "$OUTPUT_FILE"
    fi
}

# Add project config files
echo "## PROJECT CONFIGURATION" >> "$OUTPUT_FILE"
add_file "package.json"
add_file "tsconfig.json"
add_file "vite.config.ts"
add_file "tailwind.config.js"
add_file "firebase.json"
add_file "firestore.rules"
add_file "firestore.indexes.json"

# Add frontend source files
echo "" >> "$OUTPUT_FILE"
echo "## FRONTEND SOURCE CODE" >> "$OUTPUT_FILE"

# Find all TypeScript/TSX files in src directory
find src -type f \( -name "*.ts" -o -name "*.tsx" \) | sort | while read -r file; do
    add_file "$file"
done

# Add CSS files
find src -type f -name "*.css" | sort | while read -r file; do
    add_file "$file"
done

# Add index.html
add_file "index.html"

# Add backend/functions source files
echo "" >> "$OUTPUT_FILE"
echo "## BACKEND (CLOUD FUNCTIONS) SOURCE CODE" >> "$OUTPUT_FILE"

add_file "functions/package.json"
add_file "functions/tsconfig.json"

# Find all TypeScript files in functions/src directory
find functions/src -type f -name "*.ts" | sort | while read -r file; do
    add_file "$file"
done

# Summary
echo "" >> "$OUTPUT_FILE"
echo "=================================================================================" >> "$OUTPUT_FILE"
echo "END OF CODEBASE" >> "$OUTPUT_FILE"
echo "=================================================================================" >> "$OUTPUT_FILE"

# Count files and lines
FILE_COUNT=$(grep -c "^FILE:" "$OUTPUT_FILE")
LINE_COUNT=$(wc -l < "$OUTPUT_FILE")

echo "✅ Generated $OUTPUT_FILE"
echo "   - $FILE_COUNT files included"
echo "   - $LINE_COUNT total lines"



================================================================================
FILE: scripts/get-vapid-key.mjs
================================================================================
#!/usr/bin/env node
/**
 * Get VAPID Key from Firebase
 * 
 * Uses the Firebase CLI's stored credentials to make authenticated API calls
 * to retrieve the web push certificate (VAPID key) from Firebase.
 */

import { readFileSync, writeFileSync, existsSync } from 'fs';
import { homedir } from 'os';
import { join } from 'path';
import https from 'https';

const PROJECT_ID = 'insurance-news-ai';
const WEB_APP_ID = '1:695640024145:web:ab17c496e14b3d915ac470';

// Read Firebase CLI credentials
function getFirebaseCredentials() {
  const configPath = join(homedir(), '.config', 'configstore', 'firebase-tools.json');
  
  if (!existsSync(configPath)) {
    console.error('Firebase CLI not configured. Run: npx firebase login');
    return null;
  }
  
  const config = JSON.parse(readFileSync(configPath, 'utf-8'));
  return config.tokens;
}

// Refresh access token if needed
async function refreshAccessToken(refreshToken) {
  return new Promise((resolve, reject) => {
    const data = new URLSearchParams({
      client_id: '563584335869-fgrhgmd47bqnekij5i8b5pr03ho849e6.apps.googleusercontent.com',
      client_secret: 'j9iVZfS8kkCEFUPaAeJV0sAi',
      refresh_token: refreshToken,
      grant_type: 'refresh_token'
    }).toString();

    const options = {
      hostname: 'oauth2.googleapis.com',
      path: '/token',
      method: 'POST',
      headers: {
        'Content-Type': 'application/x-www-form-urlencoded',
        'Content-Length': data.length
      }
    };

    const req = https.request(options, (res) => {
      let body = '';
      res.on('data', chunk => body += chunk);
      res.on('end', () => {
        try {
          const result = JSON.parse(body);
          resolve(result.access_token);
        } catch (e) {
          reject(new Error('Failed to parse token response'));
        }
      });
    });

    req.on('error', reject);
    req.write(data);
    req.end();
  });
}

// Make authenticated API request
function apiRequest(accessToken, path) {
  return new Promise((resolve, reject) => {
    const options = {
      hostname: 'fcmregistrations.googleapis.com',
      path: path,
      method: 'GET',
      headers: {
        'Authorization': `Bearer ${accessToken}`,
        'Content-Type': 'application/json'
      }
    };

    const req = https.request(options, (res) => {
      let body = '';
      res.on('data', chunk => body += chunk);
      res.on('end', () => resolve({ status: res.statusCode, body }));
    });

    req.on('error', reject);
    req.end();
  });
}

// Generic API request helper
function makeRequest(hostname, path, accessToken, method = 'GET', body = null) {
  return new Promise((resolve, reject) => {
    const options = {
      hostname,
      path,
      method,
      headers: {
        'Authorization': `Bearer ${accessToken}`,
        'Content-Type': 'application/json'
      }
    };

    const req = https.request(options, (res) => {
      let data = '';
      res.on('data', chunk => data += chunk);
      res.on('end', () => resolve({ status: res.statusCode, body: data }));
    });

    req.on('error', reject);
    if (body) req.write(JSON.stringify(body));
    req.end();
  });
}

// Get FCM sender ID config
async function getFcmConfig(accessToken) {
  // Try the GCM/FCM sender endpoint
  const result = await makeRequest(
    'fcm.googleapis.com',
    `/v1/projects/${PROJECT_ID}/messages:send`,
    accessToken,
    'POST',
    { validate_only: true, message: { topic: 'test' } }
  );
  return result;
}

// Get web push certificates from Identity Toolkit
async function getWebPushCerts(accessToken) {
  // The web push certificates are stored in the project's FCM settings
  // We can access them via the Firebase Management API
  const result = await makeRequest(
    'firebase.googleapis.com',
    `/v1beta1/projects/${PROJECT_ID}`,
    accessToken
  );
  return result;
}

// Create a web push certificate
async function createWebPushCert(accessToken) {
  // Generate VAPID keys locally since Firebase doesn't expose an API for this
  const { execSync } = await import('child_process');
  const keysJson = execSync('npx web-push generate-vapid-keys --json', { encoding: 'utf-8' });
  const keys = JSON.parse(keysJson.trim());

  return keys;
}

// Save VAPID key to .env.local
function saveVapidKey(publicKey) {
  const envPath = '.env.local';
  let content = '';

  if (existsSync(envPath)) {
    content = readFileSync(envPath, 'utf-8');
    if (content.includes('VITE_FIREBASE_VAPID_KEY=')) {
      content = content.replace(/VITE_FIREBASE_VAPID_KEY=.*/, `VITE_FIREBASE_VAPID_KEY=${publicKey}`);
    } else {
      content += `\n# Firebase Cloud Messaging VAPID Key\nVITE_FIREBASE_VAPID_KEY=${publicKey}\n`;
    }
  } else {
    content = `# Firebase Cloud Messaging VAPID Key\nVITE_FIREBASE_VAPID_KEY=${publicKey}\n`;
  }

  writeFileSync(envPath, content.trim() + '\n');
  return envPath;
}

async function main() {
  console.log('🔑 Firebase Cloud Messaging Setup\n');
  console.log('='.repeat(50) + '\n');

  // Get stored credentials
  const creds = getFirebaseCredentials();
  if (!creds) {
    process.exit(1);
  }

  console.log('📋 Found Firebase CLI credentials');
  console.log('   Refreshing access token...\n');

  // Refresh the access token
  const accessToken = await refreshAccessToken(creds.refresh_token);
  console.log('✅ Access token refreshed\n');

  // Get project info
  console.log('🔍 Fetching project configuration...\n');
  const projectResult = await getWebPushCerts(accessToken);
  const projectData = JSON.parse(projectResult.body);
  console.log(`   Project: ${projectData.displayName || PROJECT_ID}`);
  console.log(`   Project Number: ${projectData.projectNumber || 'N/A'}\n`);

  // Generate VAPID keys
  console.log('🔑 Generating VAPID key pair...\n');
  const vapidKeys = await createWebPushCert(accessToken);
  console.log(`   Public Key: ${vapidKeys.publicKey.substring(0, 40)}...`);
  console.log('   Private Key: [GENERATED]\n');

  // Save to environment
  const envPath = saveVapidKey(vapidKeys.publicKey);
  console.log(`✅ Saved VAPID public key to ${envPath}\n`);

  // Also save private key for reference (needed for custom VAPID)
  const privateKeyPath = '.vapid-private-key';
  writeFileSync(privateKeyPath, vapidKeys.privateKey);
  console.log(`✅ Saved VAPID private key to ${privateKeyPath}\n`);

  console.log('='.repeat(50));
  console.log('\n📋 IMPORTANT NOTES:\n');
  console.log('For Firebase Cloud Messaging to work with web push, you have two options:\n');
  console.log('Option 1: Use Firebase Console VAPID Key (Recommended)');
  console.log('   1. Go to Firebase Console → Project Settings → Cloud Messaging');
  console.log('   2. Under "Web configuration", click "Generate key pair"');
  console.log('   3. Copy the generated key and update .env.local\n');
  console.log('Option 2: Use the generated VAPID key (already saved)');
  console.log('   The key has been saved to .env.local and is ready to use.\n');
  console.log('='.repeat(50) + '\n');
}

main().catch(console.error);



================================================================================
FILE: scripts/setup-fcm.mjs
================================================================================
#!/usr/bin/env node
/**
 * FCM Setup Script
 * 
 * This script helps configure Firebase Cloud Messaging for web push notifications.
 * It uses the Google Cloud Identity Platform API to get/create web push certificates.
 */

import { execSync } from 'child_process';
import { writeFileSync, existsSync, readFileSync } from 'fs';

const PROJECT_ID = 'insurance-news-ai';

// Get Firebase access token using the Firebase CLI
function getAccessToken() {
  try {
    // Firebase CLI stores credentials that we can use
    const result = execSync('npx firebase --json projects:list', { 
      encoding: 'utf-8',
      stdio: ['pipe', 'pipe', 'pipe']
    });
    // If this works, Firebase CLI is authenticated
    return true;
  } catch (error) {
    console.error('Firebase CLI not authenticated. Run: npx firebase login');
    return false;
  }
}

// Use Firebase CLI to make authenticated API calls
async function getWebPushCertificate() {
  console.log('🔍 Checking for existing web push certificate...\n');
  
  // The Firebase Console generates VAPID keys automatically when you enable Cloud Messaging
  // We can retrieve them via the Firebase Management REST API
  
  try {
    // Use firebase CLI to get the web app config which may include messaging config
    const configResult = execSync(
      `npx firebase apps:sdkconfig WEB --project ${PROJECT_ID}`,
      { encoding: 'utf-8', stdio: ['pipe', 'pipe', 'pipe'] }
    );
    
    console.log('📱 Firebase Web App Config retrieved successfully');
    
    // Parse the config to get messagingSenderId
    const configMatch = configResult.match(/"messagingSenderId":\s*"(\d+)"/);
    if (configMatch) {
      console.log(`   Messaging Sender ID: ${configMatch[1]}`);
    }
    
    return configMatch ? configMatch[1] : null;
  } catch (error) {
    console.error('Failed to get web app config:', error.message);
    return null;
  }
}

// Generate VAPID keys using web-push
function generateVapidKeys() {
  console.log('\n🔑 Generating VAPID key pair...\n');
  
  try {
    const result = execSync('npx web-push generate-vapid-keys --json', {
      encoding: 'utf-8',
      stdio: ['pipe', 'pipe', 'pipe']
    });
    
    const keys = JSON.parse(result.trim());
    console.log('   Public Key:', keys.publicKey.substring(0, 30) + '...');
    console.log('   Private Key: [HIDDEN]');
    
    return keys;
  } catch (error) {
    console.error('Failed to generate VAPID keys:', error.message);
    return null;
  }
}

// Create or update .env.local file
function updateEnvFile(vapidPublicKey) {
  const envPath = '.env.local';
  let envContent = '';
  
  if (existsSync(envPath)) {
    envContent = readFileSync(envPath, 'utf-8');
  }
  
  // Check if VAPID key already exists
  if (envContent.includes('VITE_FIREBASE_VAPID_KEY=')) {
    // Update existing key
    envContent = envContent.replace(
      /VITE_FIREBASE_VAPID_KEY=.*/,
      `VITE_FIREBASE_VAPID_KEY=${vapidPublicKey}`
    );
  } else {
    // Add new key
    envContent += `\n# Firebase Cloud Messaging VAPID Key\nVITE_FIREBASE_VAPID_KEY=${vapidPublicKey}\n`;
  }
  
  writeFileSync(envPath, envContent.trim() + '\n');
  console.log(`\n✅ Updated ${envPath} with VAPID public key`);
}

// Main setup function
async function main() {
  console.log('🚀 Firebase Cloud Messaging Setup\n');
  console.log('='.repeat(50) + '\n');
  
  // Check Firebase CLI authentication
  if (!getAccessToken()) {
    process.exit(1);
  }
  
  // Get messaging sender ID
  const senderId = await getWebPushCertificate();
  
  // Generate VAPID keys
  const vapidKeys = generateVapidKeys();
  
  if (vapidKeys) {
    // Update environment file
    updateEnvFile(vapidKeys.publicKey);
    
    // Save private key securely (for reference - Firebase handles this)
    console.log('\n📋 Setup Summary:');
    console.log('='.repeat(50));
    console.log(`   Project: ${PROJECT_ID}`);
    console.log(`   Sender ID: ${senderId || 'N/A'}`);
    console.log(`   VAPID Public Key: ${vapidKeys.publicKey.substring(0, 40)}...`);
    console.log('\n⚠️  IMPORTANT: For Firebase Cloud Messaging, you should use');
    console.log('   the VAPID key from Firebase Console instead of a custom one.');
    console.log('   Go to: Firebase Console → Project Settings → Cloud Messaging');
    console.log('   → Web configuration → Generate key pair\n');
  }
}

main().catch(console.error);



